from collections.abc import Iterator, Sequence
from typing import overload

import _pymimir


class BidirectionalClassStaticGraph:
    @overload
    def __init__(self, arg: ClassStaticGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableClassStaticGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> list[ClassEdge]: ...

    def get_edge(self, arg: int, /) -> ClassVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class BidirectionalProblemStaticGraph:
    @overload
    def __init__(self, arg: ProblemStaticGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableProblemStaticGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> list[ProblemEdge]: ...

    def get_edge(self, arg: int, /) -> ProblemVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ClassEdge:
    def get_index(self) -> int: ...

    def get_source(self) -> int: ...

    def get_target(self) -> int: ...

    def get_property_0(self) -> int: ...

    def get_property_1(self) -> int: ...

class ClassStaticGraph:
    def __init__(self) -> None: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, *args) -> int: ...

    @overload
    def add_vertex(self, arg: ClassVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, /, *args) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: ClassEdge, /) -> int: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> list[ClassEdge]: ...

    def get_edge(self, arg: int, /) -> ClassVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ClassVertex:
    def get_index(self) -> int: ...

    def get_property_0(self) -> int: ...

    def get_property_1(self) -> int: ...

class ForwardClassStaticGraph:
    @overload
    def __init__(self, arg: ClassStaticGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableClassStaticGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> list[ClassEdge]: ...

    def get_edge(self, arg: int, /) -> ClassVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ForwardProblemStaticGraph:
    @overload
    def __init__(self, arg: ProblemStaticGraph, /) -> None: ...

    @overload
    def __init__(self, arg: ImmutableProblemStaticGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> list[ProblemEdge]: ...

    def get_edge(self, arg: int, /) -> ProblemVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class GeneralizedStateSpace:
    @staticmethod
    def create(state_spaces: Sequence[StateSpace], options: GeneralizedStateSpaceOptions = ...) -> GeneralizedStateSpace: ...

    def get_state_spaces(self) -> list[StateSpace]: ...

    def get_graph(self) -> BidirectionalClassStaticGraph: ...

    def get_initial_vertices(self) -> set[int]: ...

    def get_goal_vertices(self) -> set[int]: ...

    def get_unsolvable_vertices(self) -> set[int]: ...

    @overload
    def get_state_space(self, arg: ClassVertex, /) -> StateSpace: ...

    @overload
    def get_state_space(self, arg: ClassEdge, /) -> StateSpace: ...

    def get_problem_vertex(self, arg: ClassVertex, /) -> ProblemVertex: ...

    def get_problem_edge(self, arg: ClassEdge, /) -> ProblemEdge: ...

    def get_class_vertex(self, arg: ProblemVertex, /) -> ClassVertex: ...

    def get_class_edge(self, arg: ProblemEdge, /) -> ClassEdge: ...

    def create_induced_subgraph_from_class_vertex_indices(self, arg: Sequence[int], /) -> BidirectionalClassStaticGraph: ...

    def create_induced_subgraph_from_problem_indices(self, arg: Sequence[int], /) -> BidirectionalClassStaticGraph: ...

class GeneralizedStateSpaceOptions:
    def __init__(self) -> None: ...

    @property
    def symmetry_pruning(self) -> bool: ...

    @symmetry_pruning.setter
    def symmetry_pruning(self, arg: bool, /) -> None: ...

class ImmutableClassStaticGraph:
    def __init__(self, arg: ClassStaticGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ClassVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ClassEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ClassVertex]: ...

    def get_vertex(self, vertex_index: int) -> ClassVertex: ...

    def get_edges(self) -> list[ClassEdge]: ...

    def get_edge(self, arg: int, /) -> ClassEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ImmutableProblemStaticGraph:
    def __init__(self, arg: ProblemStaticGraph, /) -> None: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> list[ProblemEdge]: ...

    def get_edge(self, arg: int, /) -> ProblemEdge: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class KnowledgeBase:
    @staticmethod
    def create(contexts: _pymimir.advanced.search.GeneralizedSearchContext, options: KnowledgeBaseOptions = ...) -> KnowledgeBase: ...

    def get_generalized_state_space(self) -> GeneralizedStateSpace | None: ...

class KnowledgeBaseOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, state_space_options: StateSpaceOptions, generalized_state_space_options: GeneralizedStateSpaceOptions, tuple_graph_options: TupleGraphOptions | None = None) -> None: ...

    @property
    def state_space_options(self) -> StateSpaceOptions: ...

    @state_space_options.setter
    def state_space_options(self, arg: StateSpaceOptions, /) -> None: ...

    @property
    def generalized_state_space_options(self) -> GeneralizedStateSpaceOptions | None: ...

    @generalized_state_space_options.setter
    def generalized_state_space_options(self, arg: GeneralizedStateSpaceOptions, /) -> None: ...

    @property
    def tuple_graph_options(self) -> TupleGraphOptions | None: ...

    @tuple_graph_options.setter
    def tuple_graph_options(self, arg: TupleGraphOptions, /) -> None: ...

class ProblemEdge:
    def get_index(self) -> int: ...

    def get_source(self) -> int: ...

    def get_target(self) -> int: ...

    def get_property_0(self) -> _pymimir.advanced.formalism.GroundAction: ...

    def get_property_1(self) -> _pymimir.advanced.formalism.Problem: ...

    def get_property_2(self) -> float: ...

class ProblemStaticGraph:
    def __init__(self) -> None: ...

    def clear(self) -> None: ...

    @overload
    def add_vertex(self, *args) -> int: ...

    @overload
    def add_vertex(self, arg: ProblemVertex, /) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, /, *args) -> int: ...

    @overload
    def add_directed_edge(self, arg0: int, arg1: int, arg2: ProblemEdge, /) -> int: ...

    def get_vertex_indices(self) -> Iterator[int]: ...

    def get_edge_indices(self) -> Iterator[int]: ...

    def get_forward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_backward_adjacent_vertices(self, vertex_index: int) -> Iterator[ProblemVertex]: ...

    def get_forward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_vertex_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_forward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_backward_adjacent_edges(self, vertex_index: int) -> Iterator[ProblemEdge]: ...

    def get_forward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_backward_adjacent_edge_indices(self, vertex_index: int) -> Iterator[int]: ...

    def get_vertices(self) -> list[ProblemVertex]: ...

    def get_vertex(self, vertex_index: int) -> ProblemVertex: ...

    def get_edges(self) -> list[ProblemEdge]: ...

    def get_edge(self, arg: int, /) -> ProblemVertex: ...

    def get_num_vertices(self) -> int: ...

    def get_num_edges(self) -> int: ...

    def get_forward_source(self, edge_index: int) -> int: ...

    def get_backward_source(self, edge_index: int) -> int: ...

    def get_forward_target(self, edge_index: int) -> int: ...

    def get_backward_target(self, edge_index: int) -> int: ...

    def get_forward_degrees(self) -> list[int]: ...

    def get_backward_degrees(self) -> list[int]: ...

    def get_forward_degree(self, vertex_index: int) -> int: ...

    def get_backward_degree(self, vertex_index: int) -> int: ...

    def compute_forward_topological_sort(self) -> list[int]: ...

    def compute_backward_topological_sort(self) -> list[int]: ...

    def compute_forward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_backward_floyd_warshall_all_pairs_shortest_paths(self, arg: Sequence[float], /) -> list[list[float]]: ...

    def compute_forward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_backward_breadth_first_search(self, arg: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<int, std::allocator<int> > >": ...

    def compute_forward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_backward_depth_first_search(self, arg: Sequence[int], /) -> list[int]: ...

    def compute_forward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_backward_dijkstra_shortest_paths(self, arg0: Sequence[float], arg1: Sequence[int], /) -> "std::tuple<std::vector<unsigned int, std::allocator<unsigned int> >, std::vector<double, std::allocator<double> > >": ...

    def compute_strong_components(self, arg0: Sequence[float], arg1: Sequence[int], /) -> tuple[int, list[int]]: ...

class ProblemVertex:
    def get_index(self) -> int: ...

    def get_property_0(self) -> _pymimir.advanced.search.State: ...

    def get_property_1(self) -> _pymimir.advanced.formalism.Problem: ...

    def get_property_2(self) -> "mimir::graphs::nauty::Certificate": ...

    def get_property_3(self) -> int: ...

    def get_property_4(self) -> float: ...

    def get_property_5(self) -> bool: ...

    def get_property_6(self) -> bool: ...

    def get_property_7(self) -> bool: ...

    def get_property_8(self) -> bool: ...

class StateSpace:
    @overload
    @staticmethod
    def create(context: _pymimir.advanced.search.SearchContext, options: StateSpaceOptions = ...) -> StateSpace | None: ...

    @overload
    @staticmethod
    def create(contexts: _pymimir.advanced.search.GeneralizedSearchContext, options: StateSpaceOptions = ...) -> list[StateSpace]: ...

    def get_search_context(self) -> _pymimir.advanced.search.SearchContext: ...

    def get_graph(self) -> BidirectionalProblemStaticGraph: ...

    def get_initial_vertex(self) -> int: ...

    def get_goal_vertices(self) -> set[int]: ...

    def get_unsolvable_vertices(self) -> set[int]: ...

class StateSpaceOptions:
    def __init__(self) -> None: ...

    @property
    def sort_ascending_by_num_states(self) -> bool: ...

    @sort_ascending_by_num_states.setter
    def sort_ascending_by_num_states(self, arg: bool, /) -> None: ...

    @property
    def symmetry_pruning(self) -> bool: ...

    @symmetry_pruning.setter
    def symmetry_pruning(self, arg: bool, /) -> None: ...

    @property
    def mark_true_goal_literals(self) -> bool: ...

    @mark_true_goal_literals.setter
    def mark_true_goal_literals(self, arg: bool, /) -> None: ...

    @property
    def remove_if_unsolvable(self) -> bool: ...

    @remove_if_unsolvable.setter
    def remove_if_unsolvable(self, arg: bool, /) -> None: ...

    @property
    def max_num_states(self) -> int: ...

    @max_num_states.setter
    def max_num_states(self, arg: int, /) -> None: ...

    @property
    def timeout_ms(self) -> int: ...

    @timeout_ms.setter
    def timeout_ms(self, arg: int, /) -> None: ...

class TupleGraphOptions:
    @overload
    def __init__(self) -> None: ...

    @overload
    def __init__(self, width: int, enable_dominance_pruning: bool) -> None: ...

    @property
    def width(self) -> int: ...

    @width.setter
    def width(self, arg: int, /) -> None: ...

    @property
    def enable_dominance_pruning(self) -> bool: ...

    @enable_dominance_pruning.setter
    def enable_dominance_pruning(self, arg: bool, /) -> None: ...
