"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceImporter = void 0;
exports.removeNonImportResources = removeNonImportResources;
const util_1 = require("util");
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const fs = require("fs-extra");
const promptly = require("promptly");
const api_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api");
const private_1 = require("../../../../@aws-cdk/tmp-toolkit-helpers/src/api/io/private");
const deployments_1 = require("../deployments");
/**
 * Resource importing utility class
 *
 * - Determines the resources added to a template (compared to the deployed version)
 * - Look up the identification information
 *   - Load them from a file, or
 *   - Ask the user, based on information supplied to us by CloudFormation's GetTemplateSummary
 * - Translate the input to a structure expected by CloudFormation, update the template to add the
 *   importable resources, then run an IMPORT changeset.
 */
class ResourceImporter {
    constructor(stack, props) {
        this.stack = stack;
        this.cfn = props.deployments;
        this.ioHelper = props.ioHelper;
    }
    /**
     * Ask the user for resources to import
     */
    async askForResourceIdentifiers(available) {
        const ret = { importResources: [], resourceMap: {} };
        const resourceIdentifiers = await this.resourceIdentifiers();
        for (const resource of available) {
            const identifier = await this.askForResourceIdentifier(resourceIdentifiers, resource);
            if (!identifier) {
                continue;
            }
            ret.importResources.push(resource);
            ret.resourceMap[resource.logicalId] = identifier;
        }
        return ret;
    }
    /**
     * Load the resources to import from a file
     */
    async loadResourceIdentifiers(available, filename) {
        const contents = await fs.readJson(filename);
        const ret = { importResources: [], resourceMap: {} };
        for (const resource of available) {
            const descr = this.describeResource(resource.logicalId);
            const idProps = contents[resource.logicalId];
            if (idProps) {
                await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg((0, util_1.format)('%s: importing using %s', chalk.blue(descr), chalk.blue(fmtdict(idProps)))));
                ret.importResources.push(resource);
                ret.resourceMap[resource.logicalId] = idProps;
                delete contents[resource.logicalId];
            }
            else {
                await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg((0, util_1.format)('%s: skipping', chalk.blue(descr))));
            }
        }
        const unknown = Object.keys(contents);
        if (unknown.length > 0) {
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_WARN.msg(`Unrecognized resource identifiers in mapping file: ${unknown.join(', ')}`));
        }
        return ret;
    }
    /**
     * Based on the provided resource mapping, prepare CFN structures for import (template,
     * ResourcesToImport structure) and perform the import operation (CloudFormation deployment)
     *
     * @param importMap Mapping from CDK construct tree path to physical resource import identifiers
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMap(importMap, options = {}) {
        const resourcesToImport = await this.makeResourcesToImport(importMap);
        const updatedTemplate = await this.currentTemplateWithAdditions(importMap.importResources);
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    /**
     * Based on the app and resources file generated by cdk migrate. Removes all items from the template that
     * cannot be included in an import change-set for new stacks and performs the import operation,
     * creating the new stack.
     *
     * @param resourcesToImport The mapping created by cdk migrate
     * @param options Options to pass to CloudFormation deploy operation
     */
    async importResourcesFromMigrate(resourcesToImport, options = {}) {
        const updatedTemplate = this.removeNonImportResources();
        await this.importResources(updatedTemplate, resourcesToImport, options);
    }
    async importResources(overrideTemplate, resourcesToImport, options) {
        try {
            const result = await this.cfn.deployStack({
                stack: this.stack,
                deployName: this.stack.stackName,
                ...options,
                overrideTemplate,
                resourcesToImport,
            });
            (0, deployments_1.assertIsSuccessfulDeployStackResult)(result);
            const message = result.noOp
                ? ' ✅  %s (no changes)'
                : ' ✅  %s';
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg('\n' + chalk.green((0, util_1.format)(message, this.stack.displayName))));
        }
        catch (e) {
            await this.ioHelper.notify(private_1.IO.CDK_TOOLKIT_E3900.msg((0, util_1.format)('\n ❌  %s failed: %s', chalk.bold(this.stack.displayName), e), { error: e }));
            throw e;
        }
    }
    /**
     * Perform a diff between the currently running and the new template, ensure that it is valid
     * for importing and return a list of resources that are being added in the new version
     *
     * @return mapping logicalResourceId -> resourceDifference
     */
    async discoverImportableResources(allowNonAdditions = false) {
        const currentTemplate = await this.currentTemplate();
        const diff = cfnDiff.fullDiff(currentTemplate, this.stack.template);
        // Ignore changes to CDKMetadata
        const resourceChanges = Object.entries(diff.resources.changes)
            .filter(([logicalId, _]) => logicalId !== 'CDKMetadata');
        // Split the changes into additions and non-additions. Imports only make sense
        // for newly-added resources.
        const nonAdditions = resourceChanges.filter(([_, dif]) => !dif.isAddition);
        const additions = resourceChanges.filter(([_, dif]) => dif.isAddition);
        if (nonAdditions.length) {
            const offendingResources = nonAdditions.map(([logId, _]) => this.describeResource(logId));
            if (allowNonAdditions) {
                await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_WARN.msg(`Ignoring updated/deleted resources (--force): ${offendingResources.join(', ')}`));
            }
            else {
                throw new api_1.ToolkitError('No resource updates or deletes are allowed on import operation. Make sure to resolve pending changes ' +
                    `to existing resources, before attempting an import. Updated/deleted resources: ${offendingResources.join(', ')} (--force to override)`);
            }
        }
        // Resources in the new template, that are not present in the current template, are a potential import candidates
        return {
            additions: additions.map(([logicalId, resourceDiff]) => ({
                logicalId,
                resourceDiff,
                resourceDefinition: addDefaultDeletionPolicy(this.stack.template?.Resources?.[logicalId] ?? {}),
            })),
            hasNonAdditions: nonAdditions.length > 0,
        };
    }
    /**
     * Resolves the environment of a stack.
     */
    async resolveEnvironment() {
        return this.cfn.resolveEnvironment(this.stack);
    }
    /**
     * Get currently deployed template of the given stack (SINGLETON)
     *
     * @returns Currently deployed CloudFormation template
     */
    async currentTemplate() {
        if (!this._currentTemplate) {
            this._currentTemplate = await this.cfn.readCurrentTemplate(this.stack);
        }
        return this._currentTemplate;
    }
    /**
     * Return the current template, with the given resources added to it
     */
    async currentTemplateWithAdditions(additions) {
        const template = await this.currentTemplate();
        if (!template.Resources) {
            template.Resources = {};
        }
        for (const add of additions) {
            template.Resources[add.logicalId] = add.resourceDefinition;
        }
        return template;
    }
    /**
     * Get a list of import identifiers for all resource types used in the given
     * template that do support the import operation (SINGLETON)
     *
     * @returns a mapping from a resource type to a list of property names that together identify the resource for import
     */
    async resourceIdentifiers() {
        const ret = {};
        const resourceIdentifierSummaries = await this.cfn.resourceIdentifierSummaries(this.stack);
        for (const summary of resourceIdentifierSummaries) {
            if ('ResourceType' in summary && summary.ResourceType && 'ResourceIdentifiers' in summary && summary.ResourceIdentifiers) {
                ret[summary.ResourceType] = (summary.ResourceIdentifiers ?? [])?.map(x => x.split(','));
            }
        }
        return ret;
    }
    /**
     * Ask for the importable identifier for the given resource
     *
     * There may be more than one identifier under which a resource can be imported. The `import`
     * operation needs exactly one of them.
     *
     * - If we can get one from the template, we will use one.
     * - Otherwise, we will ask the user for one of them.
     */
    async askForResourceIdentifier(resourceIdentifiers, chg) {
        const resourceName = this.describeResource(chg.logicalId);
        // Skip resources that do not support importing
        const resourceType = chg.resourceDiff.newResourceType;
        if (resourceType === undefined || !(resourceType in resourceIdentifiers)) {
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_WARN.msg(`${resourceName}: unsupported resource type ${resourceType}, skipping import.`));
            return undefined;
        }
        const idPropSets = resourceIdentifiers[resourceType];
        // Retain only literal strings: strip potential CFN intrinsics
        const resourceProps = Object.fromEntries(Object.entries(chg.resourceDefinition.Properties ?? {})
            .filter(([_, v]) => typeof v === 'string'));
        // Find property sets that are fully satisfied in the template, ask the user to confirm them
        const satisfiedPropSets = idPropSets.filter(ps => ps.every(p => resourceProps[p]));
        for (const satisfiedPropSet of satisfiedPropSets) {
            const candidateProps = Object.fromEntries(satisfiedPropSet.map(p => [p, resourceProps[p]]));
            const displayCandidateProps = fmtdict(candidateProps);
            if (await promptly.confirm(`${chalk.blue(resourceName)} (${resourceType}): import with ${chalk.yellow(displayCandidateProps)} (yes/no) [default: yes]? `, { default: 'yes' })) {
                return candidateProps;
            }
        }
        // If we got here and the user rejected any available identifiers, then apparently they don't want the resource at all
        if (satisfiedPropSets.length > 0) {
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(chalk.grey(`Skipping import of ${resourceName}`)));
            return undefined;
        }
        // We cannot auto-import this, ask the user for one of the props
        // The only difference between these cases is what we print: for multiple properties, we print a preamble
        const prefix = `${chalk.blue(resourceName)} (${resourceType})`;
        let preamble;
        let promptPattern;
        if (idPropSets.length > 1) {
            preamble = `${prefix}: enter one of ${idPropSets.map(x => chalk.blue(x.join('+'))).join(', ')} to import (all empty to skip)`;
            promptPattern = `${prefix}: enter %`;
        }
        else {
            promptPattern = `${prefix}: enter %`;
        }
        // Do the input loop here
        if (preamble) {
            await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(preamble));
        }
        for (const idProps of idPropSets) {
            const input = {};
            for (const idProp of idProps) {
                // If we have a value from the template, use it as default. This will only be a partial
                // identifier if present, otherwise we would have done the import already above.
                const defaultValue = resourceProps[idProp] ?? '';
                const prompt = [
                    promptPattern.replace(/%/g, chalk.blue(idProp)),
                    defaultValue
                        ? `[${defaultValue}]`
                        : '(empty to skip)',
                ].join(' ') + ':';
                const response = await promptly.prompt(prompt, { default: defaultValue, trim: true });
                if (!response) {
                    break;
                }
                input[idProp] = response;
                // Also stick this property into 'resourceProps', so that it may be reused by a subsequent question
                // (for a different compound identifier that involves the same property). Just a small UX enhancement.
                resourceProps[idProp] = response;
            }
            // If the user gave inputs for all values, we are complete
            if (Object.keys(input).length === idProps.length) {
                return input;
            }
        }
        await this.ioHelper.notify(private_1.IO.DEFAULT_TOOLKIT_INFO.msg(chalk.grey(`Skipping import of ${resourceName}`)));
        return undefined;
    }
    /**
     * Convert the internal "resource mapping" structure to CloudFormation accepted "ResourcesToImport" structure
     */
    async makeResourcesToImport(resourceMap) {
        return resourceMap.importResources.map(res => ({
            LogicalResourceId: res.logicalId,
            ResourceType: res.resourceDiff.newResourceType,
            ResourceIdentifier: resourceMap.resourceMap[res.logicalId],
        }));
    }
    /**
     * Convert CloudFormation logical resource ID to CDK construct tree path
     *
     * @param logicalId CloudFormation logical ID of the resource (the key in the template's Resources section)
     * @returns Forward-slash separated path of the resource in CDK construct tree, e.g. MyStack/MyBucket/Resource
     */
    describeResource(logicalId) {
        return this.stack.template?.Resources?.[logicalId]?.Metadata?.['aws:cdk:path'] ?? logicalId;
    }
    /**
     * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
     * @returns template with import resources only
     */
    removeNonImportResources() {
        return removeNonImportResources(this.stack);
    }
}
exports.ResourceImporter = ResourceImporter;
/**
 * Removes CDKMetadata and Outputs in the template so that only resources for importing are left.
 * @returns template with import resources only
 */
function removeNonImportResources(stack) {
    const template = stack.template;
    delete template.Resources.CDKMetadata;
    delete template.Outputs;
    return template;
}
function fmtdict(xs) {
    return Object.entries(xs).map(([k, v]) => `${k}=${v}`).join(', ');
}
/**
 * Add a default `DeletionPolicy` policy.
 * The default value is set to 'Retain', to lower risk of unintentionally
 * deleting stateful resources in the process of importing to CDK.
 */
function addDefaultDeletionPolicy(resource) {
    if (resource.DeletionPolicy) {
        return resource;
    }
    return {
        ...resource,
        DeletionPolicy: 'Retain',
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1wb3J0ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbXBvcnRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFpY0EsNERBS0M7QUF0Y0QsK0JBQThCO0FBQzlCLHdEQUF3RDtBQUl4RCwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQywwRUFBZ0Y7QUFDaEYseUZBQWdHO0FBRWhHLGdEQUFxRTtBQW1GckU7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBYSxnQkFBZ0I7SUFPM0IsWUFDRSxLQUF3QyxFQUN4QyxLQUE0QjtRQUU1QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7UUFDN0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO0lBQ2pDLENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxTQUErQjtRQUNwRSxNQUFNLEdBQUcsR0FBYyxFQUFFLGVBQWUsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxDQUFDO1FBQ2hFLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUU3RCxLQUFLLE1BQU0sUUFBUSxJQUFJLFNBQVMsRUFBRSxDQUFDO1lBQ2pDLE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3RGLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztnQkFDaEIsU0FBUztZQUNYLENBQUM7WUFFRCxHQUFHLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNuQyxHQUFHLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxVQUFVLENBQUM7UUFDbkQsQ0FBQztRQUVELE9BQU8sR0FBRyxD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LENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNwRSxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsd0JBQXdCLENBQUMsUUFBYTtJQUM3QyxJQUFJLFFBQVEsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUM1QixPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRUQsT0FBTztRQUNMLEdBQUcsUUFBUTtRQUNYLGNBQWMsRUFBRSxRQUFRO0tBQ3pCLENBQUM7QUFDSixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjZm5EaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHR5cGUgeyBSZXNvdXJjZURpZmZlcmVuY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB0eXBlICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB0eXBlIHsgUmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyeSwgUmVzb3VyY2VUb0ltcG9ydCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZGZvcm1hdGlvbic7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyBwcm9tcHRseSBmcm9tICdwcm9tcHRseSc7XG5pbXBvcnQgeyBUb29sa2l0RXJyb3IgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGknO1xuaW1wb3J0IHsgSU8sIHR5cGUgSW9IZWxwZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9AYXdzLWNkay90bXAtdG9vbGtpdC1oZWxwZXJzL3NyYy9hcGkvaW8vcHJpdmF0ZSc7XG5pbXBvcnQgdHlwZSB7IERlcGxveW1lbnRNZXRob2QsIERlcGxveW1lbnRzIH0gZnJvbSAnLi4vZGVwbG95bWVudHMnO1xuaW1wb3J0IHsgYXNzZXJ0SXNTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuLi9kZXBsb3ltZW50cyc7XG5pbXBvcnQgdHlwZSB7IFRhZyB9IGZyb20gJy4uL3RhZ3MnO1xuXG5leHBvcnQgdHlwZSBSZXNvdXJjZXNUb0ltcG9ydCA9IFJlc291cmNlVG9JbXBvcnRbXTtcbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyA9IFJlc291cmNlSWRlbnRpZmllclN1bW1hcnlbXTtcblxuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZUltcG9ydGVyUHJvcHMge1xuICBkZXBsb3ltZW50czogRGVwbG95bWVudHM7XG4gIGlvSGVscGVyOiBJb0hlbHBlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJbXBvcnREZXBsb3ltZW50T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBSb2xlIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gZm9yIGRlcGxveW1lbnRcbiAgICpcbiAgICogQGRlZmF1bHQgLSBEZWZhdWx0IHN0YWNrIHJvbGVcbiAgICovXG4gIHJlYWRvbmx5IHJvbGVBcm4/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIERlcGxveW1lbnQgbWV0aG9kXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQ2hhbmdlIHNldCB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgZGVwbG95bWVudE1ldGhvZD86IERlcGxveW1lbnRNZXRob2Q7XG5cbiAgLyoqXG4gICAqIFN0YWNrIHRhZ3MgKHBhc3MgdGhyb3VnaCB0byBDbG91ZEZvcm1hdGlvbilcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyB0YWdzXG4gICAqL1xuICByZWFkb25seSB0YWdzPzogVGFnW107XG5cbiAgLyoqXG4gICAqIFVzZSBwcmV2aW91cyB2YWx1ZXMgZm9yIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogSWYgbm90IHNldCwgYWxsIHBhcmFtZXRlcnMgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIGV2ZXJ5IGRlcGxveW1lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHVzZVByZXZpb3VzUGFyYW1ldGVycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJvbGxiYWNrIGZhaWxlZCBkZXBsb3ltZW50c1xuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSByb2xsYmFjaz86IGJvb2xlYW47XG59XG5cbi8qKlxuICogU2V0IG9mIHBhcmFtZXRlcnMgdGhhdCB1bmlxdWVseSBpZGVudGlmeSBhIHBoeXNpY2FsIHJlc291cmNlIG9mIGEgZ2l2ZW4gdHlwZVxuICogZm9yIHRoZSBpbXBvcnQgb3BlcmF0aW9uLCBleGFtcGxlOlxuICpcbiAqIGBgYFxuICoge1xuICogICBcIkFXUzo6UzM6OkJ1Y2tldFwiOiBbW1wiQnVja2V0TmFtZVwiXV0sXG4gKiAgIFwiQVdTOjpEeW5hbW9EQjo6R2xvYmFsVGFibGVcIjogW1tcIlRhYmxlTmFtZVwiXSwgW1wiVGFibGVBcm5cIl0sIFtcIlRhYmxlU3RyZWFtQXJuXCJdXSxcbiAqICAgXCJBV1M6OlJvdXRlNTM6OktleVNpZ25pbmdLZXlcIjogW1tcIkhvc3RlZFpvbmVJZFwiLCBcIk5hbWVcIl1dLFxuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCB0eXBlIFJlc291cmNlSWRlbnRpZmllcnMgPSB7IFtyZXNvdXJjZVR5cGU6IHN0cmluZ106IHN0cmluZ1tdW10gfTtcblxudHlwZSBSZXNvdXJjZUlkZW50aWZpZXJQcm9wZXJ0aWVzID0gUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuLyoqXG4gKiBNYXBwaW5nIG9mIENESyByZXNvdXJjZXMgKEwxIGNvbnN0cnVjdHMpIHRvIHBoeXNpY2FsIHJlc291cmNlcyB0byBiZSBpbXBvcnRlZFxuICogaW4gdGhlaXIgcGxhY2UsIGV4YW1wbGU6XG4gKlxuICogYGBgXG4gKiB7XG4gKiAgIFwiTXlTdGFjay9NeVMzQnVja2V0L1Jlc291cmNlXCI6IHtcbiAqICAgICBcIkJ1Y2tldE5hbWVcIjogXCJteS1tYW51YWxseS1jcmVhdGVkLXMzLWJ1Y2tldFwiXG4gKiAgIH0sXG4gKiAgIFwiTXlTdGFjay9NeVZwYy9SZXNvdXJjZVwiOiB7XG4gKiAgICAgXCJWcGNJZFwiOiBcInZwYy0xMjM0NTY3ODlcIlxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xudHlwZSBSZXNvdXJjZU1hcCA9IHsgW2xvZ2ljYWxSZXNvdXJjZTogc3RyaW5nXTogUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyB9O1xuXG4vKipcbiAqIFJlc291cmNlIGltcG9ydGluZyB1dGlsaXR5IGNsYXNzXG4gKlxuICogLSBEZXRlcm1pbmVzIHRoZSByZXNvdXJjZXMgYWRkZWQgdG8gYSB0ZW1wbGF0ZSAoY29tcGFyZWQgdG8gdGhlIGRlcGxveWVkIHZlcnNpb24pXG4gKiAtIExvb2sgdXAgdGhlIGlkZW50aWZpY2F0aW9uIGluZm9ybWF0aW9uXG4gKiAgIC0gTG9hZCB0aGVtIGZyb20gYSBmaWxlLCBvclxuICogICAtIEFzayB0aGUgdXNlciwgYmFzZWQgb24gaW5mb3JtYXRpb24gc3VwcGxpZWQgdG8gdXMgYnkgQ2xvdWRGb3JtYXRpb24ncyBHZXRUZW1wbGF0ZVN1bW1hcnlcbiAqIC0gVHJhbnNsYXRlIHRoZSBpbnB1dCB0byBhIHN0cnVjdHVyZSBleHBlY3RlZCBieSBDbG91ZEZvcm1hdGlvbiwgdXBkYXRlIHRoZSB0ZW1wbGF0ZSB0byBhZGQgdGhlXG4gKiAgIGltcG9ydGFibGUgcmVzb3VyY2VzLCB0aGVuIHJ1biBhbiBJTVBPUlQgY2hhbmdlc2V0LlxuICovXG5leHBvcnQgY2xhc3MgUmVzb3VyY2VJbXBvcnRlciB7XG4gIHByaXZhdGUgX2N1cnJlbnRUZW1wbGF0ZTogYW55O1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbiAgcHJpdmF0ZSByZWFkb25seSBjZm46IERlcGxveW1lbnRzO1xuICBwcml2YXRlIHJlYWRvbmx5IGlvSGVscGVyOiBJb0hlbHBlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICAgIHByb3BzOiBSZXNvdXJjZUltcG9ydGVyUHJvcHMsXG4gICkge1xuICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB0aGlzLmNmbiA9IHByb3BzLmRlcGxveW1lbnRzO1xuICAgIHRoaXMuaW9IZWxwZXIgPSBwcm9wcy5pb0hlbHBlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc2sgdGhlIHVzZXIgZm9yIHJlc291cmNlcyB0byBpbXBvcnRcbiAgICovXG4gIHB1YmxpYyBhc3luYyBhc2tGb3JSZXNvdXJjZUlkZW50aWZpZXJzKGF2YWlsYWJsZTogSW1wb3J0YWJsZVJlc291cmNlW10pOiBQcm9taXNlPEltcG9ydE1hcD4ge1xuICAgIGNvbnN0IHJldDogSW1wb3J0TWFwID0geyBpbXBvcnRSZXNvdXJjZXM6IFtdLCByZXNvdXJjZU1hcDoge30gfTtcbiAgICBjb25zdCByZXNvdXJjZUlkZW50aWZpZXJzID0gYXdhaXQgdGhpcy5yZXNvdXJjZUlkZW50aWZpZXJzKCk7XG5cbiAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIGF2YWlsYWJsZSkge1xuICAgICAgY29uc3QgaWRlbnRpZmllciA9IGF3YWl0IHRoaXMuYXNrRm9yUmVzb3VyY2VJZGVudGlmaWVyKHJlc291cmNlSWRlbnRpZmllcnMsIHJlc291cmNlKTtcbiAgICAgIGlmICghaWRlbnRpZmllcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmV0LmltcG9ydFJlc291cmNlcy5wdXNoKHJlc291cmNlKTtcbiAgICAgIHJldC5yZXNvdXJjZU1hcFtyZXNvdXJjZS5sb2dpY2FsSWRdID0gaWRlbnRpZmllcjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgdGhlIHJlc291cmNlcyB0byBpbXBvcnQgZnJvbSBhIGZpbGVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBsb2FkUmVzb3VyY2VJZGVudGlmaWVycyhhdmFpbGFibGU6IEltcG9ydGFibGVSZXNvdXJjZVtdLCBmaWxlbmFtZTogc3RyaW5nKTogUHJvbWlzZTxJbXBvcnRNYXA+IHtcbiAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IGZzLnJlYWRKc29uKGZpbGVuYW1lKTtcblxuICAgIGNvbnN0IHJldDogSW1wb3J0TWFwID0geyBpbXBvcnRSZXNvdXJjZXM6IFtdLCByZXNvdXJjZU1hcDoge30gfTtcbiAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIGF2YWlsYWJsZSkge1xuICAgICAgY29uc3QgZGVzY3IgPSB0aGlzLmRlc2NyaWJlUmVzb3VyY2UocmVzb3VyY2UubG9naWNhbElkKTtcbiAgICAgIGNvbnN0IGlkUHJvcHMgPSBjb250ZW50c1tyZXNvdXJjZS5sb2dpY2FsSWRdO1xuICAgICAgaWYgKGlkUHJvcHMpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGZvcm1hdCgnJXM6IGltcG9ydGluZyB1c2luZyAlcycsIGNoYWxrLmJsdWUoZGVzY3IpLCBjaGFsay5ibHVlKGZtdGRpY3QoaWRQcm9wcykpKSkpO1xuXG4gICAgICAgIHJldC5pbXBvcnRSZXNvdXJjZXMucHVzaChyZXNvdXJjZSk7XG4gICAgICAgIHJldC5yZXNvdXJjZU1hcFtyZXNvdXJjZS5sb2dpY2FsSWRdID0gaWRQcm9wcztcbiAgICAgICAgZGVsZXRlIGNvbnRlbnRzW3Jlc291cmNlLmxvZ2ljYWxJZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfSU5GTy5tc2coZm9ybWF0KCclczogc2tpcHBpbmcnLCBjaGFsay5ibHVlKGRlc2NyKSkpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB1bmtub3duID0gT2JqZWN0LmtleXMoY29udGVudHMpO1xuICAgIGlmICh1bmtub3duLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfVE9PTEtJVF9XQVJOLm1zZyhgVW5yZWNvZ25pemVkIHJlc291cmNlIGlkZW50aWZpZXJzIGluIG1hcHBpbmcgZmlsZTogJHt1bmtub3duLmpvaW4oJywgJyl9YCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogQmFzZWQgb24gdGhlIHByb3ZpZGVkIHJlc291cmNlIG1hcHBpbmcsIHByZXBhcmUgQ0ZOIHN0cnVjdHVyZXMgZm9yIGltcG9ydCAodGVtcGxhdGUsXG4gICAqIFJlc291cmNlc1RvSW1wb3J0IHN0cnVjdHVyZSkgYW5kIHBlcmZvcm0gdGhlIGltcG9ydCBvcGVyYXRpb24gKENsb3VkRm9ybWF0aW9uIGRlcGxveW1lbnQpXG4gICAqXG4gICAqIEBwYXJhbSBpbXBvcnRNYXAgTWFwcGluZyBmcm9tIENESyBjb25zdHJ1Y3QgdHJlZSBwYXRoIHRvIHBoeXNpY2FsIHJlc291cmNlIGltcG9ydCBpZGVudGlmaWVyc1xuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gZGVwbG95IG9wZXJhdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGltcG9ydFJlc291cmNlc0Zyb21NYXAoaW1wb3J0TWFwOiBJbXBvcnRNYXAsIG9wdGlvbnM6IEltcG9ydERlcGxveW1lbnRPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByZXNvdXJjZXNUb0ltcG9ydDogUmVzb3VyY2VzVG9JbXBvcnQgPSBhd2FpdCB0aGlzLm1ha2VSZXNvdXJjZXNUb0ltcG9ydChpbXBvcnRNYXApO1xuICAgIGNvbnN0IHVwZGF0ZWRUZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY3VycmVudFRlbXBsYXRlV2l0aEFkZGl0aW9ucyhpbXBvcnRNYXAuaW1wb3J0UmVzb3VyY2VzKTtcblxuICAgIGF3YWl0IHRoaXMuaW1wb3J0UmVzb3VyY2VzKHVwZGF0ZWRUZW1wbGF0ZSwgcmVzb3VyY2VzVG9JbXBvcnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhc2VkIG9uIHRoZSBhcHAgYW5kIHJlc291cmNlcyBmaWxlIGdlbmVyYXRlZCBieSBjZGsgbWlncmF0ZS4gUmVtb3ZlcyBhbGwgaXRlbXMgZnJvbSB0aGUgdGVtcGxhdGUgdGhhdFxuICAgKiBjYW5ub3QgYmUgaW5jbHVkZWQgaW4gYW4gaW1wb3J0IGNoYW5nZS1zZXQgZm9yIG5ldyBzdGFja3MgYW5kIHBlcmZvcm1zIHRoZSBpbXBvcnQgb3BlcmF0aW9uLFxuICAgKiBjcmVhdGluZyB0aGUgbmV3IHN0YWNrLlxuICAgKlxuICAgKiBAcGFyYW0gcmVzb3VyY2VzVG9JbXBvcnQgVGhlIG1hcHBpbmcgY3JlYXRlZCBieSBjZGsgbWlncmF0ZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIHRvIHBhc3MgdG8gQ2xvdWRGb3JtYXRpb24gZGVwbG95IG9wZXJhdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIGltcG9ydFJlc291cmNlc0Zyb21NaWdyYXRlKHJlc291cmNlc1RvSW1wb3J0OiBSZXNvdXJjZXNUb0ltcG9ydCwgb3B0aW9uczogSW1wb3J0RGVwbG95bWVudE9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVwZGF0ZWRUZW1wbGF0ZSA9IHRoaXMucmVtb3ZlTm9uSW1wb3J0UmVzb3VyY2VzKCk7XG5cbiAgICBhd2FpdCB0aGlzLmltcG9ydFJlc291cmNlcyh1cGRhdGVkVGVtcGxhdGUsIHJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW1wb3J0UmVzb3VyY2VzKG92ZXJyaWRlVGVtcGxhdGU6IGFueSwgcmVzb3VyY2VzVG9JbXBvcnQ6IFJlc291cmNlc1RvSW1wb3J0LCBvcHRpb25zOiBJbXBvcnREZXBsb3ltZW50T3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNmbi5kZXBsb3lTdGFjayh7XG4gICAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgICBkZXBsb3lOYW1lOiB0aGlzLnN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgb3ZlcnJpZGVUZW1wbGF0ZSxcbiAgICAgICAgcmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICB9KTtcblxuICAgICAgYXNzZXJ0SXNTdWNjZXNzZnVsRGVwbG95U3RhY2tSZXN1bHQocmVzdWx0KTtcblxuICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3VsdC5ub09wXG4gICAgICAgID8gJyDinIUgICVzIChubyBjaGFuZ2VzKSdcbiAgICAgICAgOiAnIOKchSAgJXMnO1xuXG4gICAgICBhd2FpdCB0aGlzLmlvSGVscGVyLm5vdGlmeShJTy5ERUZBVUxUX1RPT0xLSVRfSU5GTy5tc2coJ1xcbicgKyBjaGFsay5ncmVlbihmb3JtYXQobWVzc2FnZSwgdGhpcy5zdGFjay5kaXNwbGF5TmFtZSkpKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uQ0RLX1RPT0xLSVRfRTM5MDAubXNnKGZvcm1hdCgnXFxuIOKdjCAgJXMgZmFpbGVkOiAlcycsIGNoYWxrLmJvbGQodGhpcy5zdGFjay5kaXNwbGF5TmFtZSksIGUpLCB7IGVycm9yOiBlIGFzIGFueSB9KSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgZGlmZiBiZXR3ZWVuIHRoZSBjdXJyZW50bHkgcnVubmluZyBhbmQgdGhlIG5ldyB0ZW1wbGF0ZSwgZW5zdXJlIHRoYXQgaXQgaXMgdmFsaWRcbiAgICogZm9yIGltcG9ydGluZyBhbmQgcmV0dXJuIGEgbGlzdCBvZiByZXNvdXJjZXMgdGhhdCBhcmUgYmVpbmcgYWRkZWQgaW4gdGhlIG5ldyB2ZXJzaW9uXG4gICAqXG4gICAqIEByZXR1cm4gbWFwcGluZyBsb2dpY2FsUmVzb3VyY2VJZCAtPiByZXNvdXJjZURpZmZlcmVuY2VcbiAgICovXG4gIHB1YmxpYyBhc3luYyBkaXNjb3ZlckltcG9ydGFibGVSZXNvdXJjZXMoYWxsb3dOb25BZGRpdGlvbnMgPSBmYWxzZSk6IFByb21pc2U8RGlzY292ZXJJbXBvcnRhYmxlUmVzb3VyY2VzUmVzdWx0PiB7XG4gICAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgdGhpcy5jdXJyZW50VGVtcGxhdGUoKTtcblxuICAgIGNvbnN0IGRpZmYgPSBjZm5EaWZmLmZ1bGxEaWZmKGN1cnJlbnRUZW1wbGF0ZSwgdGhpcy5zdGFjay50ZW1wbGF0ZSk7XG5cbiAgICAvLyBJZ25vcmUgY2hhbmdlcyB0byBDREtNZXRhZGF0YVxuICAgIGNvbnN0IHJlc291cmNlQ2hhbmdlcyA9IE9iamVjdC5lbnRyaWVzKGRpZmYucmVzb3VyY2VzLmNoYW5nZXMpXG4gICAgICAuZmlsdGVyKChbbG9naWNhbElkLCBfXSkgPT4gbG9naWNhbElkICE9PSAnQ0RLTWV0YWRhdGEnKTtcblxuICAgIC8vIFNwbGl0IHRoZSBjaGFuZ2VzIGludG8gYWRkaXRpb25zIGFuZCBub24tYWRkaXRpb25zLiBJbXBvcnRzIG9ubHkgbWFrZSBzZW5zZVxuICAgIC8vIGZvciBuZXdseS1hZGRlZCByZXNvdXJjZXMuXG4gICAgY29uc3Qgbm9uQWRkaXRpb25zID0gcmVzb3VyY2VDaGFuZ2VzLmZpbHRlcigoW18sIGRpZl0pID0+ICFkaWYuaXNBZGRpdGlvbik7XG4gICAgY29uc3QgYWRkaXRpb25zID0gcmVzb3VyY2VDaGFuZ2VzLmZpbHRlcigoW18sIGRpZl0pID0+IGRpZi5pc0FkZGl0aW9uKTtcblxuICAgIGlmIChub25BZGRpdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZlbmRpbmdSZXNvdXJjZXMgPSBub25BZGRpdGlvbnMubWFwKChbbG9nSWQsIF9dKSA9PiB0aGlzLmRlc2NyaWJlUmVzb3VyY2UobG9nSWQpKTtcblxuICAgICAgaWYgKGFsbG93Tm9uQWRkaXRpb25zKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfVE9PTEtJVF9XQVJOLm1zZyhgSWdub3JpbmcgdXBkYXRlZC9kZWxldGVkIHJlc291cmNlcyAoLS1mb3JjZSk6ICR7b2ZmZW5kaW5nUmVzb3VyY2VzLmpvaW4oJywgJyl9YCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xraXRFcnJvcignTm8gcmVzb3VyY2UgdXBkYXRlcyBvciBkZWxldGVzIGFyZSBhbGxvd2VkIG9uIGltcG9ydCBvcGVyYXRpb24uIE1ha2Ugc3VyZSB0byByZXNvbHZlIHBlbmRpbmcgY2hhbmdlcyAnICtcbiAgICAgICAgICBgdG8gZXhpc3RpbmcgcmVzb3VyY2VzLCBiZWZvcmUgYXR0ZW1wdGluZyBhbiBpbXBvcnQuIFVwZGF0ZWQvZGVsZXRlZCByZXNvdXJjZXM6ICR7b2ZmZW5kaW5nUmVzb3VyY2VzLmpvaW4oJywgJyl9ICgtLWZvcmNlIHRvIG92ZXJyaWRlKWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlc291cmNlcyBpbiB0aGUgbmV3IHRlbXBsYXRlLCB0aGF0IGFyZSBub3QgcHJlc2VudCBpbiB0aGUgY3VycmVudCB0ZW1wbGF0ZSwgYXJlIGEgcG90ZW50aWFsIGltcG9ydCBjYW5kaWRhdGVzXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZGl0aW9uczogYWRkaXRpb25zLm1hcCgoW2xvZ2ljYWxJZCwgcmVzb3VyY2VEaWZmXSkgPT4gKHtcbiAgICAgICAgbG9naWNhbElkLFxuICAgICAgICByZXNvdXJjZURpZmYsXG4gICAgICAgIHJlc291cmNlRGVmaW5pdGlvbjogYWRkRGVmYXVsdERlbGV0aW9uUG9saWN5KHRoaXMuc3RhY2sudGVtcGxhdGU/LlJlc291cmNlcz8uW2xvZ2ljYWxJZF0gPz8ge30pLFxuICAgICAgfSkpLFxuICAgICAgaGFzTm9uQWRkaXRpb25zOiBub25BZGRpdGlvbnMubGVuZ3RoID4gMCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIHRoZSBlbnZpcm9ubWVudCBvZiBhIHN0YWNrLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlc29sdmVFbnZpcm9ubWVudCgpOiBQcm9taXNlPGN4YXBpLkVudmlyb25tZW50PiB7XG4gICAgcmV0dXJuIHRoaXMuY2ZuLnJlc29sdmVFbnZpcm9ubWVudCh0aGlzLnN0YWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudGx5IGRlcGxveWVkIHRlbXBsYXRlIG9mIHRoZSBnaXZlbiBzdGFjayAoU0lOR0xFVE9OKVxuICAgKlxuICAgKiBAcmV0dXJucyBDdXJyZW50bHkgZGVwbG95ZWQgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3VycmVudFRlbXBsYXRlKCk6IFByb21pc2U8YW55PiB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50VGVtcGxhdGUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY2ZuLnJlYWRDdXJyZW50VGVtcGxhdGUodGhpcy5zdGFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHRlbXBsYXRlLCB3aXRoIHRoZSBnaXZlbiByZXNvdXJjZXMgYWRkZWQgdG8gaXRcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgY3VycmVudFRlbXBsYXRlV2l0aEFkZGl0aW9ucyhhZGRpdGlvbnM6IEltcG9ydGFibGVSZXNvdXJjZVtdKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IHRoaXMuY3VycmVudFRlbXBsYXRlKCk7XG4gICAgaWYgKCF0ZW1wbGF0ZS5SZXNvdXJjZXMpIHtcbiAgICAgIHRlbXBsYXRlLlJlc291cmNlcyA9IHt9O1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYWRkIG9mIGFkZGl0aW9ucykge1xuICAgICAgdGVtcGxhdGUuUmVzb3VyY2VzW2FkZC5sb2dpY2FsSWRdID0gYWRkLnJlc291cmNlRGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgbGlzdCBvZiBpbXBvcnQgaWRlbnRpZmllcnMgZm9yIGFsbCByZXNvdXJjZSB0eXBlcyB1c2VkIGluIHRoZSBnaXZlblxuICAgKiB0ZW1wbGF0ZSB0aGF0IGRvIHN1cHBvcnQgdGhlIGltcG9ydCBvcGVyYXRpb24gKFNJTkdMRVRPTilcbiAgICpcbiAgICogQHJldHVybnMgYSBtYXBwaW5nIGZyb20gYSByZXNvdXJjZSB0eXBlIHRvIGEgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IHRvZ2V0aGVyIGlkZW50aWZ5IHRoZSByZXNvdXJjZSBmb3IgaW1wb3J0XG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlc291cmNlSWRlbnRpZmllcnMoKTogUHJvbWlzZTxSZXNvdXJjZUlkZW50aWZpZXJzPiB7XG4gICAgY29uc3QgcmV0OiBSZXNvdXJjZUlkZW50aWZpZXJzID0ge307XG4gICAgY29uc3QgcmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzID0gYXdhaXQgdGhpcy5jZm4ucmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzKHRoaXMuc3RhY2spO1xuICAgIGZvciAoY29uc3Qgc3VtbWFyeSBvZiByZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMpIHtcbiAgICAgIGlmICgnUmVzb3VyY2VUeXBlJyBpbiBzdW1tYXJ5ICYmIHN1bW1hcnkuUmVzb3VyY2VUeXBlICYmICdSZXNvdXJjZUlkZW50aWZpZXJzJyBpbiBzdW1tYXJ5ICYmIHN1bW1hcnkuUmVzb3VyY2VJZGVudGlmaWVycykge1xuICAgICAgICByZXRbc3VtbWFyeS5SZXNvdXJjZVR5cGVdID0gKHN1bW1hcnkuUmVzb3VyY2VJZGVudGlmaWVycyA/PyBbXSk/Lm1hcCh4ID0+IHguc3BsaXQoJywnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogQXNrIGZvciB0aGUgaW1wb3J0YWJsZSBpZGVudGlmaWVyIGZvciB0aGUgZ2l2ZW4gcmVzb3VyY2VcbiAgICpcbiAgICogVGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBvbmUgaWRlbnRpZmllciB1bmRlciB3aGljaCBhIHJlc291cmNlIGNhbiBiZSBpbXBvcnRlZC4gVGhlIGBpbXBvcnRgXG4gICAqIG9wZXJhdGlvbiBuZWVkcyBleGFjdGx5IG9uZSBvZiB0aGVtLlxuICAgKlxuICAgKiAtIElmIHdlIGNhbiBnZXQgb25lIGZyb20gdGhlIHRlbXBsYXRlLCB3ZSB3aWxsIHVzZSBvbmUuXG4gICAqIC0gT3RoZXJ3aXNlLCB3ZSB3aWxsIGFzayB0aGUgdXNlciBmb3Igb25lIG9mIHRoZW0uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGFza0ZvclJlc291cmNlSWRlbnRpZmllcihcbiAgICByZXNvdXJjZUlkZW50aWZpZXJzOiBSZXNvdXJjZUlkZW50aWZpZXJzLFxuICAgIGNoZzogSW1wb3J0YWJsZVJlc291cmNlLFxuICApOiBQcm9taXNlPFJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXMgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCByZXNvdXJjZU5hbWUgPSB0aGlzLmRlc2NyaWJlUmVzb3VyY2UoY2hnLmxvZ2ljYWxJZCk7XG5cbiAgICAvLyBTa2lwIHJlc291cmNlcyB0aGF0IGRvIG5vdCBzdXBwb3J0IGltcG9ydGluZ1xuICAgIGNvbnN0IHJlc291cmNlVHlwZSA9IGNoZy5yZXNvdXJjZURpZmYubmV3UmVzb3VyY2VUeXBlO1xuICAgIGlmIChyZXNvdXJjZVR5cGUgPT09IHVuZGVmaW5lZCB8fCAhKHJlc291cmNlVHlwZSBpbiByZXNvdXJjZUlkZW50aWZpZXJzKSkge1xuICAgICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX1dBUk4ubXNnKGAke3Jlc291cmNlTmFtZX06IHVuc3VwcG9ydGVkIHJlc291cmNlIHR5cGUgJHtyZXNvdXJjZVR5cGV9LCBza2lwcGluZyBpbXBvcnQuYCkpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBpZFByb3BTZXRzID0gcmVzb3VyY2VJZGVudGlmaWVyc1tyZXNvdXJjZVR5cGVdO1xuXG4gICAgLy8gUmV0YWluIG9ubHkgbGl0ZXJhbCBzdHJpbmdzOiBzdHJpcCBwb3RlbnRpYWwgQ0ZOIGludHJpbnNpY3NcbiAgICBjb25zdCByZXNvdXJjZVByb3BzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGNoZy5yZXNvdXJjZURlZmluaXRpb24uUHJvcGVydGllcyA/PyB7fSlcbiAgICAgIC5maWx0ZXIoKFtfLCB2XSkgPT4gdHlwZW9mIHYgPT09ICdzdHJpbmcnKSkgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcblxuICAgIC8vIEZpbmQgcHJvcGVydHkgc2V0cyB0aGF0IGFyZSBmdWxseSBzYXRpc2ZpZWQgaW4gdGhlIHRlbXBsYXRlLCBhc2sgdGhlIHVzZXIgdG8gY29uZmlybSB0aGVtXG4gICAgY29uc3Qgc2F0aXNmaWVkUHJvcFNldHMgPSBpZFByb3BTZXRzLmZpbHRlcihwcyA9PiBwcy5ldmVyeShwID0+IHJlc291cmNlUHJvcHNbcF0pKTtcbiAgICBmb3IgKGNvbnN0IHNhdGlzZmllZFByb3BTZXQgb2Ygc2F0aXNmaWVkUHJvcFNldHMpIHtcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZVByb3BzID0gT2JqZWN0LmZyb21FbnRyaWVzKHNhdGlzZmllZFByb3BTZXQubWFwKHAgPT4gW3AsIHJlc291cmNlUHJvcHNbcF1dKSk7XG4gICAgICBjb25zdCBkaXNwbGF5Q2FuZGlkYXRlUHJvcHMgPSBmbXRkaWN0KGNhbmRpZGF0ZVByb3BzKTtcblxuICAgICAgaWYgKGF3YWl0IHByb21wdGx5LmNvbmZpcm0oXG4gICAgICAgIGAke2NoYWxrLmJsdWUocmVzb3VyY2VOYW1lKX0gKCR7cmVzb3VyY2VUeXBlfSk6IGltcG9ydCB3aXRoICR7Y2hhbGsueWVsbG93KGRpc3BsYXlDYW5kaWRhdGVQcm9wcyl9ICh5ZXMvbm8pIFtkZWZhdWx0OiB5ZXNdPyBgLFxuICAgICAgICB7IGRlZmF1bHQ6ICd5ZXMnIH0sXG4gICAgICApKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGVQcm9wcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgaGVyZSBhbmQgdGhlIHVzZXIgcmVqZWN0ZWQgYW55IGF2YWlsYWJsZSBpZGVudGlmaWVycywgdGhlbiBhcHBhcmVudGx5IHRoZXkgZG9uJ3Qgd2FudCB0aGUgcmVzb3VyY2UgYXQgYWxsXG4gICAgaWYgKHNhdGlzZmllZFByb3BTZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfVE9PTEtJVF9JTkZPLm1zZyhjaGFsay5ncmV5KGBTa2lwcGluZyBpbXBvcnQgb2YgJHtyZXNvdXJjZU5hbWV9YCkpKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2Fubm90IGF1dG8taW1wb3J0IHRoaXMsIGFzayB0aGUgdXNlciBmb3Igb25lIG9mIHRoZSBwcm9wc1xuICAgIC8vIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVzZSBjYXNlcyBpcyB3aGF0IHdlIHByaW50OiBmb3IgbXVsdGlwbGUgcHJvcGVydGllcywgd2UgcHJpbnQgYSBwcmVhbWJsZVxuICAgIGNvbnN0IHByZWZpeCA9IGAke2NoYWxrLmJsdWUocmVzb3VyY2VOYW1lKX0gKCR7cmVzb3VyY2VUeXBlfSlgO1xuICAgIGxldCBwcmVhbWJsZTtcbiAgICBsZXQgcHJvbXB0UGF0dGVybjtcbiAgICBpZiAoaWRQcm9wU2V0cy5sZW5ndGggPiAxKSB7XG4gICAgICBwcmVhbWJsZSA9IGAke3ByZWZpeH06IGVudGVyIG9uZSBvZiAke2lkUHJvcFNldHMubWFwKHggPT4gY2hhbGsuYmx1ZSh4LmpvaW4oJysnKSkpLmpvaW4oJywgJyl9IHRvIGltcG9ydCAoYWxsIGVtcHR5IHRvIHNraXApYDtcbiAgICAgIHByb21wdFBhdHRlcm4gPSBgJHtwcmVmaXh9OiBlbnRlciAlYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvbXB0UGF0dGVybiA9IGAke3ByZWZpeH06IGVudGVyICVgO1xuICAgIH1cblxuICAgIC8vIERvIHRoZSBpbnB1dCBsb29wIGhlcmVcbiAgICBpZiAocHJlYW1ibGUpIHtcbiAgICAgIGF3YWl0IHRoaXMuaW9IZWxwZXIubm90aWZ5KElPLkRFRkFVTFRfVE9PTEtJVF9JTkZPLm1zZyhwcmVhbWJsZSkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGlkUHJvcHMgb2YgaWRQcm9wU2V0cykge1xuICAgICAgY29uc3QgaW5wdXQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICAgIGZvciAoY29uc3QgaWRQcm9wIG9mIGlkUHJvcHMpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHZhbHVlIGZyb20gdGhlIHRlbXBsYXRlLCB1c2UgaXQgYXMgZGVmYXVsdC4gVGhpcyB3aWxsIG9ubHkgYmUgYSBwYXJ0aWFsXG4gICAgICAgIC8vIGlkZW50aWZpZXIgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmUgZG9uZSB0aGUgaW1wb3J0IGFscmVhZHkgYWJvdmUuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHJlc291cmNlUHJvcHNbaWRQcm9wXSA/PyAnJztcblxuICAgICAgICBjb25zdCBwcm9tcHQgPSBbXG4gICAgICAgICAgcHJvbXB0UGF0dGVybi5yZXBsYWNlKC8lL2csIGNoYWxrLmJsdWUoaWRQcm9wKSksXG4gICAgICAgICAgZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICA/IGBbJHtkZWZhdWx0VmFsdWV9XWBcbiAgICAgICAgICAgIDogJyhlbXB0eSB0byBza2lwKScsXG4gICAgICAgIF0uam9pbignICcpICsgJzonO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHByb21wdGx5LnByb21wdChwcm9tcHQsXG4gICAgICAgICAgeyBkZWZhdWx0OiBkZWZhdWx0VmFsdWUsIHRyaW06IHRydWUgfSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dFtpZFByb3BdID0gcmVzcG9uc2U7XG4gICAgICAgIC8vIEFsc28gc3RpY2sgdGhpcyBwcm9wZXJ0eSBpbnRvICdyZXNvdXJjZVByb3BzJywgc28gdGhhdCBpdCBtYXkgYmUgcmV1c2VkIGJ5IGEgc3Vic2VxdWVudCBxdWVzdGlvblxuICAgICAgICAvLyAoZm9yIGEgZGlmZmVyZW50IGNvbXBvdW5kIGlkZW50aWZpZXIgdGhhdCBpbnZvbHZlcyB0aGUgc2FtZSBwcm9wZXJ0eSkuIEp1c3QgYSBzbWFsbCBVWCBlbmhhbmNlbWVudC5cbiAgICAgICAgcmVzb3VyY2VQcm9wc1tpZFByb3BdID0gcmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSB1c2VyIGdhdmUgaW5wdXRzIGZvciBhbGwgdmFsdWVzLCB3ZSBhcmUgY29tcGxldGVcbiAgICAgIGlmIChPYmplY3Qua2V5cyhpbnB1dCkubGVuZ3RoID09PSBpZFByb3BzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXdhaXQgdGhpcy5pb0hlbHBlci5ub3RpZnkoSU8uREVGQVVMVF9UT09MS0lUX0lORk8ubXNnKGNoYWxrLmdyZXkoYFNraXBwaW5nIGltcG9ydCBvZiAke3Jlc291cmNlTmFtZX1gKSkpO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGUgaW50ZXJuYWwgXCJyZXNvdXJjZSBtYXBwaW5nXCIgc3RydWN0dXJlIHRvIENsb3VkRm9ybWF0aW9uIGFjY2VwdGVkIFwiUmVzb3VyY2VzVG9JbXBvcnRcIiBzdHJ1Y3R1cmVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgbWFrZVJlc291cmNlc1RvSW1wb3J0KHJlc291cmNlTWFwOiBJbXBvcnRNYXApOiBQcm9taXNlPFJlc291cmNlc1RvSW1wb3J0PiB7XG4gICAgcmV0dXJuIHJlc291cmNlTWFwLmltcG9ydFJlc291cmNlcy5tYXAocmVzID0+ICh7XG4gICAgICBMb2dpY2FsUmVzb3VyY2VJZDogcmVzLmxvZ2ljYWxJZCxcbiAgICAgIFJlc291cmNlVHlwZTogcmVzLnJlc291cmNlRGlmZi5uZXdSZXNvdXJjZVR5cGUhLFxuICAgICAgUmVzb3VyY2VJZGVudGlmaWVyOiByZXNvdXJjZU1hcC5yZXNvdXJjZU1hcFtyZXMubG9naWNhbElkXSxcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBDbG91ZEZvcm1hdGlvbiBsb2dpY2FsIHJlc291cmNlIElEIHRvIENESyBjb25zdHJ1Y3QgdHJlZSBwYXRoXG4gICAqXG4gICAqIEBwYXJhbSBsb2dpY2FsSWQgQ2xvdWRGb3JtYXRpb24gbG9naWNhbCBJRCBvZiB0aGUgcmVzb3VyY2UgKHRoZSBrZXkgaW4gdGhlIHRlbXBsYXRlJ3MgUmVzb3VyY2VzIHNlY3Rpb24pXG4gICAqIEByZXR1cm5zIEZvcndhcmQtc2xhc2ggc2VwYXJhdGVkIHBhdGggb2YgdGhlIHJlc291cmNlIGluIENESyBjb25zdHJ1Y3QgdHJlZSwgZS5nLiBNeVN0YWNrL015QnVja2V0L1Jlc291cmNlXG4gICAqL1xuICBwcml2YXRlIGRlc2NyaWJlUmVzb3VyY2UobG9naWNhbElkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0YWNrLnRlbXBsYXRlPy5SZXNvdXJjZXM/Lltsb2dpY2FsSWRdPy5NZXRhZGF0YT8uWydhd3M6Y2RrOnBhdGgnXSA/PyBsb2dpY2FsSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBDREtNZXRhZGF0YSBhbmQgT3V0cHV0cyBpbiB0aGUgdGVtcGxhdGUgc28gdGhhdCBvbmx5IHJlc291cmNlcyBmb3IgaW1wb3J0aW5nIGFyZSBsZWZ0LlxuICAgKiBAcmV0dXJucyB0ZW1wbGF0ZSB3aXRoIGltcG9ydCByZXNvdXJjZXMgb25seVxuICAgKi9cbiAgcHJpdmF0ZSByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHJlbW92ZU5vbkltcG9ydFJlc291cmNlcyh0aGlzLnN0YWNrKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgQ0RLTWV0YWRhdGEgYW5kIE91dHB1dHMgaW4gdGhlIHRlbXBsYXRlIHNvIHRoYXQgb25seSByZXNvdXJjZXMgZm9yIGltcG9ydGluZyBhcmUgbGVmdC5cbiAqIEByZXR1cm5zIHRlbXBsYXRlIHdpdGggaW1wb3J0IHJlc291cmNlcyBvbmx5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb25JbXBvcnRSZXNvdXJjZXMoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCkge1xuICBjb25zdCB0ZW1wbGF0ZSA9IHN0YWNrLnRlbXBsYXRlO1xuICBkZWxldGUgdGVtcGxhdGUuUmVzb3VyY2VzLkNES01ldGFkYXRhO1xuICBkZWxldGUgdGVtcGxhdGUuT3V0cHV0cztcbiAgcmV0dXJuIHRlbXBsYXRlO1xufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IGEgcmVzb3VyY2UgaW4gdGhlIHRlbXBsYXRlIHRoYXQgaXMgaW1wb3J0YWJsZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEltcG9ydGFibGVSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBUaGUgbG9naWNhbCBJRCBvZiB0aGUgcmVzb3VyY2VcbiAgICovXG4gIHJlYWRvbmx5IGxvZ2ljYWxJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgZGVmaW5pdGlvbiBpbiB0aGUgbmV3IHRlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZURlZmluaXRpb246IGFueTtcblxuICAvKipcbiAgICogVGhlIGRpZmYgYXMgcmVwb3J0ZWQgYnkgYGNsb3VkZm9ybWF0aW9uLWRpZmZgLlxuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VEaWZmOiBSZXNvdXJjZURpZmZlcmVuY2U7XG59XG5cbi8qKlxuICogVGhlIGluZm9ybWF0aW9uIG5lY2Vzc2FyeSB0byBleGVjdXRlIGFuIGltcG9ydCBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbXBvcnRNYXAge1xuICAvKipcbiAgICogTWFwcGluZyBsb2dpY2FsIElEcyB0byBwaHlzaWNhbCBuYW1lc1xuICAgKi9cbiAgcmVhZG9ubHkgcmVzb3VyY2VNYXA6IFJlc291cmNlTWFwO1xuXG4gIC8qKlxuICAgKiBUaGUgc2VsZWN0aW9uIG9mIHJlc291cmNlcyB3ZSBhcmUgYWN0dWFsbHkgaW1wb3J0aW5nXG4gICAqXG4gICAqIEZvciBlYWNoIG9mIHRoZSByZXNvdXJjZXMgaW4gdGhpcyBsaXN0LCB0aGVyZSBpcyBhIGNvcnJlc3BvbmRpbmcgZW50cnkgaW5cbiAgICogdGhlIGByZXNvdXJjZU1hcGAgbWFwLlxuICAgKi9cbiAgcmVhZG9ubHkgaW1wb3J0UmVzb3VyY2VzOiBJbXBvcnRhYmxlUmVzb3VyY2VbXTtcbn1cblxuZnVuY3Rpb24gZm10ZGljdDxBPih4czogUmVjb3JkPHN0cmluZywgQT4pIHtcbiAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHhzKS5tYXAoKFtrLCB2XSkgPT4gYCR7a309JHt2fWApLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogQWRkIGEgZGVmYXVsdCBgRGVsZXRpb25Qb2xpY3lgIHBvbGljeS5cbiAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCB0byAnUmV0YWluJywgdG8gbG93ZXIgcmlzayBvZiB1bmludGVudGlvbmFsbHlcbiAqIGRlbGV0aW5nIHN0YXRlZnVsIHJlc291cmNlcyBpbiB0aGUgcHJvY2VzcyBvZiBpbXBvcnRpbmcgdG8gQ0RLLlxuICovXG5mdW5jdGlvbiBhZGREZWZhdWx0RGVsZXRpb25Qb2xpY3kocmVzb3VyY2U6IGFueSk6IGFueSB7XG4gIGlmIChyZXNvdXJjZS5EZWxldGlvblBvbGljeSkge1xuICAgIHJldHVybiByZXNvdXJjZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzb3VyY2UsXG4gICAgRGVsZXRpb25Qb2xpY3k6ICdSZXRhaW4nLFxuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpc2NvdmVySW1wb3J0YWJsZVJlc291cmNlc1Jlc3VsdCB7XG4gIHJlYWRvbmx5IGFkZGl0aW9uczogSW1wb3J0YWJsZVJlc291cmNlW107XG4gIHJlYWRvbmx5IGhhc05vbkFkZGl0aW9uczogYm9vbGVhbjtcbn1cbiJdfQ==