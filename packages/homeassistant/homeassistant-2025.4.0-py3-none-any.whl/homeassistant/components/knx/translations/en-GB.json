{
    "config": {
        "error": {
            "keyfile_invalid_signature": "The password to decrypt the `.knxkeys` file is wrong.",
            "keyfile_no_backbone_key": "The `.knxkeys` file does not contain a backbone key for secure routing.",
            "keyfile_no_tunnel_for_host": "The `.knxkeys` file does not contain credentials for host `{host}`.",
            "keyfile_not_found": "The specified `.knxkeys` file was not found in the path config/.storage/knx/",
            "unsupported_tunnel_type": "Selected tunnelling type not supported by gateway."
        },
        "step": {
            "connection_type": {
                "data_description": {
                    "connection_type": "Please select the connection type you want to use for your KNX connection."
                },
                "title": "KNX connection"
            },
            "knxkeys_tunnel_select": {
                "data": {
                    "tunnel_endpoint_ia": "Select the tunnel endpoint used for the connection."
                },
                "data_description": {
                    "tunnel_endpoint_ia": "'Automatic' selects a free tunnel endpoint for you when connecting. If you're unsure, this is the best option."
                },
                "title": "Tunnel endpoint"
            },
            "manual_tunnel": {
                "data_description": {
                    "tunneling_type": "Select the tunneling type of your KNX/IP tunneling device. Older interfaces may only support `UDP`."
                },
                "title": "Tunnel settings"
            },
            "routing": {
                "data_description": {
                    "multicast_group": "Multicast group used by your installation. Default is `224.0.23.12`",
                    "multicast_port": "Multicast port used by your installation. Default is `3671`",
                    "routing_secure": "Select if your installation uses encrypted communication according to the KNX IP Secure standard. This setting requires compatible devices and configuration. You'll be prompted for credentials in the next step."
                },
                "title": "Routing"
            },
            "secure_key_source_menu_routing": {
                "menu_options": {
                    "secure_routing_manual": "Configure IP Secure backbone key manually"
                }
            },
            "secure_key_source_menu_tunnel": {
                "description": "How do you want to configure KNX/IP Secure?",
                "menu_options": {
                    "secure_knxkeys": "Use a `.knxkeys` file providing IP Secure keys",
                    "secure_tunnel_manual": "Configure IP Secure credentials manually"
                },
                "title": "KNX IP Secure"
            },
            "secure_knxkeys": {
                "data": {
                    "knxkeys_file": "Keyring file"
                },
                "data_description": {
                    "knxkeys_file": "Select a `.knxkeys` file. This can be exported from ETS."
                },
                "title": "Import KNX Keyring"
            },
            "secure_routing_manual": {
                "title": "Secure routing"
            },
            "secure_tunnel_manual": {
                "title": "Secure tunnelling"
            },
            "tcp_tunnel_endpoint": {
                "data": {
                    "tunnel_endpoint_ia": "Select the tunnel endpoint used for the connection."
                },
                "data_description": {
                    "tunnel_endpoint_ia": "'Automatic' selects a free tunnel endpoint for you when connecting. If you're unsure, this is the best option."
                },
                "title": "Tunnel endpoint"
            },
            "tunnel": {
                "data_description": {
                    "gateway": "Select a KNX tunnelling interface you want use for the connection."
                },
                "title": "Tunnel"
            }
        }
    },
    "device_automation": {
        "extra_fields": {
            "destination": "Group addresses",
            "group_value_read": "GroupValueRead",
            "group_value_response": "GroupValueResponse",
            "group_value_write": "GroupValueWrite",
            "incoming": "Incoming",
            "outgoing": "Outgoing"
        },
        "extra_fields_descriptions": {
            "destination": "The trigger will listen to telegrams sent or received on these group addresses. If no address is selected, the trigger will fire for every group address.",
            "group_value_read": "Listen on GroupValueRead telegrams.",
            "group_value_response": "Listen on GroupValueResponse telegrams.",
            "group_value_write": "Listen on GroupValueWrite telegrams.",
            "incoming": "Listen on incoming telegrams.",
            "outgoing": "Listen on outgoing telegrams."
        },
        "trigger_type": {
            "telegram": "Telegram"
        }
    },
    "entity": {
        "climate": {
            "knx_climate": {
                "state_attributes": {
                    "preset_mode": {
                        "state": {
                            "auto": "Auto",
                            "building_protection": "Building protection",
                            "standby": "Standby"
                        }
                    }
                }
            }
        },
        "sensor": {
            "connected_since": {
                "name": "Connection established"
            },
            "connection_type": {
                "name": "Connection type"
            },
            "telegram_count": {
                "name": "Telegrams",
                "unit_of_measurement": "telegrams"
            },
            "telegrams_incoming": {
                "name": "Incoming telegrams",
                "unit_of_measurement": "telegrams"
            },
            "telegrams_incoming_error": {
                "name": "Incoming telegram errors",
                "unit_of_measurement": "errors"
            },
            "telegrams_outgoing": {
                "name": "Outgoing telegrams",
                "unit_of_measurement": "telegrams"
            },
            "telegrams_outgoing_error": {
                "name": "Outgoing telegram errors",
                "unit_of_measurement": "errors"
            }
        }
    },
    "options": {
        "error": {
            "keyfile_invalid_signature": "The password to decrypt the `.knxkeys` file is wrong.",
            "keyfile_no_backbone_key": "The `.knxkeys` file does not contain a backbone key for secure routing.",
            "keyfile_no_tunnel_for_host": "The `.knxkeys` file does not contain credentials for host `{host}`.",
            "keyfile_not_found": "The specified `.knxkeys` file was not found in the path config/.storage/knx/",
            "unsupported_tunnel_type": "Selected tunnelling type not supported by gateway."
        },
        "step": {
            "communication_settings": {
                "data": {
                    "telegram_log_size": "Telegram history limit"
                },
                "data_description": {
                    "state_updater": "Sets the default behaviour for reading state addresses from the KNX Bus.\nWhen enabled, Home Assistant will monitor each group address and read it from the bus if no value has been received for one hour.\nWhen disabled, state addresses will only be read once after a bus connection is established.\nThis behaviour can be overridden for individual entities using the `sync_state` option.",
                    "telegram_log_size": "Telegrams to keep in memory for KNX panel group monitor. Maximum: {telegram_log_size_max}"
                },
                "title": "Communication settings"
            },
            "connection_type": {
                "data_description": {
                    "connection_type": "Please select the connection type you want to use for your KNX connection."
                },
                "title": "KNX connection"
            },
            "init": {
                "menu_options": {
                    "communication_settings": "Communication settings",
                    "connection_type": "Configure KNX interface",
                    "secure_knxkeys": "Import a `.knxkeys` file"
                },
                "title": "KNX Settings"
            },
            "knxkeys_tunnel_select": {
                "data": {
                    "tunnel_endpoint_ia": "Select the tunnel endpoint used for the connection."
                },
                "data_description": {
                    "tunnel_endpoint_ia": "'Automatic' selects a free tunnel endpoint for you when connecting. If you're unsure, this is the best option."
                }
            },
            "manual_tunnel": {
                "data_description": {
                    "tunneling_type": "Select the tunneling type of your KNX/IP tunneling device. Older interfaces may only support `UDP`."
                },
                "title": "Tunnel settings"
            },
            "routing": {
                "data_description": {
                    "multicast_group": "Multicast group used by your installation. Default is `224.0.23.12`",
                    "multicast_port": "Multicast port used by your installation. Default is `3671`",
                    "routing_secure": "Select if your installation uses encrypted communication according to the KNX IP Secure standard. This setting requires compatible devices and configuration. You'll be prompted for credentials in the next step."
                },
                "title": "Routing"
            },
            "secure_knxkeys": {
                "data": {
                    "knxkeys_file": "Keyring file"
                },
                "data_description": {
                    "knxkeys_file": "Select a `.knxkeys` file. This can be exported from ETS."
                },
                "title": "Import KNX Keyring"
            },
            "secure_routing_manual": {
                "title": "Secure routing"
            },
            "secure_tunnel_manual": {
                "title": "Secure tunnelling"
            },
            "tcp_tunnel_endpoint": {
                "data": {
                    "tunnel_endpoint_ia": "Select the tunnel endpoint used for the connection."
                },
                "data_description": {
                    "tunnel_endpoint_ia": "'Automatic' selects a free tunnel endpoint for you when connecting. If you're unsure, this is the best option."
                },
                "title": "Tunnel endpoint"
            },
            "tunnel": {
                "data_description": {
                    "gateway": "Select a KNX tunnelling interface you want use for the connection."
                },
                "title": "Tunnel"
            }
        }
    },
    "services": {
        "event_register": {
            "fields": {
                "address": {
                    "description": "Group address(es) that shall be added or removed. Lists are allowed.",
                    "name": "Group address"
                },
                "remove": {
                    "description": "Whether the group address(es) will be removed.",
                    "name": "Remove event registration"
                },
                "type": {
                    "description": "If set, the payload will be decoded as given DPT in the event data `value` key. KNX sensor types are valid values (see https://www.home-assistant.io/integrations/knx/#value-types).",
                    "name": "Value type"
                }
            },
            "name": "Register knx_event"
        },
        "exposure_register": {
            "description": "Adds or removes exposures to KNX bus. Only exposures added with this action can be removed.",
            "fields": {
                "address": {
                    "description": "Group address state or attribute updates will be sent to. GroupValueRead requests will be answered. Per address only one exposure can be registered.",
                    "name": "Group address"
                },
                "attribute": {
                    "description": "Attribute of the entity that shall be sent to the KNX bus. If not set, the state will be sent. E.g. for a light the state is either \u201con\u201d or \u201coff\u201d - with attribute you can expose its \u201cbrightness\u201d.",
                    "name": "Entity attribute"
                },
                "default": {
                    "description": "Default value to send to the bus if the state or attribute value is None. E.g. a light with state \u201coff\u201d has no brightness attribute so a default value of 0 could be used. If not set (or None) no value would be sent to the bus and a GroupReadRequest to the address would return the last known value.",
                    "name": "Default value"
                },
                "entity_id": {
                    "description": "Entity ID whose state or attribute shall be exposed.",
                    "name": "Entity"
                },
                "remove": {
                    "description": "Whether the exposure should be removed. Only the 'Address' field is required for removal.",
                    "name": "Remove exposure"
                },
                "type": {
                    "description": "Telegrams will be encoded as given DPT. 'binary' and all KNX sensor types are valid values (see https://www.home-assistant.io/integrations/knx/#value-types).",
                    "name": "Value type"
                }
            },
            "name": "Expose to KNX bus"
        },
        "read": {
            "description": "Sends GroupValueRead requests to the KNX bus. Response can be used from `knx_event` and will be processed in KNX entities.",
            "fields": {
                "address": {
                    "description": "Group address(es) to send read request to. Lists will read multiple group addresses."
                }
            },
            "name": "Read from KNX bus"
        },
        "reload": {
            "description": "Reloads the KNX integration."
        },
        "send": {
            "description": "Sends arbitrary data directly to the KNX bus.",
            "fields": {
                "address": {
                    "description": "Group address(es) to write to. Lists will send to multiple group addresses successively.",
                    "name": "Group address"
                },
                "payload": {
                    "description": "Payload to send to the bus. Integers are treated as DPT 1/2/3 payloads. For DPTs > 6 bits send a list. Each value represents 1 octet (0-255). Pad with 0 to DPT byte length.",
                    "name": "Payload"
                },
                "response": {
                    "name": "Send as Response"
                },
                "type": {
                    "description": "If set, the payload will not be sent as raw bytes, but encoded as given DPT. KNX sensor types are valid values (see https://www.home-assistant.io/integrations/knx/#value-types).",
                    "name": "Value type"
                }
            },
            "name": "Send to KNX bus"
        }
    }
}