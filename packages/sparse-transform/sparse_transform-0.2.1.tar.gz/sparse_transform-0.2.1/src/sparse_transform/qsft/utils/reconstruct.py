import numpy as np
from sparse_transform.qsft.utils.general import angle_q
from typing import Any, Dict, List, Tuple, Union

def singleton_detection_noiseless(U_slice: np.ndarray, **kwargs: Any) -> np.ndarray:
    """
    Finds the index of a singleton without noise.

    Parameters
    ----------
    U_slice : np.ndarray
        The WHT component of a subsampled bin, with element i corresponding to delay i.
    **kwargs : Any
        Additional keyword arguments.

    Returns
    -------
    np.ndarray
        Index of the corresponding right node, in binary form.
    """
    q = kwargs.get('q')
    angles = np.angle(U_slice)
    angles = q*(angles[1:] - angles[0])/(2*np.pi)
    angles = angles.round().astype(int) % q
    return angles

def singleton_detection_coded(k: np.ndarray, **kwargs: Any) -> Union[np.ndarray, List[np.ndarray]]:
    """
    Finds the index of a singleton with coded decoding.

    Assumes the Delays matrix is generated by a code, and the syndrome decoder is passed to it.

    Parameters
    ----------
    k : np.ndarray
        The WHT component of a subsampled bin, with element i corresponding to delay i.
    **kwargs : Any
        Additional keyword arguments.

    Returns
    -------
    Union[np.ndarray, List[np.ndarray]]
        Index of the corresponding right node, in binary form, if list decoding.
    """
    decoder = kwargs.get('source_decoder')
    dec = decoder(list(k), **kwargs)
    if type(dec) == list:
        return [np.array(dec[i][0][0, :], dtype=int) for i in range(len(dec))]
    else:
        return np.array(dec[0][0, :], dtype=int)

def singleton_detection_mle(U_slice: np.ndarray, **kwargs: Any) -> Tuple[np.ndarray, np.ndarray]:
    """
    Finds the index of a singleton using MLE.

    Uses MLE: looks at the residuals created by peeling off each possible singleton.

    Parameters
    ----------
    U_slice : np.ndarray
        The WHT component of a subsampled bin, with element i corresponding to delay i.
    **kwargs : Any
        Additional keyword arguments.

    Returns
    -------
    Tuple[np.ndarray, np.ndarray]
        The index of the singleton and the set of signatures under the delays matrix D.
    """
    selection, S_slice, q, n = kwargs.get("selection"), kwargs.get("S_slice"), kwargs.get("q"), kwargs.get("source_parity")
    P = S_slice.shape[0]
    alphas = 1/P * np.dot(np.conjugate(S_slice).T, U_slice)
    residuals = np.linalg.norm(U_slice - (alphas * S_slice).T, ord=2, axis=1)
    k_sel = np.argmin(residuals)
    return selection[k_sel], S_slice[:, k_sel]

def singleton_detection_nso_soft(U_slice: np.ndarray, **kwargs: Any) -> np.ndarray:
    """
    Finds the index of a singleton using Soft Decoding NSO algorithm.

    Parameters
    ----------
    U_slice : np.ndarray
        The WHT component of a subsampled bin, with element i corresponding to delay i.
    **kwargs : Any
        Additional keyword arguments.

    Returns
    -------
    np.ndarray
        The index of the singleton.
    """
    q, p1 = kwargs.get("q"), kwargs.get("source_parity")
    q_roots = 2 * np.pi / q * np.arange(q + 1)
    U_slice_zero = U_slice[0::p1]
    k_sel_qary = np.zeros((p1-1, ), dtype=int)
    for i in range(1, p1):
        U_slice_i = U_slice[i::p1]
        angle = np.angle(np.mean(U_slice_zero * np.conjugate(U_slice_i))) % (2 * np.pi)
        idx = (np.abs(q_roots - angle)).argmin() % q
        k_sel_qary[i-1] = idx
    return k_sel_qary

def singleton_detection_nso_hard(U_slice: np.ndarray, **kwargs: Any) -> np.ndarray:
    """
    Finds the index of a singleton using Hard Decoding NSO Algorithm.

    Parameters
    ----------
    U_slice : np.ndarray
        The WHT component of a subsampled bin, with element i corresponding to delay i.
    **kwargs : Any
        Additional keyword arguments.

    Returns
    -------
    np.ndarray
        The index of the singleton.
    """
    q, p1 = kwargs.get("q"), kwargs.get("source_parity")
    U_slice_zero = U_slice[0::p1]
    angle_0 = angle_q(U_slice_zero, q)
    k_sel_qary = np.zeros((p1-1, ), dtype=int)
    for i in range(1, p1):
        U_slice_i = U_slice[i::p1]
        angle = angle_q(U_slice_i, q)
        idx = np.round(np.mean((angle_0 - angle) % q)) % q
        k_sel_qary[i-1] = idx
    return k_sel_qary

def singleton_detection_siso(U_slice: np.ndarray, **kwargs: Any) -> np.ndarray:
    """
    Finds the index of a singleton using SISO Singleton Detection.

    Parameters
    ----------
    U_slice : np.ndarray
        The WHT component of a subsampled bin, with element i corresponding to delay i.
    **kwargs : Any
        Additional keyword arguments.

    Returns
    -------
    np.ndarray
        The index of the singleton.
    """
    res = np.real(U_slice/U_slice[0])[1:]
    return res

def singleton_detection(U_slice: np.ndarray, method_source: str = "identity", method_channel: str = "identity", **kwargs: Any) -> Union[np.ndarray, List[np.ndarray]]:
    """
    Recovers the index value k of a singleton.

    Parameters
    ----------
    U_slice : np.ndarray
        The relevant subsampled Fourier transform to be considered.
    method_source : str
        Method of reconstruction for source coding.
    method_channel : str
        Method of reconstruction for channel coding.
    **kwargs : Any
        Additional keyword arguments.

    Returns
    -------
    Union[np.ndarray, List[np.ndarray]]
        Value of the computed singleton index k.
    """
    # Split detection into two phases, channel and source decoding
    k = {
        "mle": singleton_detection_mle,
        "nso-soft": singleton_detection_nso_soft,
        "nso-hard": singleton_detection_nso_hard,
        "identity": singleton_detection_noiseless,
        "identity-siso": singleton_detection_siso,
    }.get(method_channel)(U_slice, **kwargs)

    if method_source != "identity":
        k = {
            "coded": singleton_detection_coded
        }.get(method_source)(k, **kwargs)
    return k