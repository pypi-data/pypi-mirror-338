# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos - based on the path /qos/buffer-allocation-profiles/buffer-allocation-profile/queues/queue/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to a queue wtihin a buffer allocation
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__dedicated_buffer','__dedicated_buffer_temporal','__use_shared_buffer','__shared_buffer_limit_type','__static_shared_buffer_limit','__static_shared_buffer_limit_temporal','__dynamic_limit_scaling_factor',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['qos', 'buffer-allocation-profiles', 'buffer-allocation-profile', 'queues', 'queue', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)


  def _get_dedicated_buffer(self):
    """
    Getter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    return self.__dedicated_buffer
      
  def _set_dedicated_buffer(self, v, load=False):
    """
    Setter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer(self):
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_dedicated_buffer_temporal(self):
    """
    Getter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    return self.__dedicated_buffer_temporal
      
  def _set_dedicated_buffer_temporal(self, v, load=False):
    """
    Setter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer_temporal() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer_temporal must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer_temporal(self):
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_use_shared_buffer(self):
    """
    Getter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    return self.__use_shared_buffer
      
  def _set_use_shared_buffer(self, v, load=False):
    """
    Setter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_shared_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_shared_buffer() directly.

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_shared_buffer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)""",
        })

    self.__use_shared_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_shared_buffer(self):
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)


  def _get_shared_buffer_limit_type(self):
    """
    Getter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    return self.__shared_buffer_limit_type
      
  def _set_shared_buffer_limit_type(self, v, load=False):
    """
    Setter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_buffer_limit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_buffer_limit_type() directly.

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_buffer_limit_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-qos:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)""",
        })

    self.__shared_buffer_limit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_buffer_limit_type(self):
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)


  def _get_static_shared_buffer_limit(self):
    """
    Getter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    return self.__static_shared_buffer_limit
      
  def _set_static_shared_buffer_limit(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit(self):
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_static_shared_buffer_limit_temporal(self):
    """
    Getter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    return self.__static_shared_buffer_limit_temporal
      
  def _set_static_shared_buffer_limit_temporal(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit_temporal() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit_temporal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit_temporal(self):
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_dynamic_limit_scaling_factor(self):
    """
    Getter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    return self.__dynamic_limit_scaling_factor
      
  def _set_dynamic_limit_scaling_factor(self, v, load=False):
    """
    Setter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_limit_scaling_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_limit_scaling_factor() directly.

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_limit_scaling_factor must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)""",
        })

    self.__dynamic_limit_scaling_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_limit_scaling_factor(self):
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

  name = __builtin__.property(_get_name)
  dedicated_buffer = __builtin__.property(_get_dedicated_buffer)
  dedicated_buffer_temporal = __builtin__.property(_get_dedicated_buffer_temporal)
  use_shared_buffer = __builtin__.property(_get_use_shared_buffer)
  shared_buffer_limit_type = __builtin__.property(_get_shared_buffer_limit_type)
  static_shared_buffer_limit = __builtin__.property(_get_static_shared_buffer_limit)
  static_shared_buffer_limit_temporal = __builtin__.property(_get_static_shared_buffer_limit_temporal)
  dynamic_limit_scaling_factor = __builtin__.property(_get_dynamic_limit_scaling_factor)


  _pyangbind_elements = OrderedDict([('name', name), ('dedicated_buffer', dedicated_buffer), ('dedicated_buffer_temporal', dedicated_buffer_temporal), ('use_shared_buffer', use_shared_buffer), ('shared_buffer_limit_type', shared_buffer_limit_type), ('static_shared_buffer_limit', static_shared_buffer_limit), ('static_shared_buffer_limit_temporal', static_shared_buffer_limit_temporal), ('dynamic_limit_scaling_factor', dynamic_limit_scaling_factor), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-interfaces - based on the path /qos/buffer-allocation-profiles/buffer-allocation-profile/queues/queue/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to a queue wtihin a buffer allocation
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__dedicated_buffer','__dedicated_buffer_temporal','__use_shared_buffer','__shared_buffer_limit_type','__static_shared_buffer_limit','__static_shared_buffer_limit_temporal','__dynamic_limit_scaling_factor',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['qos', 'buffer-allocation-profiles', 'buffer-allocation-profile', 'queues', 'queue', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)


  def _get_dedicated_buffer(self):
    """
    Getter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    return self.__dedicated_buffer
      
  def _set_dedicated_buffer(self, v, load=False):
    """
    Setter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer(self):
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_dedicated_buffer_temporal(self):
    """
    Getter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    return self.__dedicated_buffer_temporal
      
  def _set_dedicated_buffer_temporal(self, v, load=False):
    """
    Setter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer_temporal() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer_temporal must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer_temporal(self):
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_use_shared_buffer(self):
    """
    Getter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    return self.__use_shared_buffer
      
  def _set_use_shared_buffer(self, v, load=False):
    """
    Setter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_shared_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_shared_buffer() directly.

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_shared_buffer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)""",
        })

    self.__use_shared_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_shared_buffer(self):
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)


  def _get_shared_buffer_limit_type(self):
    """
    Getter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    return self.__shared_buffer_limit_type
      
  def _set_shared_buffer_limit_type(self, v, load=False):
    """
    Setter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_buffer_limit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_buffer_limit_type() directly.

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_buffer_limit_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-qos:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)""",
        })

    self.__shared_buffer_limit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_buffer_limit_type(self):
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)


  def _get_static_shared_buffer_limit(self):
    """
    Getter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    return self.__static_shared_buffer_limit
      
  def _set_static_shared_buffer_limit(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit(self):
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_static_shared_buffer_limit_temporal(self):
    """
    Getter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    return self.__static_shared_buffer_limit_temporal
      
  def _set_static_shared_buffer_limit_temporal(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit_temporal() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit_temporal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit_temporal(self):
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_dynamic_limit_scaling_factor(self):
    """
    Getter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    return self.__dynamic_limit_scaling_factor
      
  def _set_dynamic_limit_scaling_factor(self, v, load=False):
    """
    Setter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_limit_scaling_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_limit_scaling_factor() directly.

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_limit_scaling_factor must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)""",
        })

    self.__dynamic_limit_scaling_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_limit_scaling_factor(self):
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

  name = __builtin__.property(_get_name)
  dedicated_buffer = __builtin__.property(_get_dedicated_buffer)
  dedicated_buffer_temporal = __builtin__.property(_get_dedicated_buffer_temporal)
  use_shared_buffer = __builtin__.property(_get_use_shared_buffer)
  shared_buffer_limit_type = __builtin__.property(_get_shared_buffer_limit_type)
  static_shared_buffer_limit = __builtin__.property(_get_static_shared_buffer_limit)
  static_shared_buffer_limit_temporal = __builtin__.property(_get_static_shared_buffer_limit_temporal)
  dynamic_limit_scaling_factor = __builtin__.property(_get_dynamic_limit_scaling_factor)


  _pyangbind_elements = OrderedDict([('name', name), ('dedicated_buffer', dedicated_buffer), ('dedicated_buffer_temporal', dedicated_buffer_temporal), ('use_shared_buffer', use_shared_buffer), ('shared_buffer_limit_type', shared_buffer_limit_type), ('static_shared_buffer_limit', static_shared_buffer_limit), ('static_shared_buffer_limit_temporal', static_shared_buffer_limit_temporal), ('dynamic_limit_scaling_factor', dynamic_limit_scaling_factor), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /qos/buffer-allocation-profiles/buffer-allocation-profile/queues/queue/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to a queue wtihin a buffer allocation
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__dedicated_buffer','__dedicated_buffer_temporal','__use_shared_buffer','__shared_buffer_limit_type','__static_shared_buffer_limit','__static_shared_buffer_limit_temporal','__dynamic_limit_scaling_factor',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['qos', 'buffer-allocation-profiles', 'buffer-allocation-profile', 'queues', 'queue', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)


  def _get_dedicated_buffer(self):
    """
    Getter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    return self.__dedicated_buffer
      
  def _set_dedicated_buffer(self, v, load=False):
    """
    Setter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer(self):
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_dedicated_buffer_temporal(self):
    """
    Getter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    return self.__dedicated_buffer_temporal
      
  def _set_dedicated_buffer_temporal(self, v, load=False):
    """
    Setter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer_temporal() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer_temporal must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer_temporal(self):
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_use_shared_buffer(self):
    """
    Getter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    return self.__use_shared_buffer
      
  def _set_use_shared_buffer(self, v, load=False):
    """
    Setter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_shared_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_shared_buffer() directly.

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_shared_buffer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)""",
        })

    self.__use_shared_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_shared_buffer(self):
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)


  def _get_shared_buffer_limit_type(self):
    """
    Getter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    return self.__shared_buffer_limit_type
      
  def _set_shared_buffer_limit_type(self, v, load=False):
    """
    Setter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_buffer_limit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_buffer_limit_type() directly.

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_buffer_limit_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-qos:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)""",
        })

    self.__shared_buffer_limit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_buffer_limit_type(self):
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)


  def _get_static_shared_buffer_limit(self):
    """
    Getter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    return self.__static_shared_buffer_limit
      
  def _set_static_shared_buffer_limit(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit(self):
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_static_shared_buffer_limit_temporal(self):
    """
    Getter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    return self.__static_shared_buffer_limit_temporal
      
  def _set_static_shared_buffer_limit_temporal(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit_temporal() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit_temporal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit_temporal(self):
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_dynamic_limit_scaling_factor(self):
    """
    Getter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    return self.__dynamic_limit_scaling_factor
      
  def _set_dynamic_limit_scaling_factor(self, v, load=False):
    """
    Setter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_limit_scaling_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_limit_scaling_factor() directly.

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_limit_scaling_factor must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)""",
        })

    self.__dynamic_limit_scaling_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_limit_scaling_factor(self):
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

  name = __builtin__.property(_get_name)
  dedicated_buffer = __builtin__.property(_get_dedicated_buffer)
  dedicated_buffer_temporal = __builtin__.property(_get_dedicated_buffer_temporal)
  use_shared_buffer = __builtin__.property(_get_use_shared_buffer)
  shared_buffer_limit_type = __builtin__.property(_get_shared_buffer_limit_type)
  static_shared_buffer_limit = __builtin__.property(_get_static_shared_buffer_limit)
  static_shared_buffer_limit_temporal = __builtin__.property(_get_static_shared_buffer_limit_temporal)
  dynamic_limit_scaling_factor = __builtin__.property(_get_dynamic_limit_scaling_factor)


  _pyangbind_elements = OrderedDict([('name', name), ('dedicated_buffer', dedicated_buffer), ('dedicated_buffer_temporal', dedicated_buffer_temporal), ('use_shared_buffer', use_shared_buffer), ('shared_buffer_limit_type', shared_buffer_limit_type), ('static_shared_buffer_limit', static_shared_buffer_limit), ('static_shared_buffer_limit_temporal', static_shared_buffer_limit_temporal), ('dynamic_limit_scaling_factor', dynamic_limit_scaling_factor), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-mem-mgmt - based on the path /qos/buffer-allocation-profiles/buffer-allocation-profile/queues/queue/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to a queue wtihin a buffer allocation
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__dedicated_buffer','__dedicated_buffer_temporal','__use_shared_buffer','__shared_buffer_limit_type','__static_shared_buffer_limit','__static_shared_buffer_limit_temporal','__dynamic_limit_scaling_factor',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['qos', 'buffer-allocation-profiles', 'buffer-allocation-profile', 'queues', 'queue', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)


  def _get_dedicated_buffer(self):
    """
    Getter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    return self.__dedicated_buffer
      
  def _set_dedicated_buffer(self, v, load=False):
    """
    Setter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer(self):
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_dedicated_buffer_temporal(self):
    """
    Getter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    return self.__dedicated_buffer_temporal
      
  def _set_dedicated_buffer_temporal(self, v, load=False):
    """
    Setter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer_temporal() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer_temporal must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer_temporal(self):
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_use_shared_buffer(self):
    """
    Getter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    return self.__use_shared_buffer
      
  def _set_use_shared_buffer(self, v, load=False):
    """
    Setter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_shared_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_shared_buffer() directly.

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_shared_buffer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)""",
        })

    self.__use_shared_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_shared_buffer(self):
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)


  def _get_shared_buffer_limit_type(self):
    """
    Getter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    return self.__shared_buffer_limit_type
      
  def _set_shared_buffer_limit_type(self, v, load=False):
    """
    Setter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_buffer_limit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_buffer_limit_type() directly.

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_buffer_limit_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-qos:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)""",
        })

    self.__shared_buffer_limit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_buffer_limit_type(self):
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)


  def _get_static_shared_buffer_limit(self):
    """
    Getter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    return self.__static_shared_buffer_limit
      
  def _set_static_shared_buffer_limit(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit(self):
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_static_shared_buffer_limit_temporal(self):
    """
    Getter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    return self.__static_shared_buffer_limit_temporal
      
  def _set_static_shared_buffer_limit_temporal(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit_temporal() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit_temporal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit_temporal(self):
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_dynamic_limit_scaling_factor(self):
    """
    Getter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    return self.__dynamic_limit_scaling_factor
      
  def _set_dynamic_limit_scaling_factor(self, v, load=False):
    """
    Setter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_limit_scaling_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_limit_scaling_factor() directly.

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_limit_scaling_factor must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)""",
        })

    self.__dynamic_limit_scaling_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_limit_scaling_factor(self):
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

  name = __builtin__.property(_get_name)
  dedicated_buffer = __builtin__.property(_get_dedicated_buffer)
  dedicated_buffer_temporal = __builtin__.property(_get_dedicated_buffer_temporal)
  use_shared_buffer = __builtin__.property(_get_use_shared_buffer)
  shared_buffer_limit_type = __builtin__.property(_get_shared_buffer_limit_type)
  static_shared_buffer_limit = __builtin__.property(_get_static_shared_buffer_limit)
  static_shared_buffer_limit_temporal = __builtin__.property(_get_static_shared_buffer_limit_temporal)
  dynamic_limit_scaling_factor = __builtin__.property(_get_dynamic_limit_scaling_factor)


  _pyangbind_elements = OrderedDict([('name', name), ('dedicated_buffer', dedicated_buffer), ('dedicated_buffer_temporal', dedicated_buffer_temporal), ('use_shared_buffer', use_shared_buffer), ('shared_buffer_limit_type', shared_buffer_limit_type), ('static_shared_buffer_limit', static_shared_buffer_limit), ('static_shared_buffer_limit_temporal', static_shared_buffer_limit_temporal), ('dynamic_limit_scaling_factor', dynamic_limit_scaling_factor), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos - based on the path /qos/buffer-allocation-profiles/buffer-allocation-profile/queues/queue/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to a queue wtihin a buffer allocation
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__dedicated_buffer','__dedicated_buffer_temporal','__use_shared_buffer','__shared_buffer_limit_type','__static_shared_buffer_limit','__static_shared_buffer_limit_temporal','__dynamic_limit_scaling_factor',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['qos', 'buffer-allocation-profiles', 'buffer-allocation-profile', 'queues', 'queue', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)


  def _get_dedicated_buffer(self):
    """
    Getter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    return self.__dedicated_buffer
      
  def _set_dedicated_buffer(self, v, load=False):
    """
    Setter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer(self):
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_dedicated_buffer_temporal(self):
    """
    Getter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    return self.__dedicated_buffer_temporal
      
  def _set_dedicated_buffer_temporal(self, v, load=False):
    """
    Setter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer_temporal() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer_temporal must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer_temporal(self):
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_use_shared_buffer(self):
    """
    Getter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    return self.__use_shared_buffer
      
  def _set_use_shared_buffer(self, v, load=False):
    """
    Setter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_shared_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_shared_buffer() directly.

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_shared_buffer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)""",
        })

    self.__use_shared_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_shared_buffer(self):
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)


  def _get_shared_buffer_limit_type(self):
    """
    Getter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    return self.__shared_buffer_limit_type
      
  def _set_shared_buffer_limit_type(self, v, load=False):
    """
    Setter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_buffer_limit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_buffer_limit_type() directly.

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_buffer_limit_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-qos:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)""",
        })

    self.__shared_buffer_limit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_buffer_limit_type(self):
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)


  def _get_static_shared_buffer_limit(self):
    """
    Getter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    return self.__static_shared_buffer_limit
      
  def _set_static_shared_buffer_limit(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit(self):
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_static_shared_buffer_limit_temporal(self):
    """
    Getter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    return self.__static_shared_buffer_limit_temporal
      
  def _set_static_shared_buffer_limit_temporal(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit_temporal() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit_temporal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit_temporal(self):
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_dynamic_limit_scaling_factor(self):
    """
    Getter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    return self.__dynamic_limit_scaling_factor
      
  def _set_dynamic_limit_scaling_factor(self, v, load=False):
    """
    Setter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_limit_scaling_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_limit_scaling_factor() directly.

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_limit_scaling_factor must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)""",
        })

    self.__dynamic_limit_scaling_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_limit_scaling_factor(self):
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

  name = __builtin__.property(_get_name)
  dedicated_buffer = __builtin__.property(_get_dedicated_buffer)
  dedicated_buffer_temporal = __builtin__.property(_get_dedicated_buffer_temporal)
  use_shared_buffer = __builtin__.property(_get_use_shared_buffer)
  shared_buffer_limit_type = __builtin__.property(_get_shared_buffer_limit_type)
  static_shared_buffer_limit = __builtin__.property(_get_static_shared_buffer_limit)
  static_shared_buffer_limit_temporal = __builtin__.property(_get_static_shared_buffer_limit_temporal)
  dynamic_limit_scaling_factor = __builtin__.property(_get_dynamic_limit_scaling_factor)


  _pyangbind_elements = OrderedDict([('name', name), ('dedicated_buffer', dedicated_buffer), ('dedicated_buffer_temporal', dedicated_buffer_temporal), ('use_shared_buffer', use_shared_buffer), ('shared_buffer_limit_type', shared_buffer_limit_type), ('static_shared_buffer_limit', static_shared_buffer_limit), ('static_shared_buffer_limit_temporal', static_shared_buffer_limit_temporal), ('dynamic_limit_scaling_factor', dynamic_limit_scaling_factor), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-interfaces - based on the path /qos/buffer-allocation-profiles/buffer-allocation-profile/queues/queue/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to a queue wtihin a buffer allocation
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__dedicated_buffer','__dedicated_buffer_temporal','__use_shared_buffer','__shared_buffer_limit_type','__static_shared_buffer_limit','__static_shared_buffer_limit_temporal','__dynamic_limit_scaling_factor',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['qos', 'buffer-allocation-profiles', 'buffer-allocation-profile', 'queues', 'queue', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)


  def _get_dedicated_buffer(self):
    """
    Getter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    return self.__dedicated_buffer
      
  def _set_dedicated_buffer(self, v, load=False):
    """
    Setter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer(self):
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_dedicated_buffer_temporal(self):
    """
    Getter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    return self.__dedicated_buffer_temporal
      
  def _set_dedicated_buffer_temporal(self, v, load=False):
    """
    Setter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer_temporal() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer_temporal must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer_temporal(self):
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_use_shared_buffer(self):
    """
    Getter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    return self.__use_shared_buffer
      
  def _set_use_shared_buffer(self, v, load=False):
    """
    Setter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_shared_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_shared_buffer() directly.

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_shared_buffer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)""",
        })

    self.__use_shared_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_shared_buffer(self):
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)


  def _get_shared_buffer_limit_type(self):
    """
    Getter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    return self.__shared_buffer_limit_type
      
  def _set_shared_buffer_limit_type(self, v, load=False):
    """
    Setter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_buffer_limit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_buffer_limit_type() directly.

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_buffer_limit_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-qos:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)""",
        })

    self.__shared_buffer_limit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_buffer_limit_type(self):
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)


  def _get_static_shared_buffer_limit(self):
    """
    Getter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    return self.__static_shared_buffer_limit
      
  def _set_static_shared_buffer_limit(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit(self):
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_static_shared_buffer_limit_temporal(self):
    """
    Getter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    return self.__static_shared_buffer_limit_temporal
      
  def _set_static_shared_buffer_limit_temporal(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit_temporal() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit_temporal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit_temporal(self):
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_dynamic_limit_scaling_factor(self):
    """
    Getter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    return self.__dynamic_limit_scaling_factor
      
  def _set_dynamic_limit_scaling_factor(self, v, load=False):
    """
    Setter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_limit_scaling_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_limit_scaling_factor() directly.

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_limit_scaling_factor must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)""",
        })

    self.__dynamic_limit_scaling_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_limit_scaling_factor(self):
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

  name = __builtin__.property(_get_name)
  dedicated_buffer = __builtin__.property(_get_dedicated_buffer)
  dedicated_buffer_temporal = __builtin__.property(_get_dedicated_buffer_temporal)
  use_shared_buffer = __builtin__.property(_get_use_shared_buffer)
  shared_buffer_limit_type = __builtin__.property(_get_shared_buffer_limit_type)
  static_shared_buffer_limit = __builtin__.property(_get_static_shared_buffer_limit)
  static_shared_buffer_limit_temporal = __builtin__.property(_get_static_shared_buffer_limit_temporal)
  dynamic_limit_scaling_factor = __builtin__.property(_get_dynamic_limit_scaling_factor)


  _pyangbind_elements = OrderedDict([('name', name), ('dedicated_buffer', dedicated_buffer), ('dedicated_buffer_temporal', dedicated_buffer_temporal), ('use_shared_buffer', use_shared_buffer), ('shared_buffer_limit_type', shared_buffer_limit_type), ('static_shared_buffer_limit', static_shared_buffer_limit), ('static_shared_buffer_limit_temporal', static_shared_buffer_limit_temporal), ('dynamic_limit_scaling_factor', dynamic_limit_scaling_factor), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /qos/buffer-allocation-profiles/buffer-allocation-profile/queues/queue/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to a queue wtihin a buffer allocation
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__dedicated_buffer','__dedicated_buffer_temporal','__use_shared_buffer','__shared_buffer_limit_type','__static_shared_buffer_limit','__static_shared_buffer_limit_temporal','__dynamic_limit_scaling_factor',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['qos', 'buffer-allocation-profiles', 'buffer-allocation-profile', 'queues', 'queue', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)


  def _get_dedicated_buffer(self):
    """
    Getter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    return self.__dedicated_buffer
      
  def _set_dedicated_buffer(self, v, load=False):
    """
    Setter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer(self):
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_dedicated_buffer_temporal(self):
    """
    Getter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    return self.__dedicated_buffer_temporal
      
  def _set_dedicated_buffer_temporal(self, v, load=False):
    """
    Setter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer_temporal() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer_temporal must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer_temporal(self):
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_use_shared_buffer(self):
    """
    Getter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    return self.__use_shared_buffer
      
  def _set_use_shared_buffer(self, v, load=False):
    """
    Setter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_shared_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_shared_buffer() directly.

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_shared_buffer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)""",
        })

    self.__use_shared_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_shared_buffer(self):
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)


  def _get_shared_buffer_limit_type(self):
    """
    Getter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    return self.__shared_buffer_limit_type
      
  def _set_shared_buffer_limit_type(self, v, load=False):
    """
    Setter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_buffer_limit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_buffer_limit_type() directly.

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_buffer_limit_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-qos:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)""",
        })

    self.__shared_buffer_limit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_buffer_limit_type(self):
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)


  def _get_static_shared_buffer_limit(self):
    """
    Getter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    return self.__static_shared_buffer_limit
      
  def _set_static_shared_buffer_limit(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit(self):
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_static_shared_buffer_limit_temporal(self):
    """
    Getter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    return self.__static_shared_buffer_limit_temporal
      
  def _set_static_shared_buffer_limit_temporal(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit_temporal() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit_temporal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit_temporal(self):
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_dynamic_limit_scaling_factor(self):
    """
    Getter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    return self.__dynamic_limit_scaling_factor
      
  def _set_dynamic_limit_scaling_factor(self, v, load=False):
    """
    Setter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_limit_scaling_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_limit_scaling_factor() directly.

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_limit_scaling_factor must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)""",
        })

    self.__dynamic_limit_scaling_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_limit_scaling_factor(self):
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

  name = __builtin__.property(_get_name)
  dedicated_buffer = __builtin__.property(_get_dedicated_buffer)
  dedicated_buffer_temporal = __builtin__.property(_get_dedicated_buffer_temporal)
  use_shared_buffer = __builtin__.property(_get_use_shared_buffer)
  shared_buffer_limit_type = __builtin__.property(_get_shared_buffer_limit_type)
  static_shared_buffer_limit = __builtin__.property(_get_static_shared_buffer_limit)
  static_shared_buffer_limit_temporal = __builtin__.property(_get_static_shared_buffer_limit_temporal)
  dynamic_limit_scaling_factor = __builtin__.property(_get_dynamic_limit_scaling_factor)


  _pyangbind_elements = OrderedDict([('name', name), ('dedicated_buffer', dedicated_buffer), ('dedicated_buffer_temporal', dedicated_buffer_temporal), ('use_shared_buffer', use_shared_buffer), ('shared_buffer_limit_type', shared_buffer_limit_type), ('static_shared_buffer_limit', static_shared_buffer_limit), ('static_shared_buffer_limit_temporal', static_shared_buffer_limit_temporal), ('dynamic_limit_scaling_factor', dynamic_limit_scaling_factor), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-mem-mgmt - based on the path /qos/buffer-allocation-profiles/buffer-allocation-profile/queues/queue/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to a queue wtihin a buffer allocation
profile.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__dedicated_buffer','__dedicated_buffer_temporal','__use_shared_buffer','__shared_buffer_limit_type','__static_shared_buffer_limit','__static_shared_buffer_limit_temporal','__dynamic_limit_scaling_factor',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['qos', 'buffer-allocation-profiles', 'buffer-allocation-profile', 'queues', 'queue', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the queue being referenced within the buffer allocation profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='leafref', is_config=False)


  def _get_dedicated_buffer(self):
    """
    Getter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    return self.__dedicated_buffer
      
  def _set_dedicated_buffer(self, v, load=False):
    """
    Setter method for dedicated_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue, this is the minimum
number of bytes reserved for this queue.
This leaf is mutualy exclusive with dedicated-buffer-temporal leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer(self):
    self.__dedicated_buffer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_dedicated_buffer_temporal(self):
    """
    Getter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    return self.__dedicated_buffer_temporal
      
  def _set_dedicated_buffer_temporal(self, v, load=False):
    """
    Setter method for dedicated_buffer_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dedicated_buffer_temporal (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dedicated_buffer_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dedicated_buffer_temporal() directly.

    YANG Description: This is the dedicated buffer that is carved for the queue. The the minimum
number of bytes reserved for this queue is calculated by multiplying by interface speed
queue is attached to and queues minimum, guarantaed transmit share (derived
form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with dedicated-buffer leaf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dedicated_buffer_temporal must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)""",
        })

    self.__dedicated_buffer_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dedicated_buffer_temporal(self):
    self.__dedicated_buffer_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="dedicated-buffer-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint64', is_config=False)


  def _get_use_shared_buffer(self):
    """
    Getter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    return self.__use_shared_buffer
      
  def _set_use_shared_buffer(self, v, load=False):
    """
    Setter method for use_shared_buffer, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/use_shared_buffer (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_use_shared_buffer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_use_shared_buffer() directly.

    YANG Description: If the flag is true, then the queue is allowed to use buffers from shared pool
in additional to the dedicated buffers assigned for this queue.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """use_shared_buffer must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)""",
        })

    self.__use_shared_buffer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_use_shared_buffer(self):
    self.__use_shared_buffer = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="use-shared-buffer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='boolean', is_config=False)


  def _get_shared_buffer_limit_type(self):
    """
    Getter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    return self.__shared_buffer_limit_type
      
  def _set_shared_buffer_limit_type(self, v, load=False):
    """
    Setter method for shared_buffer_limit_type, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/shared_buffer_limit_type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_buffer_limit_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_buffer_limit_type() directly.

    YANG Description: The type of limit used to specify the amount of buffer space that the queue
is allowed to use from the shared pool.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_buffer_limit_type must be of a type compatible with identityref""",
          'defined-type': "openconfig-qos:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)""",
        })

    self.__shared_buffer_limit_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_buffer_limit_type(self):
    self.__shared_buffer_limit_type = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:STATIC': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'openconfig-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}, 'oc-qos:DYNAMIC_BASED_ON_SCALING_FACTOR': {'@module': 'openconfig-qos', '@namespace': 'http://openconfig.net/yang/qos'}},), is_leaf=True, yang_name="shared-buffer-limit-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='identityref', is_config=False)


  def _get_static_shared_buffer_limit(self):
    """
    Getter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    return self.__static_shared_buffer_limit
      
  def _set_static_shared_buffer_limit(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
This leaf is mutualy exclusive with static-shared-buffer-limit-temporal leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit(self):
    self.__static_shared_buffer_limit = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_static_shared_buffer_limit_temporal(self):
    """
    Getter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    return self.__static_shared_buffer_limit_temporal
      
  def _set_static_shared_buffer_limit_temporal(self, v, load=False):
    """
    Setter method for static_shared_buffer_limit_temporal, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/static_shared_buffer_limit_temporal (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_static_shared_buffer_limit_temporal is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_static_shared_buffer_limit_temporal() directly.

    YANG Description: If the shared-buffer-limit-type is STATIC, then static-shared-buffer-limit-temporal is
the maximum number of bytes that the queue is allowed to use from the shared
pool.
The the number of bytes is calculated by multiplying static-shared-buffer-limit-temporal
by interface speed the queue is attached to and queues minimum, guarantaed transmit share
(derived form WRR schedulers weights).
This leaf shouldbot be used for strict priority scheduled queues.
This leaf is mutualy exclusive with static-shared-buffer-limit leaf.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """static_shared_buffer_limit_temporal must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)""",
        })

    self.__static_shared_buffer_limit_temporal = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_static_shared_buffer_limit_temporal(self):
    self.__static_shared_buffer_limit_temporal = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="static-shared-buffer-limit-temporal", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='uint32', is_config=False)


  def _get_dynamic_limit_scaling_factor(self):
    """
    Getter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    return self.__dynamic_limit_scaling_factor
      
  def _set_dynamic_limit_scaling_factor(self, v, load=False):
    """
    Setter method for dynamic_limit_scaling_factor, mapped from YANG variable /qos/buffer_allocation_profiles/buffer_allocation_profile/queues/queue/state/dynamic_limit_scaling_factor (int32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dynamic_limit_scaling_factor is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dynamic_limit_scaling_factor() directly.

    YANG Description: If shared-buffer-limit-type is DYNAMIC_BASED_ON_SCALING_FACTOR, the scaling
factor and the current free space in the shared pool is used to determine the
maximum buffer sapce from the shared pool that the queue is allowed to use.

Example: If a queue is using 79MB and the other queues are using 11MB, the
free buffer is 10MB. If the configured scaling factor is 3 for the queue, the
maximum buffer space from the shared pool that the queue is allowed to use is
calculated as (free buffer * 2^scaling factor) ie. 10MB*2^3 = 80MB. Since the
current usage is 79MB which is < 80MB, the packet is queued.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dynamic_limit_scaling_factor must be of a type compatible with int32""",
          'defined-type': "int32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)""",
        })

    self.__dynamic_limit_scaling_factor = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dynamic_limit_scaling_factor(self):
    self.__dynamic_limit_scaling_factor = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['-2147483648..2147483647']}, int_size=32), is_leaf=True, yang_name="dynamic-limit-scaling-factor", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='int32', is_config=False)

  name = __builtin__.property(_get_name)
  dedicated_buffer = __builtin__.property(_get_dedicated_buffer)
  dedicated_buffer_temporal = __builtin__.property(_get_dedicated_buffer_temporal)
  use_shared_buffer = __builtin__.property(_get_use_shared_buffer)
  shared_buffer_limit_type = __builtin__.property(_get_shared_buffer_limit_type)
  static_shared_buffer_limit = __builtin__.property(_get_static_shared_buffer_limit)
  static_shared_buffer_limit_temporal = __builtin__.property(_get_static_shared_buffer_limit_temporal)
  dynamic_limit_scaling_factor = __builtin__.property(_get_dynamic_limit_scaling_factor)


  _pyangbind_elements = OrderedDict([('name', name), ('dedicated_buffer', dedicated_buffer), ('dedicated_buffer_temporal', dedicated_buffer_temporal), ('use_shared_buffer', use_shared_buffer), ('shared_buffer_limit_type', shared_buffer_limit_type), ('static_shared_buffer_limit', static_shared_buffer_limit), ('static_shared_buffer_limit_temporal', static_shared_buffer_limit_temporal), ('dynamic_limit_scaling_factor', dynamic_limit_scaling_factor), ])


