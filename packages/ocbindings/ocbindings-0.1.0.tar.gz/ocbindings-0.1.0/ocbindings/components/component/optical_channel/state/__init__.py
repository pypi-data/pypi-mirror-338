# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
from . import output_power
from . import input_power
from . import laser_bias_current
from . import chromatic_dispersion
from . import polarization_mode_dispersion
from . import second_order_polarization_mode_dispersion
from . import polarization_dependent_loss
from . import modulator_bias_xi
from . import modulator_bias_xq
from . import modulator_bias_yi
from . import modulator_bias_yq
from . import modulator_bias_x_phase
from . import modulator_bias_y_phase
from . import osnr
from . import carrier_frequency_offset
from . import sop_roc
from . import modulation_error_ratio
from . import pre_fec_ber
from . import post_fec_ber
from . import q_value
from . import esnr
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for optical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__frequency','__target_output_power','__operational_mode','__line_port','__group_id','__logical_channel_assignment','__output_power','__input_power','__laser_bias_current','__chromatic_dispersion','__polarization_mode_dispersion','__second_order_polarization_mode_dispersion','__polarization_dependent_loss','__modulator_bias_xi','__modulator_bias_xq','__modulator_bias_yi','__modulator_bias_yq','__modulator_bias_x_phase','__modulator_bias_y_phase','__osnr','__carrier_frequency_offset','__sop_roc','__modulation_error_ratio','__fec_uncorrectable_blocks','__pre_fec_ber','__post_fec_ber','__q_value','__esnr',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__line_port = YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__logical_channel_assignment = YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__output_power = YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__input_power = YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__chromatic_dispersion = YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_mode_dispersion = YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_dependent_loss = YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_xi = YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_xq = YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_yi = YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_yq = YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_x_phase = YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_y_phase = YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__osnr = YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__carrier_frequency_offset = YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__sop_roc = YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulation_error_ratio = YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__q_value = YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__esnr = YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'optical-channel', 'state']

  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_operational_mode(self):
    """
    Getter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    return self.__operational_mode
      
  def _set_operational_mode(self, v, load=False):
    """
    Setter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_mode() directly.

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_mode must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__operational_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_mode(self):
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_line_port(self):
    """
    Getter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    return self.__line_port
      
  def _set_line_port(self, v, load=False):
    """
    Setter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_port() directly.

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__line_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_port(self):
    self.__line_port = YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_group_id(self):
    """
    Getter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    return self.__group_id
      
  def _set_group_id(self, v, load=False):
    """
    Setter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_id() directly.

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__group_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_id(self):
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_logical_channel_assignment(self):
    """
    Getter method for logical_channel_assignment, mapped from YANG variable /components/component/optical_channel/state/logical_channel_assignment (leafref)

    YANG Description: Reference to the logical channel that is directly assigned
to this optical channel if it is assigned to a logical channel.
The logical channel must also reference this optical channel at
logical-channel-assignments/assignment/state/optical-channel
    """
    return self.__logical_channel_assignment
      
  def _set_logical_channel_assignment(self, v, load=False):
    """
    Setter method for logical_channel_assignment, mapped from YANG variable /components/component/optical_channel/state/logical_channel_assignment (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_assignment() directly.

    YANG Description: Reference to the logical channel that is directly assigned
to this optical channel if it is assigned to a logical channel.
The logical channel must also reference this optical channel at
logical-channel-assignments/assignment/state/optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_assignment must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__logical_channel_assignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_assignment(self):
    self.__logical_channel_assignment = YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. In some cases, such as when the physical
channel has a leafref to an optical channel component and the
module-functional-type is TYPE_DIGITAL_COHERENT_OPTIC this
grouping will NOT be used as the data will be within the
optical-channel
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. In some cases, such as when the physical
channel has a leafref to an optical channel component and the
module-functional-type is TYPE_DIGITAL_COHERENT_OPTIC this
grouping will NOT be used as the data will be within the
optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. When the physical channel has a leafref to
an optical channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this represents the aggregate
total optical power value (signal and noise) whereas
optical power value within the optical-channel represents
the signal power
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. When the physical channel has a leafref to
an optical channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this represents the aggregate
total optical power value (signal and noise) whereas
optical power value within the optical-channel represents
the signal power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value. In some cases,
such as when the physical channel has a leafref to an optical
channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this grouping will NOT be used
as the data will be within the optical-channel
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value. In some cases,
such as when the physical channel has a leafref to an optical
channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this grouping will NOT be used
as the data will be within the optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_chromatic_dispersion(self):
    """
    Getter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    return self.__chromatic_dispersion
      
  def _set_chromatic_dispersion(self, v, load=False):
    """
    Setter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chromatic_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chromatic_dispersion() directly.

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chromatic_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__chromatic_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chromatic_dispersion(self):
    self.__chromatic_dispersion = YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_mode_dispersion(self):
    """
    Getter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_mode_dispersion
      
  def _set_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_mode_dispersion() directly.

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_mode_dispersion(self):
    self.__polarization_mode_dispersion = YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_second_order_polarization_mode_dispersion(self):
    """
    Getter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    return self.__second_order_polarization_mode_dispersion
      
  def _set_second_order_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_second_order_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_second_order_polarization_mode_dispersion() directly.

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """second_order_polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__second_order_polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_second_order_polarization_mode_dispersion(self):
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_dependent_loss(self):
    """
    Getter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_dependent_loss
      
  def _set_polarization_dependent_loss(self, v, load=False):
    """
    Setter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_dependent_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_dependent_loss() directly.

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_dependent_loss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_dependent_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_dependent_loss(self):
    self.__polarization_dependent_loss = YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_xi(self):
    """
    Getter method for modulator_bias_xi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xi (container)

    YANG Description: The bias on in-phase path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_xi
      
  def _set_modulator_bias_xi(self, v, load=False):
    """
    Setter method for modulator_bias_xi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_xi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_xi() directly.

    YANG Description: The bias on in-phase path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_xi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_xi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_xi(self):
    self.__modulator_bias_xi = YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_xq(self):
    """
    Getter method for modulator_bias_xq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xq (container)

    YANG Description: The bias on quadrature path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_xq
      
  def _set_modulator_bias_xq(self, v, load=False):
    """
    Setter method for modulator_bias_xq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_xq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_xq() directly.

    YANG Description: The bias on quadrature path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_xq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_xq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_xq(self):
    self.__modulator_bias_xq = YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_yi(self):
    """
    Getter method for modulator_bias_yi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yi (container)

    YANG Description: The bias on in-phase path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_yi
      
  def _set_modulator_bias_yi(self, v, load=False):
    """
    Setter method for modulator_bias_yi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_yi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_yi() directly.

    YANG Description: The bias on in-phase path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_yi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_yi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_yi(self):
    self.__modulator_bias_yi = YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_yq(self):
    """
    Getter method for modulator_bias_yq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yq (container)

    YANG Description: The bias on quadrature path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_yq
      
  def _set_modulator_bias_yq(self, v, load=False):
    """
    Setter method for modulator_bias_yq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_yq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_yq() directly.

    YANG Description: The bias on quadrature path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_yq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_yq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_yq(self):
    self.__modulator_bias_yq = YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_x_phase(self):
    """
    Getter method for modulator_bias_x_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_x_phase (container)

    YANG Description: The X-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    return self.__modulator_bias_x_phase
      
  def _set_modulator_bias_x_phase(self, v, load=False):
    """
    Setter method for modulator_bias_x_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_x_phase (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_x_phase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_x_phase() directly.

    YANG Description: The X-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_x_phase must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_x_phase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_x_phase(self):
    self.__modulator_bias_x_phase = YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_y_phase(self):
    """
    Getter method for modulator_bias_y_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_y_phase (container)

    YANG Description: The Y-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    return self.__modulator_bias_y_phase
      
  def _set_modulator_bias_y_phase(self, v, load=False):
    """
    Setter method for modulator_bias_y_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_y_phase (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_y_phase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_y_phase() directly.

    YANG Description: The Y-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_y_phase must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_y_phase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_y_phase(self):
    self.__modulator_bias_y_phase = YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_osnr(self):
    """
    Getter method for osnr, mapped from YANG variable /components/component/optical_channel/state/osnr (container)

    YANG Description: Optical signal to noise ratio at 12.5GHz noise bandwidth
in dB with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value.
    """
    return self.__osnr
      
  def _set_osnr(self, v, load=False):
    """
    Setter method for osnr, mapped from YANG variable /components/component/optical_channel/state/osnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_osnr() directly.

    YANG Description: Optical signal to noise ratio at 12.5GHz noise bandwidth
in dB with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """osnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_osnr(self):
    self.__osnr = YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_carrier_frequency_offset(self):
    """
    Getter method for carrier_frequency_offset, mapped from YANG variable /components/component/optical_channel/state/carrier_frequency_offset (container)

    YANG Description: Carrier frequency offset in MHz with 1 decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value.
    """
    return self.__carrier_frequency_offset
      
  def _set_carrier_frequency_offset(self, v, load=False):
    """
    Setter method for carrier_frequency_offset, mapped from YANG variable /components/component/optical_channel/state/carrier_frequency_offset (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_carrier_frequency_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_carrier_frequency_offset() directly.

    YANG Description: Carrier frequency offset in MHz with 1 decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """carrier_frequency_offset must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__carrier_frequency_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_carrier_frequency_offset(self):
    self.__carrier_frequency_offset = YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_sop_roc(self):
    """
    Getter method for sop_roc, mapped from YANG variable /components/component/optical_channel/state/sop_roc (container)

    YANG Description: State-of-polarization rate-of-change (SOP-ROC) in krad/s with 1
decimal precision. This term is defined by OIF Implementation
Agreement for Coherent CMIS. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value.
    """
    return self.__sop_roc
      
  def _set_sop_roc(self, v, load=False):
    """
    Setter method for sop_roc, mapped from YANG variable /components/component/optical_channel/state/sop_roc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sop_roc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sop_roc() directly.

    YANG Description: State-of-polarization rate-of-change (SOP-ROC) in krad/s with 1
decimal precision. This term is defined by OIF Implementation
Agreement for Coherent CMIS. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sop_roc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__sop_roc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sop_roc(self):
    self.__sop_roc = YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulation_error_ratio(self):
    """
    Getter method for modulation_error_ratio, mapped from YANG variable /components/component/optical_channel/state/modulation_error_ratio (container)

    YANG Description: Modulation error ratio in dB with two decimal precision. Values
include the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulation_error_ratio
      
  def _set_modulation_error_ratio(self, v, load=False):
    """
    Setter method for modulation_error_ratio, mapped from YANG variable /components/component/optical_channel/state/modulation_error_ratio (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulation_error_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulation_error_ratio() directly.

    YANG Description: Modulation error ratio in dB with two decimal precision. Values
include the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulation_error_ratio must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulation_error_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulation_error_ratio(self):
    self.__modulation_error_ratio = YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_fec_uncorrectable_blocks(self):
    """
    Getter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/optical_channel/state/fec_uncorrectable_blocks (yang:counter64)

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    return self.__fec_uncorrectable_blocks
      
  def _set_fec_uncorrectable_blocks(self, v, load=False):
    """
    Setter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/optical_channel/state/fec_uncorrectable_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_blocks() directly.

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_blocks(self):
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /components/component/optical_channel/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /components/component/optical_channel/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /components/component/optical_channel/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /components/component/optical_channel/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_q_value(self):
    """
    Getter method for q_value, mapped from YANG variable /components/component/optical_channel/state/q_value (container)

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__q_value
      
  def _set_q_value(self, v, load=False):
    """
    Setter method for q_value, mapped from YANG variable /components/component/optical_channel/state/q_value (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_q_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_q_value() directly.

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """q_value must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__q_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_q_value(self):
    self.__q_value = YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_esnr(self):
    """
    Getter method for esnr, mapped from YANG variable /components/component/optical_channel/state/esnr (container)

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__esnr
      
  def _set_esnr(self, v, load=False):
    """
    Setter method for esnr, mapped from YANG variable /components/component/optical_channel/state/esnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esnr() directly.

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__esnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esnr(self):
    self.__esnr = YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  frequency = __builtin__.property(_get_frequency)
  target_output_power = __builtin__.property(_get_target_output_power)
  operational_mode = __builtin__.property(_get_operational_mode)
  line_port = __builtin__.property(_get_line_port)
  group_id = __builtin__.property(_get_group_id)
  logical_channel_assignment = __builtin__.property(_get_logical_channel_assignment)
  output_power = __builtin__.property(_get_output_power)
  input_power = __builtin__.property(_get_input_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)
  chromatic_dispersion = __builtin__.property(_get_chromatic_dispersion)
  polarization_mode_dispersion = __builtin__.property(_get_polarization_mode_dispersion)
  second_order_polarization_mode_dispersion = __builtin__.property(_get_second_order_polarization_mode_dispersion)
  polarization_dependent_loss = __builtin__.property(_get_polarization_dependent_loss)
  modulator_bias_xi = __builtin__.property(_get_modulator_bias_xi)
  modulator_bias_xq = __builtin__.property(_get_modulator_bias_xq)
  modulator_bias_yi = __builtin__.property(_get_modulator_bias_yi)
  modulator_bias_yq = __builtin__.property(_get_modulator_bias_yq)
  modulator_bias_x_phase = __builtin__.property(_get_modulator_bias_x_phase)
  modulator_bias_y_phase = __builtin__.property(_get_modulator_bias_y_phase)
  osnr = __builtin__.property(_get_osnr)
  carrier_frequency_offset = __builtin__.property(_get_carrier_frequency_offset)
  sop_roc = __builtin__.property(_get_sop_roc)
  modulation_error_ratio = __builtin__.property(_get_modulation_error_ratio)
  fec_uncorrectable_blocks = __builtin__.property(_get_fec_uncorrectable_blocks)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  q_value = __builtin__.property(_get_q_value)
  esnr = __builtin__.property(_get_esnr)


  _pyangbind_elements = OrderedDict([('frequency', frequency), ('target_output_power', target_output_power), ('operational_mode', operational_mode), ('line_port', line_port), ('group_id', group_id), ('logical_channel_assignment', logical_channel_assignment), ('output_power', output_power), ('input_power', input_power), ('laser_bias_current', laser_bias_current), ('chromatic_dispersion', chromatic_dispersion), ('polarization_mode_dispersion', polarization_mode_dispersion), ('second_order_polarization_mode_dispersion', second_order_polarization_mode_dispersion), ('polarization_dependent_loss', polarization_dependent_loss), ('modulator_bias_xi', modulator_bias_xi), ('modulator_bias_xq', modulator_bias_xq), ('modulator_bias_yi', modulator_bias_yi), ('modulator_bias_yq', modulator_bias_yq), ('modulator_bias_x_phase', modulator_bias_x_phase), ('modulator_bias_y_phase', modulator_bias_y_phase), ('osnr', osnr), ('carrier_frequency_offset', carrier_frequency_offset), ('sop_roc', sop_roc), ('modulation_error_ratio', modulation_error_ratio), ('fec_uncorrectable_blocks', fec_uncorrectable_blocks), ('pre_fec_ber', pre_fec_ber), ('post_fec_ber', post_fec_ber), ('q_value', q_value), ('esnr', esnr), ])


from . import output_power
from . import input_power
from . import laser_bias_current
from . import chromatic_dispersion
from . import polarization_mode_dispersion
from . import second_order_polarization_mode_dispersion
from . import polarization_dependent_loss
from . import modulator_bias_xi
from . import modulator_bias_xq
from . import modulator_bias_yi
from . import modulator_bias_yq
from . import modulator_bias_x_phase
from . import modulator_bias_y_phase
from . import osnr
from . import carrier_frequency_offset
from . import sop_roc
from . import modulation_error_ratio
from . import pre_fec_ber
from . import post_fec_ber
from . import q_value
from . import esnr
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /components/component/optical-channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for optical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__frequency','__target_output_power','__operational_mode','__line_port','__group_id','__logical_channel_assignment','__output_power','__input_power','__laser_bias_current','__chromatic_dispersion','__polarization_mode_dispersion','__second_order_polarization_mode_dispersion','__polarization_dependent_loss','__modulator_bias_xi','__modulator_bias_xq','__modulator_bias_yi','__modulator_bias_yq','__modulator_bias_x_phase','__modulator_bias_y_phase','__osnr','__carrier_frequency_offset','__sop_roc','__modulation_error_ratio','__fec_uncorrectable_blocks','__pre_fec_ber','__post_fec_ber','__q_value','__esnr',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__line_port = YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__logical_channel_assignment = YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__output_power = YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__input_power = YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__chromatic_dispersion = YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_mode_dispersion = YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_dependent_loss = YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_xi = YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_xq = YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_yi = YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_yq = YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_x_phase = YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_y_phase = YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__osnr = YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__carrier_frequency_offset = YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__sop_roc = YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulation_error_ratio = YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__q_value = YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__esnr = YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'optical-channel', 'state']

  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_operational_mode(self):
    """
    Getter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    return self.__operational_mode
      
  def _set_operational_mode(self, v, load=False):
    """
    Setter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_mode() directly.

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_mode must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__operational_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_mode(self):
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_line_port(self):
    """
    Getter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    return self.__line_port
      
  def _set_line_port(self, v, load=False):
    """
    Setter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_port() directly.

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__line_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_port(self):
    self.__line_port = YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_group_id(self):
    """
    Getter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    return self.__group_id
      
  def _set_group_id(self, v, load=False):
    """
    Setter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_id() directly.

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__group_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_id(self):
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_logical_channel_assignment(self):
    """
    Getter method for logical_channel_assignment, mapped from YANG variable /components/component/optical_channel/state/logical_channel_assignment (leafref)

    YANG Description: Reference to the logical channel that is directly assigned
to this optical channel if it is assigned to a logical channel.
The logical channel must also reference this optical channel at
logical-channel-assignments/assignment/state/optical-channel
    """
    return self.__logical_channel_assignment
      
  def _set_logical_channel_assignment(self, v, load=False):
    """
    Setter method for logical_channel_assignment, mapped from YANG variable /components/component/optical_channel/state/logical_channel_assignment (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_assignment() directly.

    YANG Description: Reference to the logical channel that is directly assigned
to this optical channel if it is assigned to a logical channel.
The logical channel must also reference this optical channel at
logical-channel-assignments/assignment/state/optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_assignment must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__logical_channel_assignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_assignment(self):
    self.__logical_channel_assignment = YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. In some cases, such as when the physical
channel has a leafref to an optical channel component and the
module-functional-type is TYPE_DIGITAL_COHERENT_OPTIC this
grouping will NOT be used as the data will be within the
optical-channel
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. In some cases, such as when the physical
channel has a leafref to an optical channel component and the
module-functional-type is TYPE_DIGITAL_COHERENT_OPTIC this
grouping will NOT be used as the data will be within the
optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. When the physical channel has a leafref to
an optical channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this represents the aggregate
total optical power value (signal and noise) whereas
optical power value within the optical-channel represents
the signal power
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. When the physical channel has a leafref to
an optical channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this represents the aggregate
total optical power value (signal and noise) whereas
optical power value within the optical-channel represents
the signal power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value. In some cases,
such as when the physical channel has a leafref to an optical
channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this grouping will NOT be used
as the data will be within the optical-channel
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value. In some cases,
such as when the physical channel has a leafref to an optical
channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this grouping will NOT be used
as the data will be within the optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_chromatic_dispersion(self):
    """
    Getter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    return self.__chromatic_dispersion
      
  def _set_chromatic_dispersion(self, v, load=False):
    """
    Setter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chromatic_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chromatic_dispersion() directly.

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chromatic_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__chromatic_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chromatic_dispersion(self):
    self.__chromatic_dispersion = YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_mode_dispersion(self):
    """
    Getter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_mode_dispersion
      
  def _set_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_mode_dispersion() directly.

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_mode_dispersion(self):
    self.__polarization_mode_dispersion = YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_second_order_polarization_mode_dispersion(self):
    """
    Getter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    return self.__second_order_polarization_mode_dispersion
      
  def _set_second_order_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_second_order_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_second_order_polarization_mode_dispersion() directly.

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """second_order_polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__second_order_polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_second_order_polarization_mode_dispersion(self):
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_dependent_loss(self):
    """
    Getter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_dependent_loss
      
  def _set_polarization_dependent_loss(self, v, load=False):
    """
    Setter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_dependent_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_dependent_loss() directly.

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_dependent_loss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_dependent_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_dependent_loss(self):
    self.__polarization_dependent_loss = YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_xi(self):
    """
    Getter method for modulator_bias_xi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xi (container)

    YANG Description: The bias on in-phase path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_xi
      
  def _set_modulator_bias_xi(self, v, load=False):
    """
    Setter method for modulator_bias_xi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_xi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_xi() directly.

    YANG Description: The bias on in-phase path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_xi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_xi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_xi(self):
    self.__modulator_bias_xi = YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_xq(self):
    """
    Getter method for modulator_bias_xq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xq (container)

    YANG Description: The bias on quadrature path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_xq
      
  def _set_modulator_bias_xq(self, v, load=False):
    """
    Setter method for modulator_bias_xq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_xq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_xq() directly.

    YANG Description: The bias on quadrature path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_xq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_xq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_xq(self):
    self.__modulator_bias_xq = YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_yi(self):
    """
    Getter method for modulator_bias_yi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yi (container)

    YANG Description: The bias on in-phase path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_yi
      
  def _set_modulator_bias_yi(self, v, load=False):
    """
    Setter method for modulator_bias_yi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_yi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_yi() directly.

    YANG Description: The bias on in-phase path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_yi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_yi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_yi(self):
    self.__modulator_bias_yi = YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_yq(self):
    """
    Getter method for modulator_bias_yq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yq (container)

    YANG Description: The bias on quadrature path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_yq
      
  def _set_modulator_bias_yq(self, v, load=False):
    """
    Setter method for modulator_bias_yq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_yq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_yq() directly.

    YANG Description: The bias on quadrature path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_yq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_yq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_yq(self):
    self.__modulator_bias_yq = YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_x_phase(self):
    """
    Getter method for modulator_bias_x_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_x_phase (container)

    YANG Description: The X-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    return self.__modulator_bias_x_phase
      
  def _set_modulator_bias_x_phase(self, v, load=False):
    """
    Setter method for modulator_bias_x_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_x_phase (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_x_phase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_x_phase() directly.

    YANG Description: The X-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_x_phase must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_x_phase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_x_phase(self):
    self.__modulator_bias_x_phase = YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_y_phase(self):
    """
    Getter method for modulator_bias_y_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_y_phase (container)

    YANG Description: The Y-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    return self.__modulator_bias_y_phase
      
  def _set_modulator_bias_y_phase(self, v, load=False):
    """
    Setter method for modulator_bias_y_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_y_phase (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_y_phase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_y_phase() directly.

    YANG Description: The Y-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_y_phase must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_y_phase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_y_phase(self):
    self.__modulator_bias_y_phase = YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_osnr(self):
    """
    Getter method for osnr, mapped from YANG variable /components/component/optical_channel/state/osnr (container)

    YANG Description: Optical signal to noise ratio at 12.5GHz noise bandwidth
in dB with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value.
    """
    return self.__osnr
      
  def _set_osnr(self, v, load=False):
    """
    Setter method for osnr, mapped from YANG variable /components/component/optical_channel/state/osnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_osnr() directly.

    YANG Description: Optical signal to noise ratio at 12.5GHz noise bandwidth
in dB with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """osnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_osnr(self):
    self.__osnr = YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_carrier_frequency_offset(self):
    """
    Getter method for carrier_frequency_offset, mapped from YANG variable /components/component/optical_channel/state/carrier_frequency_offset (container)

    YANG Description: Carrier frequency offset in MHz with 1 decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value.
    """
    return self.__carrier_frequency_offset
      
  def _set_carrier_frequency_offset(self, v, load=False):
    """
    Setter method for carrier_frequency_offset, mapped from YANG variable /components/component/optical_channel/state/carrier_frequency_offset (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_carrier_frequency_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_carrier_frequency_offset() directly.

    YANG Description: Carrier frequency offset in MHz with 1 decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """carrier_frequency_offset must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__carrier_frequency_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_carrier_frequency_offset(self):
    self.__carrier_frequency_offset = YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_sop_roc(self):
    """
    Getter method for sop_roc, mapped from YANG variable /components/component/optical_channel/state/sop_roc (container)

    YANG Description: State-of-polarization rate-of-change (SOP-ROC) in krad/s with 1
decimal precision. This term is defined by OIF Implementation
Agreement for Coherent CMIS. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value.
    """
    return self.__sop_roc
      
  def _set_sop_roc(self, v, load=False):
    """
    Setter method for sop_roc, mapped from YANG variable /components/component/optical_channel/state/sop_roc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sop_roc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sop_roc() directly.

    YANG Description: State-of-polarization rate-of-change (SOP-ROC) in krad/s with 1
decimal precision. This term is defined by OIF Implementation
Agreement for Coherent CMIS. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sop_roc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__sop_roc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sop_roc(self):
    self.__sop_roc = YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulation_error_ratio(self):
    """
    Getter method for modulation_error_ratio, mapped from YANG variable /components/component/optical_channel/state/modulation_error_ratio (container)

    YANG Description: Modulation error ratio in dB with two decimal precision. Values
include the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulation_error_ratio
      
  def _set_modulation_error_ratio(self, v, load=False):
    """
    Setter method for modulation_error_ratio, mapped from YANG variable /components/component/optical_channel/state/modulation_error_ratio (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulation_error_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulation_error_ratio() directly.

    YANG Description: Modulation error ratio in dB with two decimal precision. Values
include the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulation_error_ratio must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulation_error_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulation_error_ratio(self):
    self.__modulation_error_ratio = YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_fec_uncorrectable_blocks(self):
    """
    Getter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/optical_channel/state/fec_uncorrectable_blocks (yang:counter64)

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    return self.__fec_uncorrectable_blocks
      
  def _set_fec_uncorrectable_blocks(self, v, load=False):
    """
    Setter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/optical_channel/state/fec_uncorrectable_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_blocks() directly.

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_blocks(self):
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /components/component/optical_channel/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /components/component/optical_channel/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /components/component/optical_channel/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /components/component/optical_channel/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_q_value(self):
    """
    Getter method for q_value, mapped from YANG variable /components/component/optical_channel/state/q_value (container)

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__q_value
      
  def _set_q_value(self, v, load=False):
    """
    Setter method for q_value, mapped from YANG variable /components/component/optical_channel/state/q_value (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_q_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_q_value() directly.

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """q_value must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__q_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_q_value(self):
    self.__q_value = YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_esnr(self):
    """
    Getter method for esnr, mapped from YANG variable /components/component/optical_channel/state/esnr (container)

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__esnr
      
  def _set_esnr(self, v, load=False):
    """
    Setter method for esnr, mapped from YANG variable /components/component/optical_channel/state/esnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esnr() directly.

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__esnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esnr(self):
    self.__esnr = YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  frequency = __builtin__.property(_get_frequency)
  target_output_power = __builtin__.property(_get_target_output_power)
  operational_mode = __builtin__.property(_get_operational_mode)
  line_port = __builtin__.property(_get_line_port)
  group_id = __builtin__.property(_get_group_id)
  logical_channel_assignment = __builtin__.property(_get_logical_channel_assignment)
  output_power = __builtin__.property(_get_output_power)
  input_power = __builtin__.property(_get_input_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)
  chromatic_dispersion = __builtin__.property(_get_chromatic_dispersion)
  polarization_mode_dispersion = __builtin__.property(_get_polarization_mode_dispersion)
  second_order_polarization_mode_dispersion = __builtin__.property(_get_second_order_polarization_mode_dispersion)
  polarization_dependent_loss = __builtin__.property(_get_polarization_dependent_loss)
  modulator_bias_xi = __builtin__.property(_get_modulator_bias_xi)
  modulator_bias_xq = __builtin__.property(_get_modulator_bias_xq)
  modulator_bias_yi = __builtin__.property(_get_modulator_bias_yi)
  modulator_bias_yq = __builtin__.property(_get_modulator_bias_yq)
  modulator_bias_x_phase = __builtin__.property(_get_modulator_bias_x_phase)
  modulator_bias_y_phase = __builtin__.property(_get_modulator_bias_y_phase)
  osnr = __builtin__.property(_get_osnr)
  carrier_frequency_offset = __builtin__.property(_get_carrier_frequency_offset)
  sop_roc = __builtin__.property(_get_sop_roc)
  modulation_error_ratio = __builtin__.property(_get_modulation_error_ratio)
  fec_uncorrectable_blocks = __builtin__.property(_get_fec_uncorrectable_blocks)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  q_value = __builtin__.property(_get_q_value)
  esnr = __builtin__.property(_get_esnr)


  _pyangbind_elements = OrderedDict([('frequency', frequency), ('target_output_power', target_output_power), ('operational_mode', operational_mode), ('line_port', line_port), ('group_id', group_id), ('logical_channel_assignment', logical_channel_assignment), ('output_power', output_power), ('input_power', input_power), ('laser_bias_current', laser_bias_current), ('chromatic_dispersion', chromatic_dispersion), ('polarization_mode_dispersion', polarization_mode_dispersion), ('second_order_polarization_mode_dispersion', second_order_polarization_mode_dispersion), ('polarization_dependent_loss', polarization_dependent_loss), ('modulator_bias_xi', modulator_bias_xi), ('modulator_bias_xq', modulator_bias_xq), ('modulator_bias_yi', modulator_bias_yi), ('modulator_bias_yq', modulator_bias_yq), ('modulator_bias_x_phase', modulator_bias_x_phase), ('modulator_bias_y_phase', modulator_bias_y_phase), ('osnr', osnr), ('carrier_frequency_offset', carrier_frequency_offset), ('sop_roc', sop_roc), ('modulation_error_ratio', modulation_error_ratio), ('fec_uncorrectable_blocks', fec_uncorrectable_blocks), ('pre_fec_ber', pre_fec_ber), ('post_fec_ber', post_fec_ber), ('q_value', q_value), ('esnr', esnr), ])


from . import output_power
from . import input_power
from . import laser_bias_current
from . import chromatic_dispersion
from . import polarization_mode_dispersion
from . import second_order_polarization_mode_dispersion
from . import polarization_dependent_loss
from . import modulator_bias_xi
from . import modulator_bias_xq
from . import modulator_bias_yi
from . import modulator_bias_yq
from . import modulator_bias_x_phase
from . import modulator_bias_y_phase
from . import osnr
from . import carrier_frequency_offset
from . import sop_roc
from . import modulation_error_ratio
from . import pre_fec_ber
from . import post_fec_ber
from . import q_value
from . import esnr
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/optical-channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for optical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__frequency','__target_output_power','__operational_mode','__line_port','__group_id','__logical_channel_assignment','__output_power','__input_power','__laser_bias_current','__chromatic_dispersion','__polarization_mode_dispersion','__second_order_polarization_mode_dispersion','__polarization_dependent_loss','__modulator_bias_xi','__modulator_bias_xq','__modulator_bias_yi','__modulator_bias_yq','__modulator_bias_x_phase','__modulator_bias_y_phase','__osnr','__carrier_frequency_offset','__sop_roc','__modulation_error_ratio','__fec_uncorrectable_blocks','__pre_fec_ber','__post_fec_ber','__q_value','__esnr',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__line_port = YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__logical_channel_assignment = YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__output_power = YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__input_power = YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__chromatic_dispersion = YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_mode_dispersion = YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_dependent_loss = YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_xi = YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_xq = YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_yi = YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_yq = YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_x_phase = YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_y_phase = YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__osnr = YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__carrier_frequency_offset = YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__sop_roc = YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulation_error_ratio = YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__q_value = YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__esnr = YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'optical-channel', 'state']

  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_operational_mode(self):
    """
    Getter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    return self.__operational_mode
      
  def _set_operational_mode(self, v, load=False):
    """
    Setter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_mode() directly.

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_mode must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__operational_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_mode(self):
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_line_port(self):
    """
    Getter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    return self.__line_port
      
  def _set_line_port(self, v, load=False):
    """
    Setter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_port() directly.

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__line_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_port(self):
    self.__line_port = YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_group_id(self):
    """
    Getter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    return self.__group_id
      
  def _set_group_id(self, v, load=False):
    """
    Setter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_id() directly.

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__group_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_id(self):
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_logical_channel_assignment(self):
    """
    Getter method for logical_channel_assignment, mapped from YANG variable /components/component/optical_channel/state/logical_channel_assignment (leafref)

    YANG Description: Reference to the logical channel that is directly assigned
to this optical channel if it is assigned to a logical channel.
The logical channel must also reference this optical channel at
logical-channel-assignments/assignment/state/optical-channel
    """
    return self.__logical_channel_assignment
      
  def _set_logical_channel_assignment(self, v, load=False):
    """
    Setter method for logical_channel_assignment, mapped from YANG variable /components/component/optical_channel/state/logical_channel_assignment (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_assignment() directly.

    YANG Description: Reference to the logical channel that is directly assigned
to this optical channel if it is assigned to a logical channel.
The logical channel must also reference this optical channel at
logical-channel-assignments/assignment/state/optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_assignment must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__logical_channel_assignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_assignment(self):
    self.__logical_channel_assignment = YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. In some cases, such as when the physical
channel has a leafref to an optical channel component and the
module-functional-type is TYPE_DIGITAL_COHERENT_OPTIC this
grouping will NOT be used as the data will be within the
optical-channel
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. In some cases, such as when the physical
channel has a leafref to an optical channel component and the
module-functional-type is TYPE_DIGITAL_COHERENT_OPTIC this
grouping will NOT be used as the data will be within the
optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. When the physical channel has a leafref to
an optical channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this represents the aggregate
total optical power value (signal and noise) whereas
optical power value within the optical-channel represents
the signal power
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. When the physical channel has a leafref to
an optical channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this represents the aggregate
total optical power value (signal and noise) whereas
optical power value within the optical-channel represents
the signal power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value. In some cases,
such as when the physical channel has a leafref to an optical
channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this grouping will NOT be used
as the data will be within the optical-channel
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value. In some cases,
such as when the physical channel has a leafref to an optical
channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this grouping will NOT be used
as the data will be within the optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_chromatic_dispersion(self):
    """
    Getter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    return self.__chromatic_dispersion
      
  def _set_chromatic_dispersion(self, v, load=False):
    """
    Setter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chromatic_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chromatic_dispersion() directly.

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chromatic_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__chromatic_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chromatic_dispersion(self):
    self.__chromatic_dispersion = YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_mode_dispersion(self):
    """
    Getter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_mode_dispersion
      
  def _set_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_mode_dispersion() directly.

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_mode_dispersion(self):
    self.__polarization_mode_dispersion = YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_second_order_polarization_mode_dispersion(self):
    """
    Getter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    return self.__second_order_polarization_mode_dispersion
      
  def _set_second_order_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_second_order_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_second_order_polarization_mode_dispersion() directly.

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """second_order_polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__second_order_polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_second_order_polarization_mode_dispersion(self):
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_dependent_loss(self):
    """
    Getter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_dependent_loss
      
  def _set_polarization_dependent_loss(self, v, load=False):
    """
    Setter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_dependent_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_dependent_loss() directly.

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_dependent_loss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_dependent_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_dependent_loss(self):
    self.__polarization_dependent_loss = YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_xi(self):
    """
    Getter method for modulator_bias_xi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xi (container)

    YANG Description: The bias on in-phase path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_xi
      
  def _set_modulator_bias_xi(self, v, load=False):
    """
    Setter method for modulator_bias_xi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_xi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_xi() directly.

    YANG Description: The bias on in-phase path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_xi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_xi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_xi(self):
    self.__modulator_bias_xi = YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_xq(self):
    """
    Getter method for modulator_bias_xq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xq (container)

    YANG Description: The bias on quadrature path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_xq
      
  def _set_modulator_bias_xq(self, v, load=False):
    """
    Setter method for modulator_bias_xq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_xq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_xq() directly.

    YANG Description: The bias on quadrature path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_xq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_xq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_xq(self):
    self.__modulator_bias_xq = YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_yi(self):
    """
    Getter method for modulator_bias_yi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yi (container)

    YANG Description: The bias on in-phase path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_yi
      
  def _set_modulator_bias_yi(self, v, load=False):
    """
    Setter method for modulator_bias_yi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_yi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_yi() directly.

    YANG Description: The bias on in-phase path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_yi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_yi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_yi(self):
    self.__modulator_bias_yi = YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_yq(self):
    """
    Getter method for modulator_bias_yq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yq (container)

    YANG Description: The bias on quadrature path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_yq
      
  def _set_modulator_bias_yq(self, v, load=False):
    """
    Setter method for modulator_bias_yq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_yq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_yq() directly.

    YANG Description: The bias on quadrature path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_yq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_yq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_yq(self):
    self.__modulator_bias_yq = YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_x_phase(self):
    """
    Getter method for modulator_bias_x_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_x_phase (container)

    YANG Description: The X-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    return self.__modulator_bias_x_phase
      
  def _set_modulator_bias_x_phase(self, v, load=False):
    """
    Setter method for modulator_bias_x_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_x_phase (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_x_phase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_x_phase() directly.

    YANG Description: The X-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_x_phase must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_x_phase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_x_phase(self):
    self.__modulator_bias_x_phase = YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_y_phase(self):
    """
    Getter method for modulator_bias_y_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_y_phase (container)

    YANG Description: The Y-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    return self.__modulator_bias_y_phase
      
  def _set_modulator_bias_y_phase(self, v, load=False):
    """
    Setter method for modulator_bias_y_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_y_phase (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_y_phase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_y_phase() directly.

    YANG Description: The Y-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_y_phase must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_y_phase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_y_phase(self):
    self.__modulator_bias_y_phase = YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_osnr(self):
    """
    Getter method for osnr, mapped from YANG variable /components/component/optical_channel/state/osnr (container)

    YANG Description: Optical signal to noise ratio at 12.5GHz noise bandwidth
in dB with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value.
    """
    return self.__osnr
      
  def _set_osnr(self, v, load=False):
    """
    Setter method for osnr, mapped from YANG variable /components/component/optical_channel/state/osnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_osnr() directly.

    YANG Description: Optical signal to noise ratio at 12.5GHz noise bandwidth
in dB with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """osnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_osnr(self):
    self.__osnr = YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_carrier_frequency_offset(self):
    """
    Getter method for carrier_frequency_offset, mapped from YANG variable /components/component/optical_channel/state/carrier_frequency_offset (container)

    YANG Description: Carrier frequency offset in MHz with 1 decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value.
    """
    return self.__carrier_frequency_offset
      
  def _set_carrier_frequency_offset(self, v, load=False):
    """
    Setter method for carrier_frequency_offset, mapped from YANG variable /components/component/optical_channel/state/carrier_frequency_offset (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_carrier_frequency_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_carrier_frequency_offset() directly.

    YANG Description: Carrier frequency offset in MHz with 1 decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """carrier_frequency_offset must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__carrier_frequency_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_carrier_frequency_offset(self):
    self.__carrier_frequency_offset = YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_sop_roc(self):
    """
    Getter method for sop_roc, mapped from YANG variable /components/component/optical_channel/state/sop_roc (container)

    YANG Description: State-of-polarization rate-of-change (SOP-ROC) in krad/s with 1
decimal precision. This term is defined by OIF Implementation
Agreement for Coherent CMIS. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value.
    """
    return self.__sop_roc
      
  def _set_sop_roc(self, v, load=False):
    """
    Setter method for sop_roc, mapped from YANG variable /components/component/optical_channel/state/sop_roc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sop_roc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sop_roc() directly.

    YANG Description: State-of-polarization rate-of-change (SOP-ROC) in krad/s with 1
decimal precision. This term is defined by OIF Implementation
Agreement for Coherent CMIS. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sop_roc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__sop_roc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sop_roc(self):
    self.__sop_roc = YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulation_error_ratio(self):
    """
    Getter method for modulation_error_ratio, mapped from YANG variable /components/component/optical_channel/state/modulation_error_ratio (container)

    YANG Description: Modulation error ratio in dB with two decimal precision. Values
include the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulation_error_ratio
      
  def _set_modulation_error_ratio(self, v, load=False):
    """
    Setter method for modulation_error_ratio, mapped from YANG variable /components/component/optical_channel/state/modulation_error_ratio (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulation_error_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulation_error_ratio() directly.

    YANG Description: Modulation error ratio in dB with two decimal precision. Values
include the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulation_error_ratio must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulation_error_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulation_error_ratio(self):
    self.__modulation_error_ratio = YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_fec_uncorrectable_blocks(self):
    """
    Getter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/optical_channel/state/fec_uncorrectable_blocks (yang:counter64)

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    return self.__fec_uncorrectable_blocks
      
  def _set_fec_uncorrectable_blocks(self, v, load=False):
    """
    Setter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/optical_channel/state/fec_uncorrectable_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_blocks() directly.

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_blocks(self):
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /components/component/optical_channel/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /components/component/optical_channel/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /components/component/optical_channel/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /components/component/optical_channel/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_q_value(self):
    """
    Getter method for q_value, mapped from YANG variable /components/component/optical_channel/state/q_value (container)

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__q_value
      
  def _set_q_value(self, v, load=False):
    """
    Setter method for q_value, mapped from YANG variable /components/component/optical_channel/state/q_value (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_q_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_q_value() directly.

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """q_value must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__q_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_q_value(self):
    self.__q_value = YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_esnr(self):
    """
    Getter method for esnr, mapped from YANG variable /components/component/optical_channel/state/esnr (container)

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__esnr
      
  def _set_esnr(self, v, load=False):
    """
    Setter method for esnr, mapped from YANG variable /components/component/optical_channel/state/esnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esnr() directly.

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__esnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esnr(self):
    self.__esnr = YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  frequency = __builtin__.property(_get_frequency)
  target_output_power = __builtin__.property(_get_target_output_power)
  operational_mode = __builtin__.property(_get_operational_mode)
  line_port = __builtin__.property(_get_line_port)
  group_id = __builtin__.property(_get_group_id)
  logical_channel_assignment = __builtin__.property(_get_logical_channel_assignment)
  output_power = __builtin__.property(_get_output_power)
  input_power = __builtin__.property(_get_input_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)
  chromatic_dispersion = __builtin__.property(_get_chromatic_dispersion)
  polarization_mode_dispersion = __builtin__.property(_get_polarization_mode_dispersion)
  second_order_polarization_mode_dispersion = __builtin__.property(_get_second_order_polarization_mode_dispersion)
  polarization_dependent_loss = __builtin__.property(_get_polarization_dependent_loss)
  modulator_bias_xi = __builtin__.property(_get_modulator_bias_xi)
  modulator_bias_xq = __builtin__.property(_get_modulator_bias_xq)
  modulator_bias_yi = __builtin__.property(_get_modulator_bias_yi)
  modulator_bias_yq = __builtin__.property(_get_modulator_bias_yq)
  modulator_bias_x_phase = __builtin__.property(_get_modulator_bias_x_phase)
  modulator_bias_y_phase = __builtin__.property(_get_modulator_bias_y_phase)
  osnr = __builtin__.property(_get_osnr)
  carrier_frequency_offset = __builtin__.property(_get_carrier_frequency_offset)
  sop_roc = __builtin__.property(_get_sop_roc)
  modulation_error_ratio = __builtin__.property(_get_modulation_error_ratio)
  fec_uncorrectable_blocks = __builtin__.property(_get_fec_uncorrectable_blocks)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  q_value = __builtin__.property(_get_q_value)
  esnr = __builtin__.property(_get_esnr)


  _pyangbind_elements = OrderedDict([('frequency', frequency), ('target_output_power', target_output_power), ('operational_mode', operational_mode), ('line_port', line_port), ('group_id', group_id), ('logical_channel_assignment', logical_channel_assignment), ('output_power', output_power), ('input_power', input_power), ('laser_bias_current', laser_bias_current), ('chromatic_dispersion', chromatic_dispersion), ('polarization_mode_dispersion', polarization_mode_dispersion), ('second_order_polarization_mode_dispersion', second_order_polarization_mode_dispersion), ('polarization_dependent_loss', polarization_dependent_loss), ('modulator_bias_xi', modulator_bias_xi), ('modulator_bias_xq', modulator_bias_xq), ('modulator_bias_yi', modulator_bias_yi), ('modulator_bias_yq', modulator_bias_yq), ('modulator_bias_x_phase', modulator_bias_x_phase), ('modulator_bias_y_phase', modulator_bias_y_phase), ('osnr', osnr), ('carrier_frequency_offset', carrier_frequency_offset), ('sop_roc', sop_roc), ('modulation_error_ratio', modulation_error_ratio), ('fec_uncorrectable_blocks', fec_uncorrectable_blocks), ('pre_fec_ber', pre_fec_ber), ('post_fec_ber', post_fec_ber), ('q_value', q_value), ('esnr', esnr), ])


from . import output_power
from . import input_power
from . import laser_bias_current
from . import chromatic_dispersion
from . import polarization_mode_dispersion
from . import second_order_polarization_mode_dispersion
from . import polarization_dependent_loss
from . import modulator_bias_xi
from . import modulator_bias_xq
from . import modulator_bias_yi
from . import modulator_bias_yq
from . import modulator_bias_x_phase
from . import modulator_bias_y_phase
from . import osnr
from . import carrier_frequency_offset
from . import sop_roc
from . import modulation_error_ratio
from . import pre_fec_ber
from . import post_fec_ber
from . import q_value
from . import esnr
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /components/component/optical-channel/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for optical channels
  """
  __slots__ = ('_path_helper', '_extmethods', '__frequency','__target_output_power','__operational_mode','__line_port','__group_id','__logical_channel_assignment','__output_power','__input_power','__laser_bias_current','__chromatic_dispersion','__polarization_mode_dispersion','__second_order_polarization_mode_dispersion','__polarization_dependent_loss','__modulator_bias_xi','__modulator_bias_xq','__modulator_bias_yi','__modulator_bias_yq','__modulator_bias_x_phase','__modulator_bias_y_phase','__osnr','__carrier_frequency_offset','__sop_roc','__modulation_error_ratio','__fec_uncorrectable_blocks','__pre_fec_ber','__post_fec_ber','__q_value','__esnr',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    self.__line_port = YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    self.__logical_channel_assignment = YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    self.__output_power = YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__input_power = YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__laser_bias_current = YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__chromatic_dispersion = YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_mode_dispersion = YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__polarization_dependent_loss = YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_xi = YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_xq = YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_yi = YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_yq = YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_x_phase = YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulator_bias_y_phase = YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__osnr = YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__carrier_frequency_offset = YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__sop_roc = YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__modulation_error_ratio = YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    self.__pre_fec_ber = YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__post_fec_ber = YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__q_value = YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    self.__esnr = YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'optical-channel', 'state']

  def _get_frequency(self):
    """
    Getter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    return self.__frequency
      
  def _set_frequency(self, v, load=False):
    """
    Setter method for frequency, mapped from YANG variable /components/component/optical_channel/state/frequency (oc-opt-types:frequency-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency() directly.

    YANG Description: Frequency of the optical channel, expressed in MHz
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency must be of a type compatible with oc-opt-types:frequency-type""",
          'defined-type': "oc-opt-types:frequency-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)""",
        })

    self.__frequency = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency(self):
    self.__frequency = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="frequency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='oc-opt-types:frequency-type', is_config=False)


  def _get_target_output_power(self):
    """
    Getter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    return self.__target_output_power
      
  def _set_target_output_power(self, v, load=False):
    """
    Setter method for target_output_power, mapped from YANG variable /components/component/optical_channel/state/target_output_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_output_power() directly.

    YANG Description: Target output optical power level of the optical channel,
expressed in increments of 0.01 dBm (decibel-milliwats)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """target_output_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)""",
        })

    self.__target_output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_target_output_power(self):
    self.__target_output_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="target-output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='decimal64', is_config=False)


  def _get_operational_mode(self):
    """
    Getter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    return self.__operational_mode
      
  def _set_operational_mode(self, v, load=False):
    """
    Setter method for operational_mode, mapped from YANG variable /components/component/optical_channel/state/operational_mode (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_mode() directly.

    YANG Description: Vendor-specific mode identifier -- sets the operational
mode for the channel.  The specified operational mode must
exist in the list of supported operational modes supplied
by the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_mode must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)""",
        })

    self.__operational_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_mode(self):
    self.__operational_mode = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="operational-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint16', is_config=False)


  def _get_line_port(self):
    """
    Getter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    return self.__line_port
      
  def _set_line_port(self, v, load=False):
    """
    Setter method for line_port, mapped from YANG variable /components/component/optical_channel/state/line_port (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_line_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_line_port() directly.

    YANG Description: Reference to the line-side physical port that carries
this optical channel.  The target port should be
a component in the physical inventory data model.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """line_port must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__line_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_line_port(self):
    self.__line_port = YANGDynClass(base=str, is_leaf=True, yang_name="line-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_group_id(self):
    """
    Getter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    return self.__group_id
      
  def _set_group_id(self, v, load=False):
    """
    Setter method for group_id, mapped from YANG variable /components/component/optical_channel/state/group_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_group_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_group_id() directly.

    YANG Description: If the device places constraints on which optical
channels must be managed together (e.g., transmitted on the
same line port), it can indicate that by setting the group-id
to the same value across related optical channels.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """group_id must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)""",
        })

    self.__group_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_group_id(self):
    self.__group_id = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='uint32', is_config=False)


  def _get_logical_channel_assignment(self):
    """
    Getter method for logical_channel_assignment, mapped from YANG variable /components/component/optical_channel/state/logical_channel_assignment (leafref)

    YANG Description: Reference to the logical channel that is directly assigned
to this optical channel if it is assigned to a logical channel.
The logical channel must also reference this optical channel at
logical-channel-assignments/assignment/state/optical-channel
    """
    return self.__logical_channel_assignment
      
  def _set_logical_channel_assignment(self, v, load=False):
    """
    Setter method for logical_channel_assignment, mapped from YANG variable /components/component/optical_channel/state/logical_channel_assignment (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_channel_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_channel_assignment() directly.

    YANG Description: Reference to the logical channel that is directly assigned
to this optical channel if it is assigned to a logical channel.
The logical channel must also reference this optical channel at
logical-channel-assignments/assignment/state/optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logical_channel_assignment must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)""",
        })

    self.__logical_channel_assignment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logical_channel_assignment(self):
    self.__logical_channel_assignment = YANGDynClass(base=str, is_leaf=True, yang_name="logical-channel-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='leafref', is_config=False)


  def _get_output_power(self):
    """
    Getter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. In some cases, such as when the physical
channel has a leafref to an optical channel component and the
module-functional-type is TYPE_DIGITAL_COHERENT_OPTIC this
grouping will NOT be used as the data will be within the
optical-channel
    """
    return self.__output_power
      
  def _set_output_power(self, v, load=False):
    """
    Setter method for output_power, mapped from YANG variable /components/component/optical_channel/state/output_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_output_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_output_power() directly.

    YANG Description: The output optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. In some cases, such as when the physical
channel has a leafref to an optical channel component and the
module-functional-type is TYPE_DIGITAL_COHERENT_OPTIC this
grouping will NOT be used as the data will be within the
optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """output_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__output_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_output_power(self):
    self.__output_power = YANGDynClass(base=output_power.output_power, is_container='container', yang_name="output-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_input_power(self):
    """
    Getter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. When the physical channel has a leafref to
an optical channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this represents the aggregate
total optical power value (signal and noise) whereas
optical power value within the optical-channel represents
the signal power
    """
    return self.__input_power
      
  def _set_input_power(self, v, load=False):
    """
    Setter method for input_power, mapped from YANG variable /components/component/optical_channel/state/input_power (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_input_power() directly.

    YANG Description: The input optical power of a physical channel in units
of 0.01dBm, which may be associated with individual
physical channels, or an aggregate of multiple physical
channels (i.e., for the overall transceiver). For an
aggregate, this may be a measurement from a photodetector
or a a calculation performed on the device by summing up
all of the related individual physical channels.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value. When the physical channel has a leafref to
an optical channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this represents the aggregate
total optical power value (signal and noise) whereas
optical power value within the optical-channel represents
the signal power
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """input_power must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_input_power(self):
    self.__input_power = YANGDynClass(base=input_power.input_power, is_container='container', yang_name="input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_laser_bias_current(self):
    """
    Getter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value. In some cases,
such as when the physical channel has a leafref to an optical
channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this grouping will NOT be used
as the data will be within the optical-channel
    """
    return self.__laser_bias_current
      
  def _set_laser_bias_current(self, v, load=False):
    """
    Setter method for laser_bias_current, mapped from YANG variable /components/component/optical_channel/state/laser_bias_current (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_laser_bias_current is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_laser_bias_current() directly.

    YANG Description: The current applied by the system to the transmit laser to
achieve the output power. The current is expressed in mA
with up to two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value. In some cases,
such as when the physical channel has a leafref to an optical
channel component and the module-functional-type is
TYPE_DIGITAL_COHERENT_OPTIC this grouping will NOT be used
as the data will be within the optical-channel
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """laser_bias_current must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__laser_bias_current = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_laser_bias_current(self):
    self.__laser_bias_current = YANGDynClass(base=laser_bias_current.laser_bias_current, is_container='container', yang_name="laser-bias-current", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_chromatic_dispersion(self):
    """
    Getter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    return self.__chromatic_dispersion
      
  def _set_chromatic_dispersion(self, v, load=False):
    """
    Setter method for chromatic_dispersion, mapped from YANG variable /components/component/optical_channel/state/chromatic_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chromatic_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chromatic_dispersion() directly.

    YANG Description: Chromatic Dispersion of an optical channel in
picoseconds / nanometer (ps/nm) as reported by receiver
with two decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chromatic_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__chromatic_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chromatic_dispersion(self):
    self.__chromatic_dispersion = YANGDynClass(base=chromatic_dispersion.chromatic_dispersion, is_container='container', yang_name="chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_mode_dispersion(self):
    """
    Getter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_mode_dispersion
      
  def _set_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_mode_dispersion() directly.

    YANG Description: Polarization Mode Dispersion of an optical channel
in picosends (ps) as reported by receiver with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_mode_dispersion(self):
    self.__polarization_mode_dispersion = YANGDynClass(base=polarization_mode_dispersion.polarization_mode_dispersion, is_container='container', yang_name="polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_second_order_polarization_mode_dispersion(self):
    """
    Getter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    return self.__second_order_polarization_mode_dispersion
      
  def _set_second_order_polarization_mode_dispersion(self, v, load=False):
    """
    Setter method for second_order_polarization_mode_dispersion, mapped from YANG variable /components/component/optical_channel/state/second_order_polarization_mode_dispersion (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_second_order_polarization_mode_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_second_order_polarization_mode_dispersion() directly.

    YANG Description: Second Order Polarization Mode Dispersion of an optical
channel in picoseconds squared (ps^2) as reported by
receiver with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """second_order_polarization_mode_dispersion must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__second_order_polarization_mode_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_second_order_polarization_mode_dispersion(self):
    self.__second_order_polarization_mode_dispersion = YANGDynClass(base=second_order_polarization_mode_dispersion.second_order_polarization_mode_dispersion, is_container='container', yang_name="second-order-polarization-mode-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_polarization_dependent_loss(self):
    """
    Getter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__polarization_dependent_loss
      
  def _set_polarization_dependent_loss(self, v, load=False):
    """
    Setter method for polarization_dependent_loss, mapped from YANG variable /components/component/optical_channel/state/polarization_dependent_loss (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_polarization_dependent_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_polarization_dependent_loss() directly.

    YANG Description: Polarization Dependent Loss of an optical channel
in dB as reported by receiver with two decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """polarization_dependent_loss must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__polarization_dependent_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_polarization_dependent_loss(self):
    self.__polarization_dependent_loss = YANGDynClass(base=polarization_dependent_loss.polarization_dependent_loss, is_container='container', yang_name="polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_xi(self):
    """
    Getter method for modulator_bias_xi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xi (container)

    YANG Description: The bias on in-phase path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_xi
      
  def _set_modulator_bias_xi(self, v, load=False):
    """
    Setter method for modulator_bias_xi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_xi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_xi() directly.

    YANG Description: The bias on in-phase path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_xi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_xi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_xi(self):
    self.__modulator_bias_xi = YANGDynClass(base=modulator_bias_xi.modulator_bias_xi, is_container='container', yang_name="modulator-bias-xi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_xq(self):
    """
    Getter method for modulator_bias_xq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xq (container)

    YANG Description: The bias on quadrature path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_xq
      
  def _set_modulator_bias_xq(self, v, load=False):
    """
    Setter method for modulator_bias_xq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_xq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_xq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_xq() directly.

    YANG Description: The bias on quadrature path and Polarization X of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_xq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_xq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_xq(self):
    self.__modulator_bias_xq = YANGDynClass(base=modulator_bias_xq.modulator_bias_xq, is_container='container', yang_name="modulator-bias-xq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_yi(self):
    """
    Getter method for modulator_bias_yi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yi (container)

    YANG Description: The bias on in-phase path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_yi
      
  def _set_modulator_bias_yi(self, v, load=False):
    """
    Setter method for modulator_bias_yi, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yi (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_yi is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_yi() directly.

    YANG Description: The bias on in-phase path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_yi must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_yi = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_yi(self):
    self.__modulator_bias_yi = YANGDynClass(base=modulator_bias_yi.modulator_bias_yi, is_container='container', yang_name="modulator-bias-yi", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_yq(self):
    """
    Getter method for modulator_bias_yq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yq (container)

    YANG Description: The bias on quadrature path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulator_bias_yq
      
  def _set_modulator_bias_yq(self, v, load=False):
    """
    Setter method for modulator_bias_yq, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_yq (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_yq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_yq() directly.

    YANG Description: The bias on quadrature path and Polarization Y of
the coherent modulator. This is represented as a percentage
with 2 decimal precision. This term is defined by OIF
Implementation Agreement for Coherent CMIS. Values include
the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_yq must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_yq = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_yq(self):
    self.__modulator_bias_yq = YANGDynClass(base=modulator_bias_yq.modulator_bias_yq, is_container='container', yang_name="modulator-bias-yq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_x_phase(self):
    """
    Getter method for modulator_bias_x_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_x_phase (container)

    YANG Description: The X-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    return self.__modulator_bias_x_phase
      
  def _set_modulator_bias_x_phase(self, v, load=False):
    """
    Setter method for modulator_bias_x_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_x_phase (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_x_phase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_x_phase() directly.

    YANG Description: The X-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_x_phase must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_x_phase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_x_phase(self):
    self.__modulator_bias_x_phase = YANGDynClass(base=modulator_bias_x_phase.modulator_bias_x_phase, is_container='container', yang_name="modulator-bias-x-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulator_bias_y_phase(self):
    """
    Getter method for modulator_bias_y_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_y_phase (container)

    YANG Description: The Y-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    return self.__modulator_bias_y_phase
      
  def _set_modulator_bias_y_phase(self, v, load=False):
    """
    Setter method for modulator_bias_y_phase, mapped from YANG variable /components/component/optical_channel/state/modulator_bias_y_phase (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulator_bias_y_phase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulator_bias_y_phase() directly.

    YANG Description: The Y-Phase bias of the coherent modulator. This is
represented as a percentage with 2 decimal precision. This
term is defined by OIF Implementation Agreement for
Coherent CMIS. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max statistics
are not supported, the target is expected to just supply
the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulator_bias_y_phase must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulator_bias_y_phase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulator_bias_y_phase(self):
    self.__modulator_bias_y_phase = YANGDynClass(base=modulator_bias_y_phase.modulator_bias_y_phase, is_container='container', yang_name="modulator-bias-y-phase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_osnr(self):
    """
    Getter method for osnr, mapped from YANG variable /components/component/optical_channel/state/osnr (container)

    YANG Description: Optical signal to noise ratio at 12.5GHz noise bandwidth
in dB with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value.
    """
    return self.__osnr
      
  def _set_osnr(self, v, load=False):
    """
    Setter method for osnr, mapped from YANG variable /components/component/optical_channel/state/osnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_osnr() directly.

    YANG Description: Optical signal to noise ratio at 12.5GHz noise bandwidth
in dB with two decimal precision. Values include the
instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target
is expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """osnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_osnr(self):
    self.__osnr = YANGDynClass(base=osnr.osnr, is_container='container', yang_name="osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_carrier_frequency_offset(self):
    """
    Getter method for carrier_frequency_offset, mapped from YANG variable /components/component/optical_channel/state/carrier_frequency_offset (container)

    YANG Description: Carrier frequency offset in MHz with 1 decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value.
    """
    return self.__carrier_frequency_offset
      
  def _set_carrier_frequency_offset(self, v, load=False):
    """
    Setter method for carrier_frequency_offset, mapped from YANG variable /components/component/optical_channel/state/carrier_frequency_offset (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_carrier_frequency_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_carrier_frequency_offset() directly.

    YANG Description: Carrier frequency offset in MHz with 1 decimal precision.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not supported,
the target is expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """carrier_frequency_offset must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__carrier_frequency_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_carrier_frequency_offset(self):
    self.__carrier_frequency_offset = YANGDynClass(base=carrier_frequency_offset.carrier_frequency_offset, is_container='container', yang_name="carrier-frequency-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_sop_roc(self):
    """
    Getter method for sop_roc, mapped from YANG variable /components/component/optical_channel/state/sop_roc (container)

    YANG Description: State-of-polarization rate-of-change (SOP-ROC) in krad/s with 1
decimal precision. This term is defined by OIF Implementation
Agreement for Coherent CMIS. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value.
    """
    return self.__sop_roc
      
  def _set_sop_roc(self, v, load=False):
    """
    Setter method for sop_roc, mapped from YANG variable /components/component/optical_channel/state/sop_roc (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sop_roc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sop_roc() directly.

    YANG Description: State-of-polarization rate-of-change (SOP-ROC) in krad/s with 1
decimal precision. This term is defined by OIF Implementation
Agreement for Coherent CMIS. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected to just
supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sop_roc must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__sop_roc = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sop_roc(self):
    self.__sop_roc = YANGDynClass(base=sop_roc.sop_roc, is_container='container', yang_name="sop-roc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_modulation_error_ratio(self):
    """
    Getter method for modulation_error_ratio, mapped from YANG variable /components/component/optical_channel/state/modulation_error_ratio (container)

    YANG Description: Modulation error ratio in dB with two decimal precision. Values
include the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    return self.__modulation_error_ratio
      
  def _set_modulation_error_ratio(self, v, load=False):
    """
    Setter method for modulation_error_ratio, mapped from YANG variable /components/component/optical_channel/state/modulation_error_ratio (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modulation_error_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modulation_error_ratio() directly.

    YANG Description: Modulation error ratio in dB with two decimal precision. Values
include the instantaneous, average, minimum, and maximum statistics.
If avg/min/max statistics are not supported, the target is
expected to just supply the instant value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """modulation_error_ratio must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__modulation_error_ratio = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_modulation_error_ratio(self):
    self.__modulation_error_ratio = YANGDynClass(base=modulation_error_ratio.modulation_error_ratio, is_container='container', yang_name="modulation-error-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_fec_uncorrectable_blocks(self):
    """
    Getter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/optical_channel/state/fec_uncorrectable_blocks (yang:counter64)

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    return self.__fec_uncorrectable_blocks
      
  def _set_fec_uncorrectable_blocks(self, v, load=False):
    """
    Setter method for fec_uncorrectable_blocks, mapped from YANG variable /components/component/optical_channel/state/fec_uncorrectable_blocks (yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fec_uncorrectable_blocks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fec_uncorrectable_blocks() directly.

    YANG Description: The number of blocks or frames that were uncorrectable by
the FEC
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fec_uncorrectable_blocks must be of a type compatible with yang:counter64""",
          'defined-type': "yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)""",
        })

    self.__fec_uncorrectable_blocks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fec_uncorrectable_blocks(self):
    self.__fec_uncorrectable_blocks = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="fec-uncorrectable-blocks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='yang:counter64', is_config=False)


  def _get_pre_fec_ber(self):
    """
    Getter method for pre_fec_ber, mapped from YANG variable /components/component/optical_channel/state/pre_fec_ber (container)

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__pre_fec_ber
      
  def _set_pre_fec_ber(self, v, load=False):
    """
    Setter method for pre_fec_ber, mapped from YANG variable /components/component/optical_channel/state/pre_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber() directly.

    YANG Description: Bit error rate before forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__pre_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber(self):
    self.__pre_fec_ber = YANGDynClass(base=pre_fec_ber.pre_fec_ber, is_container='container', yang_name="pre-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_post_fec_ber(self):
    """
    Getter method for post_fec_ber, mapped from YANG variable /components/component/optical_channel/state/post_fec_ber (container)

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    return self.__post_fec_ber
      
  def _set_post_fec_ber(self, v, load=False):
    """
    Setter method for post_fec_ber, mapped from YANG variable /components/component/optical_channel/state/post_fec_ber (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_fec_ber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_fec_ber() directly.

    YANG Description: Bit error rate after forward error correction -- computed
value with 18 decimal precision. Note that decimal64
supports values as small as i x 10^-18 where i is an
integer. Values smaller than this should be reported as 0
to inidicate error free or near error free performance.
Values include the instantaneous, average, minimum, and
maximum statistics. If avg/min/max statistics are not
supported, the target is expected to just supply the
instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_fec_ber must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__post_fec_ber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_fec_ber(self):
    self.__post_fec_ber = YANGDynClass(base=post_fec_ber.post_fec_ber, is_container='container', yang_name="post-fec-ber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_q_value(self):
    """
    Getter method for q_value, mapped from YANG variable /components/component/optical_channel/state/q_value (container)

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__q_value
      
  def _set_q_value(self, v, load=False):
    """
    Setter method for q_value, mapped from YANG variable /components/component/optical_channel/state/q_value (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_q_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_q_value() directly.

    YANG Description: Quality value (factor) in dB of a channel with two
decimal precision. Values include the instantaneous,
average, minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """q_value must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__q_value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_q_value(self):
    self.__q_value = YANGDynClass(base=q_value.q_value, is_container='container', yang_name="q-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)


  def _get_esnr(self):
    """
    Getter method for esnr, mapped from YANG variable /components/component/optical_channel/state/esnr (container)

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__esnr
      
  def _set_esnr(self, v, load=False):
    """
    Setter method for esnr, mapped from YANG variable /components/component/optical_channel/state/esnr (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_esnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_esnr() directly.

    YANG Description: Electrical signal to noise ratio. Baud rate
normalized signal to noise ratio based on
error vector magnitude in dB with two decimal
precision. Values include the instantaneous, average,
minimum, and maximum statistics. If avg/min/max
statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """esnr must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)""",
        })

    self.__esnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_esnr(self):
    self.__esnr = YANGDynClass(base=esnr.esnr, is_container='container', yang_name="esnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=False)

  frequency = __builtin__.property(_get_frequency)
  target_output_power = __builtin__.property(_get_target_output_power)
  operational_mode = __builtin__.property(_get_operational_mode)
  line_port = __builtin__.property(_get_line_port)
  group_id = __builtin__.property(_get_group_id)
  logical_channel_assignment = __builtin__.property(_get_logical_channel_assignment)
  output_power = __builtin__.property(_get_output_power)
  input_power = __builtin__.property(_get_input_power)
  laser_bias_current = __builtin__.property(_get_laser_bias_current)
  chromatic_dispersion = __builtin__.property(_get_chromatic_dispersion)
  polarization_mode_dispersion = __builtin__.property(_get_polarization_mode_dispersion)
  second_order_polarization_mode_dispersion = __builtin__.property(_get_second_order_polarization_mode_dispersion)
  polarization_dependent_loss = __builtin__.property(_get_polarization_dependent_loss)
  modulator_bias_xi = __builtin__.property(_get_modulator_bias_xi)
  modulator_bias_xq = __builtin__.property(_get_modulator_bias_xq)
  modulator_bias_yi = __builtin__.property(_get_modulator_bias_yi)
  modulator_bias_yq = __builtin__.property(_get_modulator_bias_yq)
  modulator_bias_x_phase = __builtin__.property(_get_modulator_bias_x_phase)
  modulator_bias_y_phase = __builtin__.property(_get_modulator_bias_y_phase)
  osnr = __builtin__.property(_get_osnr)
  carrier_frequency_offset = __builtin__.property(_get_carrier_frequency_offset)
  sop_roc = __builtin__.property(_get_sop_roc)
  modulation_error_ratio = __builtin__.property(_get_modulation_error_ratio)
  fec_uncorrectable_blocks = __builtin__.property(_get_fec_uncorrectable_blocks)
  pre_fec_ber = __builtin__.property(_get_pre_fec_ber)
  post_fec_ber = __builtin__.property(_get_post_fec_ber)
  q_value = __builtin__.property(_get_q_value)
  esnr = __builtin__.property(_get_esnr)


  _pyangbind_elements = OrderedDict([('frequency', frequency), ('target_output_power', target_output_power), ('operational_mode', operational_mode), ('line_port', line_port), ('group_id', group_id), ('logical_channel_assignment', logical_channel_assignment), ('output_power', output_power), ('input_power', input_power), ('laser_bias_current', laser_bias_current), ('chromatic_dispersion', chromatic_dispersion), ('polarization_mode_dispersion', polarization_mode_dispersion), ('second_order_polarization_mode_dispersion', second_order_polarization_mode_dispersion), ('polarization_dependent_loss', polarization_dependent_loss), ('modulator_bias_xi', modulator_bias_xi), ('modulator_bias_xq', modulator_bias_xq), ('modulator_bias_yi', modulator_bias_yi), ('modulator_bias_yq', modulator_bias_yq), ('modulator_bias_x_phase', modulator_bias_x_phase), ('modulator_bias_y_phase', modulator_bias_y_phase), ('osnr', osnr), ('carrier_frequency_offset', carrier_frequency_offset), ('sop_roc', sop_roc), ('modulation_error_ratio', modulation_error_ratio), ('fec_uncorrectable_blocks', fec_uncorrectable_blocks), ('pre_fec_ber', pre_fec_ber), ('post_fec_ber', post_fec_ber), ('q_value', q_value), ('esnr', esnr), ])


