# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/integrated-circuit/pipeline-counters/drop/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for IC drop counters
  """
  __slots__ = ('_path_helper', '_extmethods', '__adverse_aggregate','__congestion_aggregate','__packet_processing_aggregate','__urpf_aggregate','__no_route',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adverse_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__congestion_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__packet_processing_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__urpf_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__no_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'integrated-circuit', 'pipeline-counters', 'drop', 'state']

  def _get_adverse_aggregate(self):
    """
    Getter method for adverse_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/adverse_aggregate (oc-yang:counter64)

    YANG Description: This captures the aggregation of all counters where the switch is
unexpectedly dropping packets. Occurrence of these drops on a stable
(no recent hardware or config changes) and otherwise healthy
switch needs further investigation.
This leaf counts packet discarded as result of corrupted
programming state in an INTEGRATED_CIRCUIT or corrupted data
structures of packet descriptors.

Note: corrupted packets received on ingress interfaces should be counted
in `/interfaces/interface/state/counters/in-errors` and NOT counted as
adverse-aggregate. This is because incoming corrupted packets are NOT
a signal of adverse state of an INTEGRATED_CIRCUIT but rather of an
entity adjacent to the Interface, such as a cable or transceiver). Therefore
such drops SHOULD NOT be counted as adverse-aggregate to preserve
a clean signal of INTEGRATED_CIRCUIT adverse state.
    """
    return self.__adverse_aggregate
      
  def _set_adverse_aggregate(self, v, load=False):
    """
    Setter method for adverse_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/adverse_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adverse_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adverse_aggregate() directly.

    YANG Description: This captures the aggregation of all counters where the switch is
unexpectedly dropping packets. Occurrence of these drops on a stable
(no recent hardware or config changes) and otherwise healthy
switch needs further investigation.
This leaf counts packet discarded as result of corrupted
programming state in an INTEGRATED_CIRCUIT or corrupted data
structures of packet descriptors.

Note: corrupted packets received on ingress interfaces should be counted
in `/interfaces/interface/state/counters/in-errors` and NOT counted as
adverse-aggregate. This is because incoming corrupted packets are NOT
a signal of adverse state of an INTEGRATED_CIRCUIT but rather of an
entity adjacent to the Interface, such as a cable or transceiver). Therefore
such drops SHOULD NOT be counted as adverse-aggregate to preserve
a clean signal of INTEGRATED_CIRCUIT adverse state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adverse_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__adverse_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adverse_aggregate(self):
    self.__adverse_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_congestion_aggregate(self):
    """
    Getter method for congestion_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/congestion_aggregate (oc-yang:counter64)

    YANG Description: This tracks the aggregation of all counters where the expected
conditions of packet drops due to internal congestion in some block of
the hardware that may not be visible in through other congestion
indicators like interface discards or queue drop counters.

This leaf counts packet discarded as result of exceeding
performance limits of an INTEGRATED_CIRCUT, when it processes
non-corrupted packets using legitimate, non-corrupted programming
state of the INTEGRATED_CIRCUIT.

The typical example is overloading given IC with higher packet rate (pps)
then given chip can handle. For example, let's assume chip X can process
3.6Bpps of incoming traffic and 2000 Mpps. However if average incoming
packet size is 150B, at full ingress rate this become 3000Mpps. Hence
1/3 of packets would be cropped and should be counted against
congestion-aggregate.

Another example is the case when some INTEGRATED_CIRCUIT internal data bus is
too narrow/slow for handling traffic. For example let's assume chip X needs to send
3Tbps of traffic to an external buffer memory which has only 2Tbps access I/O.  In
this case packets would be discarded, because of congestion of memory I/O bus
which is part of the INTEGRATED_CIRCUIT.  Depending on the design of the
INTEGRATED_CIRCUIT, packets could be discarded even if interface queues are
not full, hence this scenario is NOT treated as QoS queue tail-drops nor WRED drops.

Yet another example is the case where extremely large and long
ACL/filter requires more cycles to process than the INTEGRATED_CIRCUIT
has budgeted. 
    """
    return self.__congestion_aggregate
      
  def _set_congestion_aggregate(self, v, load=False):
    """
    Setter method for congestion_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/congestion_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_congestion_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_congestion_aggregate() directly.

    YANG Description: This tracks the aggregation of all counters where the expected
conditions of packet drops due to internal congestion in some block of
the hardware that may not be visible in through other congestion
indicators like interface discards or queue drop counters.

This leaf counts packet discarded as result of exceeding
performance limits of an INTEGRATED_CIRCUT, when it processes
non-corrupted packets using legitimate, non-corrupted programming
state of the INTEGRATED_CIRCUIT.

The typical example is overloading given IC with higher packet rate (pps)
then given chip can handle. For example, let's assume chip X can process
3.6Bpps of incoming traffic and 2000 Mpps. However if average incoming
packet size is 150B, at full ingress rate this become 3000Mpps. Hence
1/3 of packets would be cropped and should be counted against
congestion-aggregate.

Another example is the case when some INTEGRATED_CIRCUIT internal data bus is
too narrow/slow for handling traffic. For example let's assume chip X needs to send
3Tbps of traffic to an external buffer memory which has only 2Tbps access I/O.  In
this case packets would be discarded, because of congestion of memory I/O bus
which is part of the INTEGRATED_CIRCUIT.  Depending on the design of the
INTEGRATED_CIRCUIT, packets could be discarded even if interface queues are
not full, hence this scenario is NOT treated as QoS queue tail-drops nor WRED drops.

Yet another example is the case where extremely large and long
ACL/filter requires more cycles to process than the INTEGRATED_CIRCUIT
has budgeted. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """congestion_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__congestion_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_congestion_aggregate(self):
    self.__congestion_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_packet_processing_aggregate(self):
    """
    Getter method for packet_processing_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/packet_processing_aggregate (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to legitimate forwarding decisions (ACL drops,
No Route etc.)
This counter counts packet discarded as result of processing
non-corrupted packet against legitimate, non-corrupted state
of INTEGRATED_CIRCUIT program (FIB content, ACL content, rate-limiting token-buckets)
which mandate packet drop. The examples of this class of discard are:
- dropping packets which destination address to no match any FIB entry
- dropping packets which destination address matches FIB entry pointing
to discard next-hop (e.g. route to null0)
- dropping packts due to ACL/packet filter decission
- dropping packets due to its TTL = 1
- dropping packets due to its size exceeds egress interface MTU and
packet can't be fragmented (IPv6 or do not fragment bit is set)
-  dropping packets due to uRPF rules (note: packet is counted here and
in separate, urpf-aggregate counter simultaneously)
- etc

Note:The INTEGRATED_CIRCUIT is doing exactly what it is programmed
to do, and the packet is parsable.

    """
    return self.__packet_processing_aggregate
      
  def _set_packet_processing_aggregate(self, v, load=False):
    """
    Setter method for packet_processing_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/packet_processing_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_processing_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_processing_aggregate() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to legitimate forwarding decisions (ACL drops,
No Route etc.)
This counter counts packet discarded as result of processing
non-corrupted packet against legitimate, non-corrupted state
of INTEGRATED_CIRCUIT program (FIB content, ACL content, rate-limiting token-buckets)
which mandate packet drop. The examples of this class of discard are:
- dropping packets which destination address to no match any FIB entry
- dropping packets which destination address matches FIB entry pointing
to discard next-hop (e.g. route to null0)
- dropping packts due to ACL/packet filter decission
- dropping packets due to its TTL = 1
- dropping packets due to its size exceeds egress interface MTU and
packet can't be fragmented (IPv6 or do not fragment bit is set)
-  dropping packets due to uRPF rules (note: packet is counted here and
in separate, urpf-aggregate counter simultaneously)
- etc

Note:The INTEGRATED_CIRCUIT is doing exactly what it is programmed
to do, and the packet is parsable.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_processing_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__packet_processing_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_processing_aggregate(self):
    self.__packet_processing_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_urpf_aggregate(self):
    """
    Getter method for urpf_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/urpf_aggregate (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to failing uRPF lookup check.  This counter
and the packet-processing-aggregate counter should be incremented
for each uRPF packet drop.
This counter counts packet discarded as result of Unicast Reverse
Path Forwarding verification.
    """
    return self.__urpf_aggregate
      
  def _set_urpf_aggregate(self, v, load=False):
    """
    Setter method for urpf_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/urpf_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_urpf_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_urpf_aggregate() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to failing uRPF lookup check.  This counter
and the packet-processing-aggregate counter should be incremented
for each uRPF packet drop.
This counter counts packet discarded as result of Unicast Reverse
Path Forwarding verification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """urpf_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__urpf_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_urpf_aggregate(self):
    self.__urpf_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_no_route(self):
    """
    Getter method for no_route, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/no_route (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to no FIB entry for this ipv4 or ipv6 lookup.

This counter and the packet-processing-aggregate counter should be
incremented for each no-route packet drop.
    """
    return self.__no_route
      
  def _set_no_route(self, v, load=False):
    """
    Setter method for no_route, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/no_route (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_route() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to no FIB entry for this ipv4 or ipv6 lookup.

This counter and the packet-processing-aggregate counter should be
incremented for each no-route packet drop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_route must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__no_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_route(self):
    self.__no_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)

  adverse_aggregate = __builtin__.property(_get_adverse_aggregate)
  congestion_aggregate = __builtin__.property(_get_congestion_aggregate)
  packet_processing_aggregate = __builtin__.property(_get_packet_processing_aggregate)
  urpf_aggregate = __builtin__.property(_get_urpf_aggregate)
  no_route = __builtin__.property(_get_no_route)


  _pyangbind_elements = OrderedDict([('adverse_aggregate', adverse_aggregate), ('congestion_aggregate', congestion_aggregate), ('packet_processing_aggregate', packet_processing_aggregate), ('urpf_aggregate', urpf_aggregate), ('no_route', no_route), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /components/component/integrated-circuit/pipeline-counters/drop/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for IC drop counters
  """
  __slots__ = ('_path_helper', '_extmethods', '__adverse_aggregate','__congestion_aggregate','__packet_processing_aggregate','__urpf_aggregate','__no_route',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adverse_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__congestion_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__packet_processing_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__urpf_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__no_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'integrated-circuit', 'pipeline-counters', 'drop', 'state']

  def _get_adverse_aggregate(self):
    """
    Getter method for adverse_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/adverse_aggregate (oc-yang:counter64)

    YANG Description: This captures the aggregation of all counters where the switch is
unexpectedly dropping packets. Occurrence of these drops on a stable
(no recent hardware or config changes) and otherwise healthy
switch needs further investigation.
This leaf counts packet discarded as result of corrupted
programming state in an INTEGRATED_CIRCUIT or corrupted data
structures of packet descriptors.

Note: corrupted packets received on ingress interfaces should be counted
in `/interfaces/interface/state/counters/in-errors` and NOT counted as
adverse-aggregate. This is because incoming corrupted packets are NOT
a signal of adverse state of an INTEGRATED_CIRCUIT but rather of an
entity adjacent to the Interface, such as a cable or transceiver). Therefore
such drops SHOULD NOT be counted as adverse-aggregate to preserve
a clean signal of INTEGRATED_CIRCUIT adverse state.
    """
    return self.__adverse_aggregate
      
  def _set_adverse_aggregate(self, v, load=False):
    """
    Setter method for adverse_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/adverse_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adverse_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adverse_aggregate() directly.

    YANG Description: This captures the aggregation of all counters where the switch is
unexpectedly dropping packets. Occurrence of these drops on a stable
(no recent hardware or config changes) and otherwise healthy
switch needs further investigation.
This leaf counts packet discarded as result of corrupted
programming state in an INTEGRATED_CIRCUIT or corrupted data
structures of packet descriptors.

Note: corrupted packets received on ingress interfaces should be counted
in `/interfaces/interface/state/counters/in-errors` and NOT counted as
adverse-aggregate. This is because incoming corrupted packets are NOT
a signal of adverse state of an INTEGRATED_CIRCUIT but rather of an
entity adjacent to the Interface, such as a cable or transceiver). Therefore
such drops SHOULD NOT be counted as adverse-aggregate to preserve
a clean signal of INTEGRATED_CIRCUIT adverse state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adverse_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__adverse_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adverse_aggregate(self):
    self.__adverse_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_congestion_aggregate(self):
    """
    Getter method for congestion_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/congestion_aggregate (oc-yang:counter64)

    YANG Description: This tracks the aggregation of all counters where the expected
conditions of packet drops due to internal congestion in some block of
the hardware that may not be visible in through other congestion
indicators like interface discards or queue drop counters.

This leaf counts packet discarded as result of exceeding
performance limits of an INTEGRATED_CIRCUT, when it processes
non-corrupted packets using legitimate, non-corrupted programming
state of the INTEGRATED_CIRCUIT.

The typical example is overloading given IC with higher packet rate (pps)
then given chip can handle. For example, let's assume chip X can process
3.6Bpps of incoming traffic and 2000 Mpps. However if average incoming
packet size is 150B, at full ingress rate this become 3000Mpps. Hence
1/3 of packets would be cropped and should be counted against
congestion-aggregate.

Another example is the case when some INTEGRATED_CIRCUIT internal data bus is
too narrow/slow for handling traffic. For example let's assume chip X needs to send
3Tbps of traffic to an external buffer memory which has only 2Tbps access I/O.  In
this case packets would be discarded, because of congestion of memory I/O bus
which is part of the INTEGRATED_CIRCUIT.  Depending on the design of the
INTEGRATED_CIRCUIT, packets could be discarded even if interface queues are
not full, hence this scenario is NOT treated as QoS queue tail-drops nor WRED drops.

Yet another example is the case where extremely large and long
ACL/filter requires more cycles to process than the INTEGRATED_CIRCUIT
has budgeted. 
    """
    return self.__congestion_aggregate
      
  def _set_congestion_aggregate(self, v, load=False):
    """
    Setter method for congestion_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/congestion_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_congestion_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_congestion_aggregate() directly.

    YANG Description: This tracks the aggregation of all counters where the expected
conditions of packet drops due to internal congestion in some block of
the hardware that may not be visible in through other congestion
indicators like interface discards or queue drop counters.

This leaf counts packet discarded as result of exceeding
performance limits of an INTEGRATED_CIRCUT, when it processes
non-corrupted packets using legitimate, non-corrupted programming
state of the INTEGRATED_CIRCUIT.

The typical example is overloading given IC with higher packet rate (pps)
then given chip can handle. For example, let's assume chip X can process
3.6Bpps of incoming traffic and 2000 Mpps. However if average incoming
packet size is 150B, at full ingress rate this become 3000Mpps. Hence
1/3 of packets would be cropped and should be counted against
congestion-aggregate.

Another example is the case when some INTEGRATED_CIRCUIT internal data bus is
too narrow/slow for handling traffic. For example let's assume chip X needs to send
3Tbps of traffic to an external buffer memory which has only 2Tbps access I/O.  In
this case packets would be discarded, because of congestion of memory I/O bus
which is part of the INTEGRATED_CIRCUIT.  Depending on the design of the
INTEGRATED_CIRCUIT, packets could be discarded even if interface queues are
not full, hence this scenario is NOT treated as QoS queue tail-drops nor WRED drops.

Yet another example is the case where extremely large and long
ACL/filter requires more cycles to process than the INTEGRATED_CIRCUIT
has budgeted. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """congestion_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__congestion_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_congestion_aggregate(self):
    self.__congestion_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_packet_processing_aggregate(self):
    """
    Getter method for packet_processing_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/packet_processing_aggregate (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to legitimate forwarding decisions (ACL drops,
No Route etc.)
This counter counts packet discarded as result of processing
non-corrupted packet against legitimate, non-corrupted state
of INTEGRATED_CIRCUIT program (FIB content, ACL content, rate-limiting token-buckets)
which mandate packet drop. The examples of this class of discard are:
- dropping packets which destination address to no match any FIB entry
- dropping packets which destination address matches FIB entry pointing
to discard next-hop (e.g. route to null0)
- dropping packts due to ACL/packet filter decission
- dropping packets due to its TTL = 1
- dropping packets due to its size exceeds egress interface MTU and
packet can't be fragmented (IPv6 or do not fragment bit is set)
-  dropping packets due to uRPF rules (note: packet is counted here and
in separate, urpf-aggregate counter simultaneously)
- etc

Note:The INTEGRATED_CIRCUIT is doing exactly what it is programmed
to do, and the packet is parsable.

    """
    return self.__packet_processing_aggregate
      
  def _set_packet_processing_aggregate(self, v, load=False):
    """
    Setter method for packet_processing_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/packet_processing_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_processing_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_processing_aggregate() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to legitimate forwarding decisions (ACL drops,
No Route etc.)
This counter counts packet discarded as result of processing
non-corrupted packet against legitimate, non-corrupted state
of INTEGRATED_CIRCUIT program (FIB content, ACL content, rate-limiting token-buckets)
which mandate packet drop. The examples of this class of discard are:
- dropping packets which destination address to no match any FIB entry
- dropping packets which destination address matches FIB entry pointing
to discard next-hop (e.g. route to null0)
- dropping packts due to ACL/packet filter decission
- dropping packets due to its TTL = 1
- dropping packets due to its size exceeds egress interface MTU and
packet can't be fragmented (IPv6 or do not fragment bit is set)
-  dropping packets due to uRPF rules (note: packet is counted here and
in separate, urpf-aggregate counter simultaneously)
- etc

Note:The INTEGRATED_CIRCUIT is doing exactly what it is programmed
to do, and the packet is parsable.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_processing_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__packet_processing_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_processing_aggregate(self):
    self.__packet_processing_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_urpf_aggregate(self):
    """
    Getter method for urpf_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/urpf_aggregate (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to failing uRPF lookup check.  This counter
and the packet-processing-aggregate counter should be incremented
for each uRPF packet drop.
This counter counts packet discarded as result of Unicast Reverse
Path Forwarding verification.
    """
    return self.__urpf_aggregate
      
  def _set_urpf_aggregate(self, v, load=False):
    """
    Setter method for urpf_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/urpf_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_urpf_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_urpf_aggregate() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to failing uRPF lookup check.  This counter
and the packet-processing-aggregate counter should be incremented
for each uRPF packet drop.
This counter counts packet discarded as result of Unicast Reverse
Path Forwarding verification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """urpf_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__urpf_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_urpf_aggregate(self):
    self.__urpf_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_no_route(self):
    """
    Getter method for no_route, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/no_route (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to no FIB entry for this ipv4 or ipv6 lookup.

This counter and the packet-processing-aggregate counter should be
incremented for each no-route packet drop.
    """
    return self.__no_route
      
  def _set_no_route(self, v, load=False):
    """
    Setter method for no_route, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/no_route (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_route() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to no FIB entry for this ipv4 or ipv6 lookup.

This counter and the packet-processing-aggregate counter should be
incremented for each no-route packet drop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_route must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__no_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_route(self):
    self.__no_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)

  adverse_aggregate = __builtin__.property(_get_adverse_aggregate)
  congestion_aggregate = __builtin__.property(_get_congestion_aggregate)
  packet_processing_aggregate = __builtin__.property(_get_packet_processing_aggregate)
  urpf_aggregate = __builtin__.property(_get_urpf_aggregate)
  no_route = __builtin__.property(_get_no_route)


  _pyangbind_elements = OrderedDict([('adverse_aggregate', adverse_aggregate), ('congestion_aggregate', congestion_aggregate), ('packet_processing_aggregate', packet_processing_aggregate), ('urpf_aggregate', urpf_aggregate), ('no_route', no_route), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/integrated-circuit/pipeline-counters/drop/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for IC drop counters
  """
  __slots__ = ('_path_helper', '_extmethods', '__adverse_aggregate','__congestion_aggregate','__packet_processing_aggregate','__urpf_aggregate','__no_route',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adverse_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__congestion_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__packet_processing_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__urpf_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__no_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'integrated-circuit', 'pipeline-counters', 'drop', 'state']

  def _get_adverse_aggregate(self):
    """
    Getter method for adverse_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/adverse_aggregate (oc-yang:counter64)

    YANG Description: This captures the aggregation of all counters where the switch is
unexpectedly dropping packets. Occurrence of these drops on a stable
(no recent hardware or config changes) and otherwise healthy
switch needs further investigation.
This leaf counts packet discarded as result of corrupted
programming state in an INTEGRATED_CIRCUIT or corrupted data
structures of packet descriptors.

Note: corrupted packets received on ingress interfaces should be counted
in `/interfaces/interface/state/counters/in-errors` and NOT counted as
adverse-aggregate. This is because incoming corrupted packets are NOT
a signal of adverse state of an INTEGRATED_CIRCUIT but rather of an
entity adjacent to the Interface, such as a cable or transceiver). Therefore
such drops SHOULD NOT be counted as adverse-aggregate to preserve
a clean signal of INTEGRATED_CIRCUIT adverse state.
    """
    return self.__adverse_aggregate
      
  def _set_adverse_aggregate(self, v, load=False):
    """
    Setter method for adverse_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/adverse_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adverse_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adverse_aggregate() directly.

    YANG Description: This captures the aggregation of all counters where the switch is
unexpectedly dropping packets. Occurrence of these drops on a stable
(no recent hardware or config changes) and otherwise healthy
switch needs further investigation.
This leaf counts packet discarded as result of corrupted
programming state in an INTEGRATED_CIRCUIT or corrupted data
structures of packet descriptors.

Note: corrupted packets received on ingress interfaces should be counted
in `/interfaces/interface/state/counters/in-errors` and NOT counted as
adverse-aggregate. This is because incoming corrupted packets are NOT
a signal of adverse state of an INTEGRATED_CIRCUIT but rather of an
entity adjacent to the Interface, such as a cable or transceiver). Therefore
such drops SHOULD NOT be counted as adverse-aggregate to preserve
a clean signal of INTEGRATED_CIRCUIT adverse state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adverse_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__adverse_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adverse_aggregate(self):
    self.__adverse_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_congestion_aggregate(self):
    """
    Getter method for congestion_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/congestion_aggregate (oc-yang:counter64)

    YANG Description: This tracks the aggregation of all counters where the expected
conditions of packet drops due to internal congestion in some block of
the hardware that may not be visible in through other congestion
indicators like interface discards or queue drop counters.

This leaf counts packet discarded as result of exceeding
performance limits of an INTEGRATED_CIRCUT, when it processes
non-corrupted packets using legitimate, non-corrupted programming
state of the INTEGRATED_CIRCUIT.

The typical example is overloading given IC with higher packet rate (pps)
then given chip can handle. For example, let's assume chip X can process
3.6Bpps of incoming traffic and 2000 Mpps. However if average incoming
packet size is 150B, at full ingress rate this become 3000Mpps. Hence
1/3 of packets would be cropped and should be counted against
congestion-aggregate.

Another example is the case when some INTEGRATED_CIRCUIT internal data bus is
too narrow/slow for handling traffic. For example let's assume chip X needs to send
3Tbps of traffic to an external buffer memory which has only 2Tbps access I/O.  In
this case packets would be discarded, because of congestion of memory I/O bus
which is part of the INTEGRATED_CIRCUIT.  Depending on the design of the
INTEGRATED_CIRCUIT, packets could be discarded even if interface queues are
not full, hence this scenario is NOT treated as QoS queue tail-drops nor WRED drops.

Yet another example is the case where extremely large and long
ACL/filter requires more cycles to process than the INTEGRATED_CIRCUIT
has budgeted. 
    """
    return self.__congestion_aggregate
      
  def _set_congestion_aggregate(self, v, load=False):
    """
    Setter method for congestion_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/congestion_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_congestion_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_congestion_aggregate() directly.

    YANG Description: This tracks the aggregation of all counters where the expected
conditions of packet drops due to internal congestion in some block of
the hardware that may not be visible in through other congestion
indicators like interface discards or queue drop counters.

This leaf counts packet discarded as result of exceeding
performance limits of an INTEGRATED_CIRCUT, when it processes
non-corrupted packets using legitimate, non-corrupted programming
state of the INTEGRATED_CIRCUIT.

The typical example is overloading given IC with higher packet rate (pps)
then given chip can handle. For example, let's assume chip X can process
3.6Bpps of incoming traffic and 2000 Mpps. However if average incoming
packet size is 150B, at full ingress rate this become 3000Mpps. Hence
1/3 of packets would be cropped and should be counted against
congestion-aggregate.

Another example is the case when some INTEGRATED_CIRCUIT internal data bus is
too narrow/slow for handling traffic. For example let's assume chip X needs to send
3Tbps of traffic to an external buffer memory which has only 2Tbps access I/O.  In
this case packets would be discarded, because of congestion of memory I/O bus
which is part of the INTEGRATED_CIRCUIT.  Depending on the design of the
INTEGRATED_CIRCUIT, packets could be discarded even if interface queues are
not full, hence this scenario is NOT treated as QoS queue tail-drops nor WRED drops.

Yet another example is the case where extremely large and long
ACL/filter requires more cycles to process than the INTEGRATED_CIRCUIT
has budgeted. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """congestion_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__congestion_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_congestion_aggregate(self):
    self.__congestion_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_packet_processing_aggregate(self):
    """
    Getter method for packet_processing_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/packet_processing_aggregate (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to legitimate forwarding decisions (ACL drops,
No Route etc.)
This counter counts packet discarded as result of processing
non-corrupted packet against legitimate, non-corrupted state
of INTEGRATED_CIRCUIT program (FIB content, ACL content, rate-limiting token-buckets)
which mandate packet drop. The examples of this class of discard are:
- dropping packets which destination address to no match any FIB entry
- dropping packets which destination address matches FIB entry pointing
to discard next-hop (e.g. route to null0)
- dropping packts due to ACL/packet filter decission
- dropping packets due to its TTL = 1
- dropping packets due to its size exceeds egress interface MTU and
packet can't be fragmented (IPv6 or do not fragment bit is set)
-  dropping packets due to uRPF rules (note: packet is counted here and
in separate, urpf-aggregate counter simultaneously)
- etc

Note:The INTEGRATED_CIRCUIT is doing exactly what it is programmed
to do, and the packet is parsable.

    """
    return self.__packet_processing_aggregate
      
  def _set_packet_processing_aggregate(self, v, load=False):
    """
    Setter method for packet_processing_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/packet_processing_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_processing_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_processing_aggregate() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to legitimate forwarding decisions (ACL drops,
No Route etc.)
This counter counts packet discarded as result of processing
non-corrupted packet against legitimate, non-corrupted state
of INTEGRATED_CIRCUIT program (FIB content, ACL content, rate-limiting token-buckets)
which mandate packet drop. The examples of this class of discard are:
- dropping packets which destination address to no match any FIB entry
- dropping packets which destination address matches FIB entry pointing
to discard next-hop (e.g. route to null0)
- dropping packts due to ACL/packet filter decission
- dropping packets due to its TTL = 1
- dropping packets due to its size exceeds egress interface MTU and
packet can't be fragmented (IPv6 or do not fragment bit is set)
-  dropping packets due to uRPF rules (note: packet is counted here and
in separate, urpf-aggregate counter simultaneously)
- etc

Note:The INTEGRATED_CIRCUIT is doing exactly what it is programmed
to do, and the packet is parsable.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_processing_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__packet_processing_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_processing_aggregate(self):
    self.__packet_processing_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_urpf_aggregate(self):
    """
    Getter method for urpf_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/urpf_aggregate (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to failing uRPF lookup check.  This counter
and the packet-processing-aggregate counter should be incremented
for each uRPF packet drop.
This counter counts packet discarded as result of Unicast Reverse
Path Forwarding verification.
    """
    return self.__urpf_aggregate
      
  def _set_urpf_aggregate(self, v, load=False):
    """
    Setter method for urpf_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/urpf_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_urpf_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_urpf_aggregate() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to failing uRPF lookup check.  This counter
and the packet-processing-aggregate counter should be incremented
for each uRPF packet drop.
This counter counts packet discarded as result of Unicast Reverse
Path Forwarding verification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """urpf_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__urpf_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_urpf_aggregate(self):
    self.__urpf_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_no_route(self):
    """
    Getter method for no_route, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/no_route (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to no FIB entry for this ipv4 or ipv6 lookup.

This counter and the packet-processing-aggregate counter should be
incremented for each no-route packet drop.
    """
    return self.__no_route
      
  def _set_no_route(self, v, load=False):
    """
    Setter method for no_route, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/no_route (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_route() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to no FIB entry for this ipv4 or ipv6 lookup.

This counter and the packet-processing-aggregate counter should be
incremented for each no-route packet drop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_route must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__no_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_route(self):
    self.__no_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)

  adverse_aggregate = __builtin__.property(_get_adverse_aggregate)
  congestion_aggregate = __builtin__.property(_get_congestion_aggregate)
  packet_processing_aggregate = __builtin__.property(_get_packet_processing_aggregate)
  urpf_aggregate = __builtin__.property(_get_urpf_aggregate)
  no_route = __builtin__.property(_get_no_route)


  _pyangbind_elements = OrderedDict([('adverse_aggregate', adverse_aggregate), ('congestion_aggregate', congestion_aggregate), ('packet_processing_aggregate', packet_processing_aggregate), ('urpf_aggregate', urpf_aggregate), ('no_route', no_route), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /components/component/integrated-circuit/pipeline-counters/drop/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: State container for IC drop counters
  """
  __slots__ = ('_path_helper', '_extmethods', '__adverse_aggregate','__congestion_aggregate','__packet_processing_aggregate','__urpf_aggregate','__no_route',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__adverse_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__congestion_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__packet_processing_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__urpf_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    self.__no_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'integrated-circuit', 'pipeline-counters', 'drop', 'state']

  def _get_adverse_aggregate(self):
    """
    Getter method for adverse_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/adverse_aggregate (oc-yang:counter64)

    YANG Description: This captures the aggregation of all counters where the switch is
unexpectedly dropping packets. Occurrence of these drops on a stable
(no recent hardware or config changes) and otherwise healthy
switch needs further investigation.
This leaf counts packet discarded as result of corrupted
programming state in an INTEGRATED_CIRCUIT or corrupted data
structures of packet descriptors.

Note: corrupted packets received on ingress interfaces should be counted
in `/interfaces/interface/state/counters/in-errors` and NOT counted as
adverse-aggregate. This is because incoming corrupted packets are NOT
a signal of adverse state of an INTEGRATED_CIRCUIT but rather of an
entity adjacent to the Interface, such as a cable or transceiver). Therefore
such drops SHOULD NOT be counted as adverse-aggregate to preserve
a clean signal of INTEGRATED_CIRCUIT adverse state.
    """
    return self.__adverse_aggregate
      
  def _set_adverse_aggregate(self, v, load=False):
    """
    Setter method for adverse_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/adverse_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_adverse_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_adverse_aggregate() directly.

    YANG Description: This captures the aggregation of all counters where the switch is
unexpectedly dropping packets. Occurrence of these drops on a stable
(no recent hardware or config changes) and otherwise healthy
switch needs further investigation.
This leaf counts packet discarded as result of corrupted
programming state in an INTEGRATED_CIRCUIT or corrupted data
structures of packet descriptors.

Note: corrupted packets received on ingress interfaces should be counted
in `/interfaces/interface/state/counters/in-errors` and NOT counted as
adverse-aggregate. This is because incoming corrupted packets are NOT
a signal of adverse state of an INTEGRATED_CIRCUIT but rather of an
entity adjacent to the Interface, such as a cable or transceiver). Therefore
such drops SHOULD NOT be counted as adverse-aggregate to preserve
a clean signal of INTEGRATED_CIRCUIT adverse state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """adverse_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__adverse_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_adverse_aggregate(self):
    self.__adverse_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="adverse-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_congestion_aggregate(self):
    """
    Getter method for congestion_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/congestion_aggregate (oc-yang:counter64)

    YANG Description: This tracks the aggregation of all counters where the expected
conditions of packet drops due to internal congestion in some block of
the hardware that may not be visible in through other congestion
indicators like interface discards or queue drop counters.

This leaf counts packet discarded as result of exceeding
performance limits of an INTEGRATED_CIRCUT, when it processes
non-corrupted packets using legitimate, non-corrupted programming
state of the INTEGRATED_CIRCUIT.

The typical example is overloading given IC with higher packet rate (pps)
then given chip can handle. For example, let's assume chip X can process
3.6Bpps of incoming traffic and 2000 Mpps. However if average incoming
packet size is 150B, at full ingress rate this become 3000Mpps. Hence
1/3 of packets would be cropped and should be counted against
congestion-aggregate.

Another example is the case when some INTEGRATED_CIRCUIT internal data bus is
too narrow/slow for handling traffic. For example let's assume chip X needs to send
3Tbps of traffic to an external buffer memory which has only 2Tbps access I/O.  In
this case packets would be discarded, because of congestion of memory I/O bus
which is part of the INTEGRATED_CIRCUIT.  Depending on the design of the
INTEGRATED_CIRCUIT, packets could be discarded even if interface queues are
not full, hence this scenario is NOT treated as QoS queue tail-drops nor WRED drops.

Yet another example is the case where extremely large and long
ACL/filter requires more cycles to process than the INTEGRATED_CIRCUIT
has budgeted. 
    """
    return self.__congestion_aggregate
      
  def _set_congestion_aggregate(self, v, load=False):
    """
    Setter method for congestion_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/congestion_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_congestion_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_congestion_aggregate() directly.

    YANG Description: This tracks the aggregation of all counters where the expected
conditions of packet drops due to internal congestion in some block of
the hardware that may not be visible in through other congestion
indicators like interface discards or queue drop counters.

This leaf counts packet discarded as result of exceeding
performance limits of an INTEGRATED_CIRCUT, when it processes
non-corrupted packets using legitimate, non-corrupted programming
state of the INTEGRATED_CIRCUIT.

The typical example is overloading given IC with higher packet rate (pps)
then given chip can handle. For example, let's assume chip X can process
3.6Bpps of incoming traffic and 2000 Mpps. However if average incoming
packet size is 150B, at full ingress rate this become 3000Mpps. Hence
1/3 of packets would be cropped and should be counted against
congestion-aggregate.

Another example is the case when some INTEGRATED_CIRCUIT internal data bus is
too narrow/slow for handling traffic. For example let's assume chip X needs to send
3Tbps of traffic to an external buffer memory which has only 2Tbps access I/O.  In
this case packets would be discarded, because of congestion of memory I/O bus
which is part of the INTEGRATED_CIRCUIT.  Depending on the design of the
INTEGRATED_CIRCUIT, packets could be discarded even if interface queues are
not full, hence this scenario is NOT treated as QoS queue tail-drops nor WRED drops.

Yet another example is the case where extremely large and long
ACL/filter requires more cycles to process than the INTEGRATED_CIRCUIT
has budgeted. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """congestion_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__congestion_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_congestion_aggregate(self):
    self.__congestion_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="congestion-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_packet_processing_aggregate(self):
    """
    Getter method for packet_processing_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/packet_processing_aggregate (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to legitimate forwarding decisions (ACL drops,
No Route etc.)
This counter counts packet discarded as result of processing
non-corrupted packet against legitimate, non-corrupted state
of INTEGRATED_CIRCUIT program (FIB content, ACL content, rate-limiting token-buckets)
which mandate packet drop. The examples of this class of discard are:
- dropping packets which destination address to no match any FIB entry
- dropping packets which destination address matches FIB entry pointing
to discard next-hop (e.g. route to null0)
- dropping packts due to ACL/packet filter decission
- dropping packets due to its TTL = 1
- dropping packets due to its size exceeds egress interface MTU and
packet can't be fragmented (IPv6 or do not fragment bit is set)
-  dropping packets due to uRPF rules (note: packet is counted here and
in separate, urpf-aggregate counter simultaneously)
- etc

Note:The INTEGRATED_CIRCUIT is doing exactly what it is programmed
to do, and the packet is parsable.

    """
    return self.__packet_processing_aggregate
      
  def _set_packet_processing_aggregate(self, v, load=False):
    """
    Setter method for packet_processing_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/packet_processing_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_processing_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_processing_aggregate() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to legitimate forwarding decisions (ACL drops,
No Route etc.)
This counter counts packet discarded as result of processing
non-corrupted packet against legitimate, non-corrupted state
of INTEGRATED_CIRCUIT program (FIB content, ACL content, rate-limiting token-buckets)
which mandate packet drop. The examples of this class of discard are:
- dropping packets which destination address to no match any FIB entry
- dropping packets which destination address matches FIB entry pointing
to discard next-hop (e.g. route to null0)
- dropping packts due to ACL/packet filter decission
- dropping packets due to its TTL = 1
- dropping packets due to its size exceeds egress interface MTU and
packet can't be fragmented (IPv6 or do not fragment bit is set)
-  dropping packets due to uRPF rules (note: packet is counted here and
in separate, urpf-aggregate counter simultaneously)
- etc

Note:The INTEGRATED_CIRCUIT is doing exactly what it is programmed
to do, and the packet is parsable.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """packet_processing_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__packet_processing_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_packet_processing_aggregate(self):
    self.__packet_processing_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="packet-processing-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_urpf_aggregate(self):
    """
    Getter method for urpf_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/urpf_aggregate (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to failing uRPF lookup check.  This counter
and the packet-processing-aggregate counter should be incremented
for each uRPF packet drop.
This counter counts packet discarded as result of Unicast Reverse
Path Forwarding verification.
    """
    return self.__urpf_aggregate
      
  def _set_urpf_aggregate(self, v, load=False):
    """
    Setter method for urpf_aggregate, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/urpf_aggregate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_urpf_aggregate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_urpf_aggregate() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to failing uRPF lookup check.  This counter
and the packet-processing-aggregate counter should be incremented
for each uRPF packet drop.
This counter counts packet discarded as result of Unicast Reverse
Path Forwarding verification.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """urpf_aggregate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__urpf_aggregate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_urpf_aggregate(self):
    self.__urpf_aggregate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="urpf-aggregate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)


  def _get_no_route(self):
    """
    Getter method for no_route, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/no_route (oc-yang:counter64)

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to no FIB entry for this ipv4 or ipv6 lookup.

This counter and the packet-processing-aggregate counter should be
incremented for each no-route packet drop.
    """
    return self.__no_route
      
  def _set_no_route(self, v, load=False):
    """
    Setter method for no_route, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/drop/state/no_route (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_no_route is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_no_route() directly.

    YANG Description: This aggregation of counters represents the conditions in which
packets are dropped due to no FIB entry for this ipv4 or ipv6 lookup.

This counter and the packet-processing-aggregate counter should be
incremented for each no-route packet drop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """no_route must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__no_route = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_no_route(self):
    self.__no_route = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="no-route", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='oc-yang:counter64', is_config=False)

  adverse_aggregate = __builtin__.property(_get_adverse_aggregate)
  congestion_aggregate = __builtin__.property(_get_congestion_aggregate)
  packet_processing_aggregate = __builtin__.property(_get_packet_processing_aggregate)
  urpf_aggregate = __builtin__.property(_get_urpf_aggregate)
  no_route = __builtin__.property(_get_no_route)


  _pyangbind_elements = OrderedDict([('adverse_aggregate', adverse_aggregate), ('congestion_aggregate', congestion_aggregate), ('packet_processing_aggregate', packet_processing_aggregate), ('urpf_aggregate', urpf_aggregate), ('no_route', no_route), ])


