# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
from . import config
from . import state
from . import mount_points
from . import aaa
from . import alarms
from . import logging
from . import processes
from . import messages
from . import license
from . import ssh_server
from . import telnet_server
from . import clock
from . import cpus
from . import dns
from . import mac_address
from . import memory
from . import ntp
from . import grpc_servers
from . import openflow
from . import utilization
from . import control_plane_traffic
from . import hashing
from . import bootz
from . import gnmi_pathz_policies
from . import console
class system(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system - based on the path /system. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for system-related configuration and
operational state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__mount_points','__aaa','__alarms','__logging','__processes','__messages','__license','__ssh_server','__telnet_server','__clock','__cpus','__dns','__mac_address','__memory','__ntp','__grpc_servers','__openflow','__utilization','__control_plane_traffic','__hashing','__bootz','__gnmi_pathz_policies','__console',)

  _yang_name = 'system'
  _yang_namespace = 'http://openconfig.net/yang/system'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    self.__mount_points = YANGDynClass(base=mount_points.mount_points, is_container='container', yang_name="mount-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    self.__aaa = YANGDynClass(base=aaa.aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__alarms = YANGDynClass(base=alarms.alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__processes = YANGDynClass(base=processes.processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__messages = YANGDynClass(base=messages.messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__license = YANGDynClass(base=license.license, is_container='container', yang_name="license", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__ssh_server = YANGDynClass(base=ssh_server.ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__telnet_server = YANGDynClass(base=telnet_server.telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__clock = YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__cpus = YANGDynClass(base=cpus.cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    self.__dns = YANGDynClass(base=dns.dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__mac_address = YANGDynClass(base=mac_address.mac_address, is_container='container', yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__memory = YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__ntp = YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__grpc_servers = YANGDynClass(base=grpc_servers.grpc_servers, is_container='container', yang_name="grpc-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-grpc', defining_module='openconfig-system-grpc', yang_type='container', is_config=True)
    self.__openflow = YANGDynClass(base=openflow.openflow, is_container='container', yang_name="openflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openflow', defining_module='openconfig-openflow', yang_type='container', is_config=True)
    self.__utilization = YANGDynClass(base=utilization.utilization, is_container='container', yang_name="utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-utilization', defining_module='openconfig-system-utilization', yang_type='container', is_config=True)
    self.__control_plane_traffic = YANGDynClass(base=control_plane_traffic.control_plane_traffic, is_container='container', yang_name="control-plane-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-controlplane', defining_module='openconfig-system-controlplane', yang_type='container', is_config=True)
    self.__hashing = YANGDynClass(base=hashing.hashing, is_container='container', yang_name="hashing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='container', is_config=True)
    self.__bootz = YANGDynClass(base=bootz.bootz, is_container='container', yang_name="bootz", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-bootz', defining_module='openconfig-system-bootz', yang_type='container', is_config=True)
    self.__gnmi_pathz_policies = YANGDynClass(base=gnmi_pathz_policies.gnmi_pathz_policies, is_container='container', yang_name="gnmi-pathz-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/pathz', defining_module='openconfig-gnsi-pathz', yang_type='container', is_config=False)
    self.__console = YANGDynClass(base=console.console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/credentialz', defining_module='openconfig-gnsi-credentialz', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['system']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /system/config (container)

    YANG Description: Global configuration data for the system
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /system/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Global configuration data for the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /system/state (container)

    YANG Description: Global operational state data for the system
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /system/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Global operational state data for the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)


  def _get_mount_points(self):
    """
    Getter method for mount_points, mapped from YANG variable /system/mount_points (container)

    YANG Description: When a system has a set of filesystems that are attached to a
directory (i.e., mounted on the system) they are expected to be
present in this list. If the system has the concept of mounting
physical or virtual resources to a mount point within the root
filesystem (/) they should also be included in this list.
    """
    return self.__mount_points
      
  def _set_mount_points(self, v, load=False):
    """
    Setter method for mount_points, mapped from YANG variable /system/mount_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mount_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mount_points() directly.

    YANG Description: When a system has a set of filesystems that are attached to a
directory (i.e., mounted on the system) they are expected to be
present in this list. If the system has the concept of mounting
physical or virtual resources to a mount point within the root
filesystem (/) they should also be included in this list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mount_points.mount_points, is_container='container', yang_name="mount-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mount_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mount_points.mount_points, is_container='container', yang_name="mount-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)""",
        })

    self.__mount_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mount_points(self):
    self.__mount_points = YANGDynClass(base=mount_points.mount_points, is_container='container', yang_name="mount-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)


  def _get_aaa(self):
    """
    Getter method for aaa, mapped from YANG variable /system/aaa (container)

    YANG Description: Top-level container for AAA services
    """
    return self.__aaa
      
  def _set_aaa(self, v, load=False):
    """
    Setter method for aaa, mapped from YANG variable /system/aaa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aaa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aaa() directly.

    YANG Description: Top-level container for AAA services
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=aaa.aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aaa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=aaa.aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__aaa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aaa(self):
    self.__aaa = YANGDynClass(base=aaa.aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_alarms(self):
    """
    Getter method for alarms, mapped from YANG variable /system/alarms (container)

    YANG Description: Top-level container for device alarms
    """
    return self.__alarms
      
  def _set_alarms(self, v, load=False):
    """
    Setter method for alarms, mapped from YANG variable /system/alarms (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarms() directly.

    YANG Description: Top-level container for device alarms
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=alarms.alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarms must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=alarms.alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)""",
        })

    self.__alarms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarms(self):
    self.__alarms = YANGDynClass(base=alarms.alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)


  def _get_logging(self):
    """
    Getter method for logging, mapped from YANG variable /system/logging (container)

    YANG Description: Top-level container for data related to logging / syslog
    """
    return self.__logging
      
  def _set_logging(self, v, load=False):
    """
    Setter method for logging, mapped from YANG variable /system/logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging() directly.

    YANG Description: Top-level container for data related to logging / syslog
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging.logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging(self):
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_processes(self):
    """
    Getter method for processes, mapped from YANG variable /system/processes (container)

    YANG Description: Parameters related to all monitored processes
    """
    return self.__processes
      
  def _set_processes(self, v, load=False):
    """
    Setter method for processes, mapped from YANG variable /system/processes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_processes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_processes() directly.

    YANG Description: Parameters related to all monitored processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=processes.processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """processes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=processes.processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__processes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_processes(self):
    self.__processes = YANGDynClass(base=processes.processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_messages(self):
    """
    Getter method for messages, mapped from YANG variable /system/messages (container)

    YANG Description: Top-level container for Syslog messages.
    """
    return self.__messages
      
  def _set_messages(self, v, load=False):
    """
    Setter method for messages, mapped from YANG variable /system/messages (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages() directly.

    YANG Description: Top-level container for Syslog messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=messages.messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=messages.messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__messages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages(self):
    self.__messages = YANGDynClass(base=messages.messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_license(self):
    """
    Getter method for license, mapped from YANG variable /system/license (container)

    YANG Description: Container for license model
    """
    return self.__license
      
  def _set_license(self, v, load=False):
    """
    Setter method for license, mapped from YANG variable /system/license (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_license is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_license() directly.

    YANG Description: Container for license model
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=license.license, is_container='container', yang_name="license", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """license must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=license.license, is_container='container', yang_name="license", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__license = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_license(self):
    self.__license = YANGDynClass(base=license.license, is_container='container', yang_name="license", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_ssh_server(self):
    """
    Getter method for ssh_server, mapped from YANG variable /system/ssh_server (container)

    YANG Description: Top-level container for ssh server
    """
    return self.__ssh_server
      
  def _set_ssh_server(self, v, load=False):
    """
    Setter method for ssh_server, mapped from YANG variable /system/ssh_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_server() directly.

    YANG Description: Top-level container for ssh server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ssh_server.ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ssh_server.ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__ssh_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_server(self):
    self.__ssh_server = YANGDynClass(base=ssh_server.ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_telnet_server(self):
    """
    Getter method for telnet_server, mapped from YANG variable /system/telnet_server (container)

    YANG Description: Top-level container for telnet terminal servers
    """
    return self.__telnet_server
      
  def _set_telnet_server(self, v, load=False):
    """
    Setter method for telnet_server, mapped from YANG variable /system/telnet_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telnet_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telnet_server() directly.

    YANG Description: Top-level container for telnet terminal servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=telnet_server.telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telnet_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=telnet_server.telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__telnet_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telnet_server(self):
    self.__telnet_server = YANGDynClass(base=telnet_server.telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_clock(self):
    """
    Getter method for clock, mapped from YANG variable /system/clock (container)

    YANG Description: Top-level container for clock configuration data
    """
    return self.__clock
      
  def _set_clock(self, v, load=False):
    """
    Setter method for clock, mapped from YANG variable /system/clock (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock() directly.

    YANG Description: Top-level container for clock configuration data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=clock.clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__clock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock(self):
    self.__clock = YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_cpus(self):
    """
    Getter method for cpus, mapped from YANG variable /system/cpus (container)

    YANG Description: Enclosing container for the list of CPU cores on the
system
    """
    return self.__cpus
      
  def _set_cpus(self, v, load=False):
    """
    Setter method for cpus, mapped from YANG variable /system/cpus (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpus() directly.

    YANG Description: Enclosing container for the list of CPU cores on the
system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cpus.cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpus must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cpus.cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)""",
        })

    self.__cpus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpus(self):
    self.__cpus = YANGDynClass(base=cpus.cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)


  def _get_dns(self):
    """
    Getter method for dns, mapped from YANG variable /system/dns (container)

    YANG Description: Enclosing container for DNS resolver data
    """
    return self.__dns
      
  def _set_dns(self, v, load=False):
    """
    Setter method for dns, mapped from YANG variable /system/dns (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns() directly.

    YANG Description: Enclosing container for DNS resolver data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=dns.dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dns.dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__dns = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns(self):
    self.__dns = YANGDynClass(base=dns.dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /system/mac_address (container)

    YANG Description: Top-level container for system's MAC address configuration and state
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /system/mac_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Top-level container for system's MAC address configuration and state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mac_address.mac_address, is_container='container', yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_address.mac_address, is_container='container', yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=mac_address.mac_address, is_container='container', yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /system/memory (container)

    YANG Description: Top-level container for system memory data
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /system/memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: Top-level container for system memory data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_ntp(self):
    """
    Getter method for ntp, mapped from YANG variable /system/ntp (container)

    YANG Description: Top-level container for NTP configuration and state
    """
    return self.__ntp
      
  def _set_ntp(self, v, load=False):
    """
    Setter method for ntp, mapped from YANG variable /system/ntp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp() directly.

    YANG Description: Top-level container for NTP configuration and state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ntp.ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__ntp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp(self):
    self.__ntp = YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_grpc_servers(self):
    """
    Getter method for grpc_servers, mapped from YANG variable /system/grpc_servers (container)

    YANG Description: List of gRPC servers that can be configured on the device.
    """
    return self.__grpc_servers
      
  def _set_grpc_servers(self, v, load=False):
    """
    Setter method for grpc_servers, mapped from YANG variable /system/grpc_servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grpc_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grpc_servers() directly.

    YANG Description: List of gRPC servers that can be configured on the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=grpc_servers.grpc_servers, is_container='container', yang_name="grpc-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-grpc', defining_module='openconfig-system-grpc', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grpc_servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=grpc_servers.grpc_servers, is_container='container', yang_name="grpc-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-grpc', defining_module='openconfig-system-grpc', yang_type='container', is_config=True)""",
        })

    self.__grpc_servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grpc_servers(self):
    self.__grpc_servers = YANGDynClass(base=grpc_servers.grpc_servers, is_container='container', yang_name="grpc-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-grpc', defining_module='openconfig-system-grpc', yang_type='container', is_config=True)


  def _get_openflow(self):
    """
    Getter method for openflow, mapped from YANG variable /system/openflow (container)

    YANG Description: Container for Openflow model
    """
    return self.__openflow
      
  def _set_openflow(self, v, load=False):
    """
    Setter method for openflow, mapped from YANG variable /system/openflow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openflow() directly.

    YANG Description: Container for Openflow model
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=openflow.openflow, is_container='container', yang_name="openflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openflow', defining_module='openconfig-openflow', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openflow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openflow.openflow, is_container='container', yang_name="openflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openflow', defining_module='openconfig-openflow', yang_type='container', is_config=True)""",
        })

    self.__openflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openflow(self):
    self.__openflow = YANGDynClass(base=openflow.openflow, is_container='container', yang_name="openflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openflow', defining_module='openconfig-openflow', yang_type='container', is_config=True)


  def _get_utilization(self):
    """
    Getter method for utilization, mapped from YANG variable /system/utilization (container)

    YANG Description: System wide resource utilization configuration.
    """
    return self.__utilization
      
  def _set_utilization(self, v, load=False):
    """
    Setter method for utilization, mapped from YANG variable /system/utilization (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_utilization() directly.

    YANG Description: System wide resource utilization configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=utilization.utilization, is_container='container', yang_name="utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-utilization', defining_module='openconfig-system-utilization', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """utilization must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=utilization.utilization, is_container='container', yang_name="utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-utilization', defining_module='openconfig-system-utilization', yang_type='container', is_config=True)""",
        })

    self.__utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_utilization(self):
    self.__utilization = YANGDynClass(base=utilization.utilization, is_container='container', yang_name="utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-utilization', defining_module='openconfig-system-utilization', yang_type='container', is_config=True)


  def _get_control_plane_traffic(self):
    """
    Getter method for control_plane_traffic, mapped from YANG variable /system/control_plane_traffic (container)

    YANG Description: Policies and configuration relating to the traffic destined towards
 the system control-plane.
    """
    return self.__control_plane_traffic
      
  def _set_control_plane_traffic(self, v, load=False):
    """
    Setter method for control_plane_traffic, mapped from YANG variable /system/control_plane_traffic (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_traffic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_traffic() directly.

    YANG Description: Policies and configuration relating to the traffic destined towards
 the system control-plane.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=control_plane_traffic.control_plane_traffic, is_container='container', yang_name="control-plane-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-controlplane', defining_module='openconfig-system-controlplane', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_traffic must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=control_plane_traffic.control_plane_traffic, is_container='container', yang_name="control-plane-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-controlplane', defining_module='openconfig-system-controlplane', yang_type='container', is_config=True)""",
        })

    self.__control_plane_traffic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_traffic(self):
    self.__control_plane_traffic = YANGDynClass(base=control_plane_traffic.control_plane_traffic, is_container='container', yang_name="control-plane-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-controlplane', defining_module='openconfig-system-controlplane', yang_type='container', is_config=True)


  def _get_hashing(self):
    """
    Getter method for hashing, mapped from YANG variable /system/hashing (container)

    YANG Description: Container for Hashing algorithms and hashing policies
    """
    return self.__hashing
      
  def _set_hashing(self, v, load=False):
    """
    Setter method for hashing, mapped from YANG variable /system/hashing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hashing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hashing() directly.

    YANG Description: Container for Hashing algorithms and hashing policies
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hashing.hashing, is_container='container', yang_name="hashing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hashing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hashing.hashing, is_container='container', yang_name="hashing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='container', is_config=True)""",
        })

    self.__hashing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hashing(self):
    self.__hashing = YANGDynClass(base=hashing.hashing, is_container='container', yang_name="hashing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='container', is_config=True)


  def _get_bootz(self):
    """
    Getter method for bootz, mapped from YANG variable /system/bootz (container)

    YANG Description: Bootz protocol container for management of bootz protocol state.
    """
    return self.__bootz
      
  def _set_bootz(self, v, load=False):
    """
    Setter method for bootz, mapped from YANG variable /system/bootz (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bootz is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bootz() directly.

    YANG Description: Bootz protocol container for management of bootz protocol state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bootz.bootz, is_container='container', yang_name="bootz", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-bootz', defining_module='openconfig-system-bootz', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bootz must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bootz.bootz, is_container='container', yang_name="bootz", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-bootz', defining_module='openconfig-system-bootz', yang_type='container', is_config=True)""",
        })

    self.__bootz = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bootz(self):
    self.__bootz = YANGDynClass(base=bootz.bootz, is_container='container', yang_name="bootz", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-bootz', defining_module='openconfig-system-bootz', yang_type='container', is_config=True)


  def _get_gnmi_pathz_policies(self):
    """
    Getter method for gnmi_pathz_policies, mapped from YANG variable /system/gnmi_pathz_policies (container)

    YANG Description: Collection of OpenConfig-path-based authorization policies that
have been installed on the device using the gNSI OpenConfig-
path-based authorization policy management service.
Each policy listed here is identified by its status (either
   ACTIVE or SANDBOX) and has its version and creation date/time
listed.
    """
    return self.__gnmi_pathz_policies
      
  def _set_gnmi_pathz_policies(self, v, load=False):
    """
    Setter method for gnmi_pathz_policies, mapped from YANG variable /system/gnmi_pathz_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gnmi_pathz_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gnmi_pathz_policies() directly.

    YANG Description: Collection of OpenConfig-path-based authorization policies that
have been installed on the device using the gNSI OpenConfig-
path-based authorization policy management service.
Each policy listed here is identified by its status (either
   ACTIVE or SANDBOX) and has its version and creation date/time
listed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=gnmi_pathz_policies.gnmi_pathz_policies, is_container='container', yang_name="gnmi-pathz-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/pathz', defining_module='openconfig-gnsi-pathz', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gnmi_pathz_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=gnmi_pathz_policies.gnmi_pathz_policies, is_container='container', yang_name="gnmi-pathz-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/pathz', defining_module='openconfig-gnsi-pathz', yang_type='container', is_config=False)""",
        })

    self.__gnmi_pathz_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gnmi_pathz_policies(self):
    self.__gnmi_pathz_policies = YANGDynClass(base=gnmi_pathz_policies.gnmi_pathz_policies, is_container='container', yang_name="gnmi-pathz-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/pathz', defining_module='openconfig-gnsi-pathz', yang_type='container', is_config=False)


  def _get_console(self):
    """
    Getter method for console, mapped from YANG variable /system/console (container)

    YANG Description: Console-related configuration and state.
    """
    return self.__console
      
  def _set_console(self, v, load=False):
    """
    Setter method for console, mapped from YANG variable /system/console (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_console is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_console() directly.

    YANG Description: Console-related configuration and state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=console.console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/credentialz', defining_module='openconfig-gnsi-credentialz', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """console must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=console.console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/credentialz', defining_module='openconfig-gnsi-credentialz', yang_type='container', is_config=True)""",
        })

    self.__console = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_console(self):
    self.__console = YANGDynClass(base=console.console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/credentialz', defining_module='openconfig-gnsi-credentialz', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  mount_points = __builtin__.property(_get_mount_points)
  aaa = __builtin__.property(_get_aaa, _set_aaa)
  alarms = __builtin__.property(_get_alarms)
  logging = __builtin__.property(_get_logging, _set_logging)
  processes = __builtin__.property(_get_processes, _set_processes)
  messages = __builtin__.property(_get_messages, _set_messages)
  license = __builtin__.property(_get_license, _set_license)
  ssh_server = __builtin__.property(_get_ssh_server, _set_ssh_server)
  telnet_server = __builtin__.property(_get_telnet_server, _set_telnet_server)
  clock = __builtin__.property(_get_clock, _set_clock)
  cpus = __builtin__.property(_get_cpus)
  dns = __builtin__.property(_get_dns, _set_dns)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  memory = __builtin__.property(_get_memory, _set_memory)
  ntp = __builtin__.property(_get_ntp, _set_ntp)
  grpc_servers = __builtin__.property(_get_grpc_servers, _set_grpc_servers)
  openflow = __builtin__.property(_get_openflow, _set_openflow)
  utilization = __builtin__.property(_get_utilization, _set_utilization)
  control_plane_traffic = __builtin__.property(_get_control_plane_traffic, _set_control_plane_traffic)
  hashing = __builtin__.property(_get_hashing, _set_hashing)
  bootz = __builtin__.property(_get_bootz, _set_bootz)
  gnmi_pathz_policies = __builtin__.property(_get_gnmi_pathz_policies)
  console = __builtin__.property(_get_console, _set_console)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('mount_points', mount_points), ('aaa', aaa), ('alarms', alarms), ('logging', logging), ('processes', processes), ('messages', messages), ('license', license), ('ssh_server', ssh_server), ('telnet_server', telnet_server), ('clock', clock), ('cpus', cpus), ('dns', dns), ('mac_address', mac_address), ('memory', memory), ('ntp', ntp), ('grpc_servers', grpc_servers), ('openflow', openflow), ('utilization', utilization), ('control_plane_traffic', control_plane_traffic), ('hashing', hashing), ('bootz', bootz), ('gnmi_pathz_policies', gnmi_pathz_policies), ('console', console), ])


from . import config
from . import state
from . import mount_points
from . import aaa
from . import alarms
from . import logging
from . import processes
from . import messages
from . import license
from . import ssh_server
from . import telnet_server
from . import clock
from . import cpus
from . import dns
from . import mac_address
from . import memory
from . import ntp
from . import grpc_servers
from . import openflow
from . import utilization
from . import control_plane_traffic
from . import hashing
from . import bootz
from . import gnmi_pathz_policies
from . import console
class system(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system - based on the path /system. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for system-related configuration and
operational state data
  """
  __slots__ = ('_path_helper', '_extmethods', '__config','__state','__mount_points','__aaa','__alarms','__logging','__processes','__messages','__license','__ssh_server','__telnet_server','__clock','__cpus','__dns','__mac_address','__memory','__ntp','__grpc_servers','__openflow','__utilization','__control_plane_traffic','__hashing','__bootz','__gnmi_pathz_policies','__console',)

  _yang_name = 'system'
  _yang_namespace = 'http://openconfig.net/yang/system'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    self.__mount_points = YANGDynClass(base=mount_points.mount_points, is_container='container', yang_name="mount-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    self.__aaa = YANGDynClass(base=aaa.aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__alarms = YANGDynClass(base=alarms.alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__processes = YANGDynClass(base=processes.processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__messages = YANGDynClass(base=messages.messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__license = YANGDynClass(base=license.license, is_container='container', yang_name="license", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__ssh_server = YANGDynClass(base=ssh_server.ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__telnet_server = YANGDynClass(base=telnet_server.telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__clock = YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__cpus = YANGDynClass(base=cpus.cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    self.__dns = YANGDynClass(base=dns.dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__mac_address = YANGDynClass(base=mac_address.mac_address, is_container='container', yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__memory = YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__ntp = YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    self.__grpc_servers = YANGDynClass(base=grpc_servers.grpc_servers, is_container='container', yang_name="grpc-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-grpc', defining_module='openconfig-system-grpc', yang_type='container', is_config=True)
    self.__openflow = YANGDynClass(base=openflow.openflow, is_container='container', yang_name="openflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openflow', defining_module='openconfig-openflow', yang_type='container', is_config=True)
    self.__utilization = YANGDynClass(base=utilization.utilization, is_container='container', yang_name="utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-utilization', defining_module='openconfig-system-utilization', yang_type='container', is_config=True)
    self.__control_plane_traffic = YANGDynClass(base=control_plane_traffic.control_plane_traffic, is_container='container', yang_name="control-plane-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-controlplane', defining_module='openconfig-system-controlplane', yang_type='container', is_config=True)
    self.__hashing = YANGDynClass(base=hashing.hashing, is_container='container', yang_name="hashing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='container', is_config=True)
    self.__bootz = YANGDynClass(base=bootz.bootz, is_container='container', yang_name="bootz", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-bootz', defining_module='openconfig-system-bootz', yang_type='container', is_config=True)
    self.__gnmi_pathz_policies = YANGDynClass(base=gnmi_pathz_policies.gnmi_pathz_policies, is_container='container', yang_name="gnmi-pathz-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/pathz', defining_module='openconfig-gnsi-pathz', yang_type='container', is_config=False)
    self.__console = YANGDynClass(base=console.console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/credentialz', defining_module='openconfig-gnsi-credentialz', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['system']

  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /system/config (container)

    YANG Description: Global configuration data for the system
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /system/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Global configuration data for the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=config.config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /system/state (container)

    YANG Description: Global operational state data for the system
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /system/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Global operational state data for the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)


  def _get_mount_points(self):
    """
    Getter method for mount_points, mapped from YANG variable /system/mount_points (container)

    YANG Description: When a system has a set of filesystems that are attached to a
directory (i.e., mounted on the system) they are expected to be
present in this list. If the system has the concept of mounting
physical or virtual resources to a mount point within the root
filesystem (/) they should also be included in this list.
    """
    return self.__mount_points
      
  def _set_mount_points(self, v, load=False):
    """
    Setter method for mount_points, mapped from YANG variable /system/mount_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mount_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mount_points() directly.

    YANG Description: When a system has a set of filesystems that are attached to a
directory (i.e., mounted on the system) they are expected to be
present in this list. If the system has the concept of mounting
physical or virtual resources to a mount point within the root
filesystem (/) they should also be included in this list.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mount_points.mount_points, is_container='container', yang_name="mount-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mount_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mount_points.mount_points, is_container='container', yang_name="mount-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)""",
        })

    self.__mount_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mount_points(self):
    self.__mount_points = YANGDynClass(base=mount_points.mount_points, is_container='container', yang_name="mount-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)


  def _get_aaa(self):
    """
    Getter method for aaa, mapped from YANG variable /system/aaa (container)

    YANG Description: Top-level container for AAA services
    """
    return self.__aaa
      
  def _set_aaa(self, v, load=False):
    """
    Setter method for aaa, mapped from YANG variable /system/aaa (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aaa is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aaa() directly.

    YANG Description: Top-level container for AAA services
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=aaa.aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aaa must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=aaa.aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__aaa = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aaa(self):
    self.__aaa = YANGDynClass(base=aaa.aaa, is_container='container', yang_name="aaa", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_alarms(self):
    """
    Getter method for alarms, mapped from YANG variable /system/alarms (container)

    YANG Description: Top-level container for device alarms
    """
    return self.__alarms
      
  def _set_alarms(self, v, load=False):
    """
    Setter method for alarms, mapped from YANG variable /system/alarms (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarms is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarms() directly.

    YANG Description: Top-level container for device alarms
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=alarms.alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarms must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=alarms.alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)""",
        })

    self.__alarms = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarms(self):
    self.__alarms = YANGDynClass(base=alarms.alarms, is_container='container', yang_name="alarms", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)


  def _get_logging(self):
    """
    Getter method for logging, mapped from YANG variable /system/logging (container)

    YANG Description: Top-level container for data related to logging / syslog
    """
    return self.__logging
      
  def _set_logging(self, v, load=False):
    """
    Setter method for logging, mapped from YANG variable /system/logging (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logging is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logging() directly.

    YANG Description: Top-level container for data related to logging / syslog
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=logging.logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logging must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__logging = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logging(self):
    self.__logging = YANGDynClass(base=logging.logging, is_container='container', yang_name="logging", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_processes(self):
    """
    Getter method for processes, mapped from YANG variable /system/processes (container)

    YANG Description: Parameters related to all monitored processes
    """
    return self.__processes
      
  def _set_processes(self, v, load=False):
    """
    Setter method for processes, mapped from YANG variable /system/processes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_processes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_processes() directly.

    YANG Description: Parameters related to all monitored processes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=processes.processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """processes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=processes.processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__processes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_processes(self):
    self.__processes = YANGDynClass(base=processes.processes, is_container='container', yang_name="processes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_messages(self):
    """
    Getter method for messages, mapped from YANG variable /system/messages (container)

    YANG Description: Top-level container for Syslog messages.
    """
    return self.__messages
      
  def _set_messages(self, v, load=False):
    """
    Setter method for messages, mapped from YANG variable /system/messages (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_messages is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_messages() directly.

    YANG Description: Top-level container for Syslog messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=messages.messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """messages must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=messages.messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__messages = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_messages(self):
    self.__messages = YANGDynClass(base=messages.messages, is_container='container', yang_name="messages", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_license(self):
    """
    Getter method for license, mapped from YANG variable /system/license (container)

    YANG Description: Container for license model
    """
    return self.__license
      
  def _set_license(self, v, load=False):
    """
    Setter method for license, mapped from YANG variable /system/license (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_license is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_license() directly.

    YANG Description: Container for license model
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=license.license, is_container='container', yang_name="license", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """license must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=license.license, is_container='container', yang_name="license", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__license = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_license(self):
    self.__license = YANGDynClass(base=license.license, is_container='container', yang_name="license", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_ssh_server(self):
    """
    Getter method for ssh_server, mapped from YANG variable /system/ssh_server (container)

    YANG Description: Top-level container for ssh server
    """
    return self.__ssh_server
      
  def _set_ssh_server(self, v, load=False):
    """
    Setter method for ssh_server, mapped from YANG variable /system/ssh_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_server() directly.

    YANG Description: Top-level container for ssh server
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ssh_server.ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssh_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ssh_server.ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__ssh_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssh_server(self):
    self.__ssh_server = YANGDynClass(base=ssh_server.ssh_server, is_container='container', yang_name="ssh-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_telnet_server(self):
    """
    Getter method for telnet_server, mapped from YANG variable /system/telnet_server (container)

    YANG Description: Top-level container for telnet terminal servers
    """
    return self.__telnet_server
      
  def _set_telnet_server(self, v, load=False):
    """
    Setter method for telnet_server, mapped from YANG variable /system/telnet_server (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telnet_server is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telnet_server() directly.

    YANG Description: Top-level container for telnet terminal servers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=telnet_server.telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telnet_server must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=telnet_server.telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__telnet_server = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telnet_server(self):
    self.__telnet_server = YANGDynClass(base=telnet_server.telnet_server, is_container='container', yang_name="telnet-server", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_clock(self):
    """
    Getter method for clock, mapped from YANG variable /system/clock (container)

    YANG Description: Top-level container for clock configuration data
    """
    return self.__clock
      
  def _set_clock(self, v, load=False):
    """
    Setter method for clock, mapped from YANG variable /system/clock (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock() directly.

    YANG Description: Top-level container for clock configuration data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=clock.clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clock must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__clock = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clock(self):
    self.__clock = YANGDynClass(base=clock.clock, is_container='container', yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_cpus(self):
    """
    Getter method for cpus, mapped from YANG variable /system/cpus (container)

    YANG Description: Enclosing container for the list of CPU cores on the
system
    """
    return self.__cpus
      
  def _set_cpus(self, v, load=False):
    """
    Setter method for cpus, mapped from YANG variable /system/cpus (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpus() directly.

    YANG Description: Enclosing container for the list of CPU cores on the
system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=cpus.cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpus must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=cpus.cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)""",
        })

    self.__cpus = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpus(self):
    self.__cpus = YANGDynClass(base=cpus.cpus, is_container='container', yang_name="cpus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=False)


  def _get_dns(self):
    """
    Getter method for dns, mapped from YANG variable /system/dns (container)

    YANG Description: Enclosing container for DNS resolver data
    """
    return self.__dns
      
  def _set_dns(self, v, load=False):
    """
    Setter method for dns, mapped from YANG variable /system/dns (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dns() directly.

    YANG Description: Enclosing container for DNS resolver data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=dns.dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dns must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=dns.dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__dns = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dns(self):
    self.__dns = YANGDynClass(base=dns.dns, is_container='container', yang_name="dns", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_mac_address(self):
    """
    Getter method for mac_address, mapped from YANG variable /system/mac_address (container)

    YANG Description: Top-level container for system's MAC address configuration and state
    """
    return self.__mac_address
      
  def _set_mac_address(self, v, load=False):
    """
    Setter method for mac_address, mapped from YANG variable /system/mac_address (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: Top-level container for system's MAC address configuration and state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=mac_address.mac_address, is_container='container', yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mac_address must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=mac_address.mac_address, is_container='container', yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__mac_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mac_address(self):
    self.__mac_address = YANGDynClass(base=mac_address.mac_address, is_container='container', yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /system/memory (container)

    YANG Description: Top-level container for system memory data
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /system/memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: Top-level container for system memory data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=memory.memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_ntp(self):
    """
    Getter method for ntp, mapped from YANG variable /system/ntp (container)

    YANG Description: Top-level container for NTP configuration and state
    """
    return self.__ntp
      
  def _set_ntp(self, v, load=False):
    """
    Setter method for ntp, mapped from YANG variable /system/ntp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ntp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ntp() directly.

    YANG Description: Top-level container for NTP configuration and state
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ntp.ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ntp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__ntp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ntp(self):
    self.__ntp = YANGDynClass(base=ntp.ntp, is_container='container', yang_name="ntp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)


  def _get_grpc_servers(self):
    """
    Getter method for grpc_servers, mapped from YANG variable /system/grpc_servers (container)

    YANG Description: List of gRPC servers that can be configured on the device.
    """
    return self.__grpc_servers
      
  def _set_grpc_servers(self, v, load=False):
    """
    Setter method for grpc_servers, mapped from YANG variable /system/grpc_servers (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_grpc_servers is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_grpc_servers() directly.

    YANG Description: List of gRPC servers that can be configured on the device.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=grpc_servers.grpc_servers, is_container='container', yang_name="grpc-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-grpc', defining_module='openconfig-system-grpc', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """grpc_servers must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=grpc_servers.grpc_servers, is_container='container', yang_name="grpc-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-grpc', defining_module='openconfig-system-grpc', yang_type='container', is_config=True)""",
        })

    self.__grpc_servers = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_grpc_servers(self):
    self.__grpc_servers = YANGDynClass(base=grpc_servers.grpc_servers, is_container='container', yang_name="grpc-servers", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-grpc', defining_module='openconfig-system-grpc', yang_type='container', is_config=True)


  def _get_openflow(self):
    """
    Getter method for openflow, mapped from YANG variable /system/openflow (container)

    YANG Description: Container for Openflow model
    """
    return self.__openflow
      
  def _set_openflow(self, v, load=False):
    """
    Setter method for openflow, mapped from YANG variable /system/openflow (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_openflow is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_openflow() directly.

    YANG Description: Container for Openflow model
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=openflow.openflow, is_container='container', yang_name="openflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openflow', defining_module='openconfig-openflow', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """openflow must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=openflow.openflow, is_container='container', yang_name="openflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openflow', defining_module='openconfig-openflow', yang_type='container', is_config=True)""",
        })

    self.__openflow = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_openflow(self):
    self.__openflow = YANGDynClass(base=openflow.openflow, is_container='container', yang_name="openflow", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openflow', defining_module='openconfig-openflow', yang_type='container', is_config=True)


  def _get_utilization(self):
    """
    Getter method for utilization, mapped from YANG variable /system/utilization (container)

    YANG Description: System wide resource utilization configuration.
    """
    return self.__utilization
      
  def _set_utilization(self, v, load=False):
    """
    Setter method for utilization, mapped from YANG variable /system/utilization (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_utilization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_utilization() directly.

    YANG Description: System wide resource utilization configuration.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=utilization.utilization, is_container='container', yang_name="utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-utilization', defining_module='openconfig-system-utilization', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """utilization must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=utilization.utilization, is_container='container', yang_name="utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-utilization', defining_module='openconfig-system-utilization', yang_type='container', is_config=True)""",
        })

    self.__utilization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_utilization(self):
    self.__utilization = YANGDynClass(base=utilization.utilization, is_container='container', yang_name="utilization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-utilization', defining_module='openconfig-system-utilization', yang_type='container', is_config=True)


  def _get_control_plane_traffic(self):
    """
    Getter method for control_plane_traffic, mapped from YANG variable /system/control_plane_traffic (container)

    YANG Description: Policies and configuration relating to the traffic destined towards
 the system control-plane.
    """
    return self.__control_plane_traffic
      
  def _set_control_plane_traffic(self, v, load=False):
    """
    Setter method for control_plane_traffic, mapped from YANG variable /system/control_plane_traffic (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_control_plane_traffic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_control_plane_traffic() directly.

    YANG Description: Policies and configuration relating to the traffic destined towards
 the system control-plane.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=control_plane_traffic.control_plane_traffic, is_container='container', yang_name="control-plane-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-controlplane', defining_module='openconfig-system-controlplane', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """control_plane_traffic must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=control_plane_traffic.control_plane_traffic, is_container='container', yang_name="control-plane-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-controlplane', defining_module='openconfig-system-controlplane', yang_type='container', is_config=True)""",
        })

    self.__control_plane_traffic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_control_plane_traffic(self):
    self.__control_plane_traffic = YANGDynClass(base=control_plane_traffic.control_plane_traffic, is_container='container', yang_name="control-plane-traffic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-controlplane', defining_module='openconfig-system-controlplane', yang_type='container', is_config=True)


  def _get_hashing(self):
    """
    Getter method for hashing, mapped from YANG variable /system/hashing (container)

    YANG Description: Container for Hashing algorithms and hashing policies
    """
    return self.__hashing
      
  def _set_hashing(self, v, load=False):
    """
    Setter method for hashing, mapped from YANG variable /system/hashing (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hashing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hashing() directly.

    YANG Description: Container for Hashing algorithms and hashing policies
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=hashing.hashing, is_container='container', yang_name="hashing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hashing must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=hashing.hashing, is_container='container', yang_name="hashing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='container', is_config=True)""",
        })

    self.__hashing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hashing(self):
    self.__hashing = YANGDynClass(base=hashing.hashing, is_container='container', yang_name="hashing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='container', is_config=True)


  def _get_bootz(self):
    """
    Getter method for bootz, mapped from YANG variable /system/bootz (container)

    YANG Description: Bootz protocol container for management of bootz protocol state.
    """
    return self.__bootz
      
  def _set_bootz(self, v, load=False):
    """
    Setter method for bootz, mapped from YANG variable /system/bootz (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bootz is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bootz() directly.

    YANG Description: Bootz protocol container for management of bootz protocol state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bootz.bootz, is_container='container', yang_name="bootz", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-bootz', defining_module='openconfig-system-bootz', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bootz must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bootz.bootz, is_container='container', yang_name="bootz", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-bootz', defining_module='openconfig-system-bootz', yang_type='container', is_config=True)""",
        })

    self.__bootz = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bootz(self):
    self.__bootz = YANGDynClass(base=bootz.bootz, is_container='container', yang_name="bootz", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system-bootz', defining_module='openconfig-system-bootz', yang_type='container', is_config=True)


  def _get_gnmi_pathz_policies(self):
    """
    Getter method for gnmi_pathz_policies, mapped from YANG variable /system/gnmi_pathz_policies (container)

    YANG Description: Collection of OpenConfig-path-based authorization policies that
have been installed on the device using the gNSI OpenConfig-
path-based authorization policy management service.
Each policy listed here is identified by its status (either
   ACTIVE or SANDBOX) and has its version and creation date/time
listed.
    """
    return self.__gnmi_pathz_policies
      
  def _set_gnmi_pathz_policies(self, v, load=False):
    """
    Setter method for gnmi_pathz_policies, mapped from YANG variable /system/gnmi_pathz_policies (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gnmi_pathz_policies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gnmi_pathz_policies() directly.

    YANG Description: Collection of OpenConfig-path-based authorization policies that
have been installed on the device using the gNSI OpenConfig-
path-based authorization policy management service.
Each policy listed here is identified by its status (either
   ACTIVE or SANDBOX) and has its version and creation date/time
listed.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=gnmi_pathz_policies.gnmi_pathz_policies, is_container='container', yang_name="gnmi-pathz-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/pathz', defining_module='openconfig-gnsi-pathz', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """gnmi_pathz_policies must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=gnmi_pathz_policies.gnmi_pathz_policies, is_container='container', yang_name="gnmi-pathz-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/pathz', defining_module='openconfig-gnsi-pathz', yang_type='container', is_config=False)""",
        })

    self.__gnmi_pathz_policies = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_gnmi_pathz_policies(self):
    self.__gnmi_pathz_policies = YANGDynClass(base=gnmi_pathz_policies.gnmi_pathz_policies, is_container='container', yang_name="gnmi-pathz-policies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/pathz', defining_module='openconfig-gnsi-pathz', yang_type='container', is_config=False)


  def _get_console(self):
    """
    Getter method for console, mapped from YANG variable /system/console (container)

    YANG Description: Console-related configuration and state.
    """
    return self.__console
      
  def _set_console(self, v, load=False):
    """
    Setter method for console, mapped from YANG variable /system/console (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_console is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_console() directly.

    YANG Description: Console-related configuration and state.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=console.console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/credentialz', defining_module='openconfig-gnsi-credentialz', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """console must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=console.console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/credentialz', defining_module='openconfig-gnsi-credentialz', yang_type='container', is_config=True)""",
        })

    self.__console = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_console(self):
    self.__console = YANGDynClass(base=console.console, is_container='container', yang_name="console", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://github.com/openconfig/yang/gnsi/credentialz', defining_module='openconfig-gnsi-credentialz', yang_type='container', is_config=True)

  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state)
  mount_points = __builtin__.property(_get_mount_points)
  aaa = __builtin__.property(_get_aaa, _set_aaa)
  alarms = __builtin__.property(_get_alarms)
  logging = __builtin__.property(_get_logging, _set_logging)
  processes = __builtin__.property(_get_processes, _set_processes)
  messages = __builtin__.property(_get_messages, _set_messages)
  license = __builtin__.property(_get_license, _set_license)
  ssh_server = __builtin__.property(_get_ssh_server, _set_ssh_server)
  telnet_server = __builtin__.property(_get_telnet_server, _set_telnet_server)
  clock = __builtin__.property(_get_clock, _set_clock)
  cpus = __builtin__.property(_get_cpus)
  dns = __builtin__.property(_get_dns, _set_dns)
  mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
  memory = __builtin__.property(_get_memory, _set_memory)
  ntp = __builtin__.property(_get_ntp, _set_ntp)
  grpc_servers = __builtin__.property(_get_grpc_servers, _set_grpc_servers)
  openflow = __builtin__.property(_get_openflow, _set_openflow)
  utilization = __builtin__.property(_get_utilization, _set_utilization)
  control_plane_traffic = __builtin__.property(_get_control_plane_traffic, _set_control_plane_traffic)
  hashing = __builtin__.property(_get_hashing, _set_hashing)
  bootz = __builtin__.property(_get_bootz, _set_bootz)
  gnmi_pathz_policies = __builtin__.property(_get_gnmi_pathz_policies)
  console = __builtin__.property(_get_console, _set_console)


  _pyangbind_elements = OrderedDict([('config', config), ('state', state), ('mount_points', mount_points), ('aaa', aaa), ('alarms', alarms), ('logging', logging), ('processes', processes), ('messages', messages), ('license', license), ('ssh_server', ssh_server), ('telnet_server', telnet_server), ('clock', clock), ('cpus', cpus), ('dns', dns), ('mac_address', mac_address), ('memory', memory), ('ntp', ntp), ('grpc_servers', grpc_servers), ('openflow', openflow), ('utilization', utilization), ('control_plane_traffic', control_plane_traffic), ('hashing', hashing), ('bootz', bootz), ('gnmi_pathz_policies', gnmi_pathz_policies), ('console', console), ])


