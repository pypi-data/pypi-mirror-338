# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/flex-algorithm/flex-algorithm-definition/algorithm/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Attributes for a Flexible Algorithm
  """
  __slots__ = ('_path_helper', '_extmethods', '__flex_algo_id','__flex_algo_name','__flex_algo_description','__metric_type','__calc_type','__priority','__exclude','__include_all','__include_any','__srlg_exclude','__algo_flags',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flex_algo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)
    self.__flex_algo_name = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    self.__flex_algo_description = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)
    self.__calc_type = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)
    self.__exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__include_all = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__include_any = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__srlg_exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__algo_flags = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'flex-algorithm', 'flex-algorithm-definition', 'algorithm', 'state']

  def _get_flex_algo_id(self):
    """
    Getter method for flex_algo_id, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_id (flex-algo-id)

    YANG Description: Flex Algorithm Identifier
    """
    return self.__flex_algo_id
      
  def _set_flex_algo_id(self, v, load=False):
    """
    Setter method for flex_algo_id, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_id (flex-algo-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_id() directly.

    YANG Description: Flex Algorithm Identifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_id must be of a type compatible with flex-algo-id""",
          'defined-type': "openconfig-flexalgo:flex-algo-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)""",
        })

    self.__flex_algo_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_id(self):
    self.__flex_algo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)


  def _get_flex_algo_name(self):
    """
    Getter method for flex_algo_name, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_name (string)

    YANG Description: Flexible Algorithm name
    """
    return self.__flex_algo_name
      
  def _set_flex_algo_name(self, v, load=False):
    """
    Setter method for flex_algo_name, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_name() directly.

    YANG Description: Flexible Algorithm name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)""",
        })

    self.__flex_algo_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_name(self):
    self.__flex_algo_name = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)


  def _get_flex_algo_description(self):
    """
    Getter method for flex_algo_description, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_description (string)

    YANG Description: Description of this flex-algo
    """
    return self.__flex_algo_description
      
  def _set_flex_algo_description(self, v, load=False):
    """
    Setter method for flex_algo_description, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_description() directly.

    YANG Description: Description of this flex-algo
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)""",
        })

    self.__flex_algo_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_description(self):
    self.__flex_algo_description = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)


  def _get_metric_type(self):
    """
    Getter method for metric_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/metric_type (flex-algo-metric-type)

    YANG Description: Indicates which is the corresponding metric type for
this algorithm
    """
    return self.__metric_type
      
  def _set_metric_type(self, v, load=False):
    """
    Setter method for metric_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/metric_type (flex-algo-metric-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_type() directly.

    YANG Description: Indicates which is the corresponding metric type for
this algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_type must be of a type compatible with flex-algo-metric-type""",
          'defined-type': "openconfig-flexalgo:flex-algo-metric-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)""",
        })

    self.__metric_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_type(self):
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)


  def _get_calc_type(self):
    """
    Getter method for calc_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/calc_type (flex-algo-calc-type)

    YANG Description: Indicates the calculation type, if advertised
    """
    return self.__calc_type
      
  def _set_calc_type(self, v, load=False):
    """
    Setter method for calc_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/calc_type (flex-algo-calc-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_calc_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_calc_type() directly.

    YANG Description: Indicates the calculation type, if advertised
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """calc_type must be of a type compatible with flex-algo-calc-type""",
          'defined-type': "openconfig-flexalgo:flex-algo-calc-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)""",
        })

    self.__calc_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_calc_type(self):
    self.__calc_type = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/priority (uint8)

    YANG Description: Indicates the priority for this algorithm
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Indicates the priority for this algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)


  def _get_exclude(self):
    """
    Getter method for exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/exclude (leafref)

    YANG Description: extended-admin-groups to exclude in path calculation.
    """
    return self.__exclude
      
  def _set_exclude(self, v, load=False):
    """
    Setter method for exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/exclude (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exclude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exclude() directly.

    YANG Description: extended-admin-groups to exclude in path calculation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exclude must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__exclude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exclude(self):
    self.__exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_include_all(self):
    """
    Getter method for include_all, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_all (leafref)

    YANG Description: extended-admin-groups, all of which must be included
    """
    return self.__include_all
      
  def _set_include_all(self, v, load=False):
    """
    Setter method for include_all, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_all (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_all() directly.

    YANG Description: extended-admin-groups, all of which must be included
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_all must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__include_all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_all(self):
    self.__include_all = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_include_any(self):
    """
    Getter method for include_any, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_any (leafref)

    YANG Description: extended-admin-groups, one of which must be included
    """
    return self.__include_any
      
  def _set_include_any(self, v, load=False):
    """
    Setter method for include_any, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_any (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_any is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_any() directly.

    YANG Description: extended-admin-groups, one of which must be included
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_any must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__include_any = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_any(self):
    self.__include_any = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_srlg_exclude(self):
    """
    Getter method for srlg_exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/srlg_exclude (leafref)

    YANG Description: list of references to named SRLGs to be excluded
    """
    return self.__srlg_exclude
      
  def _set_srlg_exclude(self, v, load=False):
    """
    Setter method for srlg_exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/srlg_exclude (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srlg_exclude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srlg_exclude() directly.

    YANG Description: list of references to named SRLGs to be excluded
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srlg_exclude must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__srlg_exclude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srlg_exclude(self):
    self.__srlg_exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_algo_flags(self):
    """
    Getter method for algo_flags, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/algo_flags (boolean)

    YANG Description: Advertise flex-algo definition flags
    """
    return self.__algo_flags
      
  def _set_algo_flags(self, v, load=False):
    """
    Setter method for algo_flags, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/algo_flags (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algo_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algo_flags() directly.

    YANG Description: Advertise flex-algo definition flags
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algo_flags must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)""",
        })

    self.__algo_flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algo_flags(self):
    self.__algo_flags = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)

  flex_algo_id = __builtin__.property(_get_flex_algo_id)
  flex_algo_name = __builtin__.property(_get_flex_algo_name)
  flex_algo_description = __builtin__.property(_get_flex_algo_description)
  metric_type = __builtin__.property(_get_metric_type)
  calc_type = __builtin__.property(_get_calc_type)
  priority = __builtin__.property(_get_priority)
  exclude = __builtin__.property(_get_exclude)
  include_all = __builtin__.property(_get_include_all)
  include_any = __builtin__.property(_get_include_any)
  srlg_exclude = __builtin__.property(_get_srlg_exclude)
  algo_flags = __builtin__.property(_get_algo_flags)


  _pyangbind_elements = OrderedDict([('flex_algo_id', flex_algo_id), ('flex_algo_name', flex_algo_name), ('flex_algo_description', flex_algo_description), ('metric_type', metric_type), ('calc_type', calc_type), ('priority', priority), ('exclude', exclude), ('include_all', include_all), ('include_any', include_any), ('srlg_exclude', srlg_exclude), ('algo_flags', algo_flags), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/flex-algorithm/flex-algorithm-definition/algorithm/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Attributes for a Flexible Algorithm
  """
  __slots__ = ('_path_helper', '_extmethods', '__flex_algo_id','__flex_algo_name','__flex_algo_description','__metric_type','__calc_type','__priority','__exclude','__include_all','__include_any','__srlg_exclude','__algo_flags',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flex_algo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)
    self.__flex_algo_name = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    self.__flex_algo_description = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)
    self.__calc_type = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)
    self.__exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__include_all = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__include_any = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__srlg_exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__algo_flags = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'flex-algorithm', 'flex-algorithm-definition', 'algorithm', 'state']

  def _get_flex_algo_id(self):
    """
    Getter method for flex_algo_id, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_id (flex-algo-id)

    YANG Description: Flex Algorithm Identifier
    """
    return self.__flex_algo_id
      
  def _set_flex_algo_id(self, v, load=False):
    """
    Setter method for flex_algo_id, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_id (flex-algo-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_id() directly.

    YANG Description: Flex Algorithm Identifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_id must be of a type compatible with flex-algo-id""",
          'defined-type': "openconfig-flexalgo:flex-algo-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)""",
        })

    self.__flex_algo_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_id(self):
    self.__flex_algo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)


  def _get_flex_algo_name(self):
    """
    Getter method for flex_algo_name, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_name (string)

    YANG Description: Flexible Algorithm name
    """
    return self.__flex_algo_name
      
  def _set_flex_algo_name(self, v, load=False):
    """
    Setter method for flex_algo_name, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_name() directly.

    YANG Description: Flexible Algorithm name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)""",
        })

    self.__flex_algo_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_name(self):
    self.__flex_algo_name = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)


  def _get_flex_algo_description(self):
    """
    Getter method for flex_algo_description, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_description (string)

    YANG Description: Description of this flex-algo
    """
    return self.__flex_algo_description
      
  def _set_flex_algo_description(self, v, load=False):
    """
    Setter method for flex_algo_description, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_description() directly.

    YANG Description: Description of this flex-algo
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)""",
        })

    self.__flex_algo_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_description(self):
    self.__flex_algo_description = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)


  def _get_metric_type(self):
    """
    Getter method for metric_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/metric_type (flex-algo-metric-type)

    YANG Description: Indicates which is the corresponding metric type for
this algorithm
    """
    return self.__metric_type
      
  def _set_metric_type(self, v, load=False):
    """
    Setter method for metric_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/metric_type (flex-algo-metric-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_type() directly.

    YANG Description: Indicates which is the corresponding metric type for
this algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_type must be of a type compatible with flex-algo-metric-type""",
          'defined-type': "openconfig-flexalgo:flex-algo-metric-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)""",
        })

    self.__metric_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_type(self):
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)


  def _get_calc_type(self):
    """
    Getter method for calc_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/calc_type (flex-algo-calc-type)

    YANG Description: Indicates the calculation type, if advertised
    """
    return self.__calc_type
      
  def _set_calc_type(self, v, load=False):
    """
    Setter method for calc_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/calc_type (flex-algo-calc-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_calc_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_calc_type() directly.

    YANG Description: Indicates the calculation type, if advertised
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """calc_type must be of a type compatible with flex-algo-calc-type""",
          'defined-type': "openconfig-flexalgo:flex-algo-calc-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)""",
        })

    self.__calc_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_calc_type(self):
    self.__calc_type = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/priority (uint8)

    YANG Description: Indicates the priority for this algorithm
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Indicates the priority for this algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)


  def _get_exclude(self):
    """
    Getter method for exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/exclude (leafref)

    YANG Description: extended-admin-groups to exclude in path calculation.
    """
    return self.__exclude
      
  def _set_exclude(self, v, load=False):
    """
    Setter method for exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/exclude (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exclude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exclude() directly.

    YANG Description: extended-admin-groups to exclude in path calculation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exclude must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__exclude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exclude(self):
    self.__exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_include_all(self):
    """
    Getter method for include_all, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_all (leafref)

    YANG Description: extended-admin-groups, all of which must be included
    """
    return self.__include_all
      
  def _set_include_all(self, v, load=False):
    """
    Setter method for include_all, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_all (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_all() directly.

    YANG Description: extended-admin-groups, all of which must be included
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_all must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__include_all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_all(self):
    self.__include_all = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_include_any(self):
    """
    Getter method for include_any, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_any (leafref)

    YANG Description: extended-admin-groups, one of which must be included
    """
    return self.__include_any
      
  def _set_include_any(self, v, load=False):
    """
    Setter method for include_any, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_any (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_any is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_any() directly.

    YANG Description: extended-admin-groups, one of which must be included
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_any must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__include_any = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_any(self):
    self.__include_any = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_srlg_exclude(self):
    """
    Getter method for srlg_exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/srlg_exclude (leafref)

    YANG Description: list of references to named SRLGs to be excluded
    """
    return self.__srlg_exclude
      
  def _set_srlg_exclude(self, v, load=False):
    """
    Setter method for srlg_exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/srlg_exclude (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srlg_exclude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srlg_exclude() directly.

    YANG Description: list of references to named SRLGs to be excluded
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srlg_exclude must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__srlg_exclude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srlg_exclude(self):
    self.__srlg_exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_algo_flags(self):
    """
    Getter method for algo_flags, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/algo_flags (boolean)

    YANG Description: Advertise flex-algo definition flags
    """
    return self.__algo_flags
      
  def _set_algo_flags(self, v, load=False):
    """
    Setter method for algo_flags, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/algo_flags (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algo_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algo_flags() directly.

    YANG Description: Advertise flex-algo definition flags
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algo_flags must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)""",
        })

    self.__algo_flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algo_flags(self):
    self.__algo_flags = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)

  flex_algo_id = __builtin__.property(_get_flex_algo_id)
  flex_algo_name = __builtin__.property(_get_flex_algo_name)
  flex_algo_description = __builtin__.property(_get_flex_algo_description)
  metric_type = __builtin__.property(_get_metric_type)
  calc_type = __builtin__.property(_get_calc_type)
  priority = __builtin__.property(_get_priority)
  exclude = __builtin__.property(_get_exclude)
  include_all = __builtin__.property(_get_include_all)
  include_any = __builtin__.property(_get_include_any)
  srlg_exclude = __builtin__.property(_get_srlg_exclude)
  algo_flags = __builtin__.property(_get_algo_flags)


  _pyangbind_elements = OrderedDict([('flex_algo_id', flex_algo_id), ('flex_algo_name', flex_algo_name), ('flex_algo_description', flex_algo_description), ('metric_type', metric_type), ('calc_type', calc_type), ('priority', priority), ('exclude', exclude), ('include_all', include_all), ('include_any', include_any), ('srlg_exclude', srlg_exclude), ('algo_flags', algo_flags), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/flex-algorithm/flex-algorithm-definition/algorithm/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Attributes for a Flexible Algorithm
  """
  __slots__ = ('_path_helper', '_extmethods', '__flex_algo_id','__flex_algo_name','__flex_algo_description','__metric_type','__calc_type','__priority','__exclude','__include_all','__include_any','__srlg_exclude','__algo_flags',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flex_algo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)
    self.__flex_algo_name = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    self.__flex_algo_description = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)
    self.__calc_type = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)
    self.__exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__include_all = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__include_any = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__srlg_exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__algo_flags = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'flex-algorithm', 'flex-algorithm-definition', 'algorithm', 'state']

  def _get_flex_algo_id(self):
    """
    Getter method for flex_algo_id, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_id (flex-algo-id)

    YANG Description: Flex Algorithm Identifier
    """
    return self.__flex_algo_id
      
  def _set_flex_algo_id(self, v, load=False):
    """
    Setter method for flex_algo_id, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_id (flex-algo-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_id() directly.

    YANG Description: Flex Algorithm Identifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_id must be of a type compatible with flex-algo-id""",
          'defined-type': "openconfig-flexalgo:flex-algo-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)""",
        })

    self.__flex_algo_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_id(self):
    self.__flex_algo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)


  def _get_flex_algo_name(self):
    """
    Getter method for flex_algo_name, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_name (string)

    YANG Description: Flexible Algorithm name
    """
    return self.__flex_algo_name
      
  def _set_flex_algo_name(self, v, load=False):
    """
    Setter method for flex_algo_name, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_name() directly.

    YANG Description: Flexible Algorithm name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)""",
        })

    self.__flex_algo_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_name(self):
    self.__flex_algo_name = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)


  def _get_flex_algo_description(self):
    """
    Getter method for flex_algo_description, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_description (string)

    YANG Description: Description of this flex-algo
    """
    return self.__flex_algo_description
      
  def _set_flex_algo_description(self, v, load=False):
    """
    Setter method for flex_algo_description, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_description() directly.

    YANG Description: Description of this flex-algo
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)""",
        })

    self.__flex_algo_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_description(self):
    self.__flex_algo_description = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)


  def _get_metric_type(self):
    """
    Getter method for metric_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/metric_type (flex-algo-metric-type)

    YANG Description: Indicates which is the corresponding metric type for
this algorithm
    """
    return self.__metric_type
      
  def _set_metric_type(self, v, load=False):
    """
    Setter method for metric_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/metric_type (flex-algo-metric-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_type() directly.

    YANG Description: Indicates which is the corresponding metric type for
this algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_type must be of a type compatible with flex-algo-metric-type""",
          'defined-type': "openconfig-flexalgo:flex-algo-metric-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)""",
        })

    self.__metric_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_type(self):
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)


  def _get_calc_type(self):
    """
    Getter method for calc_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/calc_type (flex-algo-calc-type)

    YANG Description: Indicates the calculation type, if advertised
    """
    return self.__calc_type
      
  def _set_calc_type(self, v, load=False):
    """
    Setter method for calc_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/calc_type (flex-algo-calc-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_calc_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_calc_type() directly.

    YANG Description: Indicates the calculation type, if advertised
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """calc_type must be of a type compatible with flex-algo-calc-type""",
          'defined-type': "openconfig-flexalgo:flex-algo-calc-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)""",
        })

    self.__calc_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_calc_type(self):
    self.__calc_type = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/priority (uint8)

    YANG Description: Indicates the priority for this algorithm
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Indicates the priority for this algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)


  def _get_exclude(self):
    """
    Getter method for exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/exclude (leafref)

    YANG Description: extended-admin-groups to exclude in path calculation.
    """
    return self.__exclude
      
  def _set_exclude(self, v, load=False):
    """
    Setter method for exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/exclude (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exclude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exclude() directly.

    YANG Description: extended-admin-groups to exclude in path calculation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exclude must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__exclude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exclude(self):
    self.__exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_include_all(self):
    """
    Getter method for include_all, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_all (leafref)

    YANG Description: extended-admin-groups, all of which must be included
    """
    return self.__include_all
      
  def _set_include_all(self, v, load=False):
    """
    Setter method for include_all, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_all (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_all() directly.

    YANG Description: extended-admin-groups, all of which must be included
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_all must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__include_all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_all(self):
    self.__include_all = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_include_any(self):
    """
    Getter method for include_any, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_any (leafref)

    YANG Description: extended-admin-groups, one of which must be included
    """
    return self.__include_any
      
  def _set_include_any(self, v, load=False):
    """
    Setter method for include_any, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_any (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_any is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_any() directly.

    YANG Description: extended-admin-groups, one of which must be included
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_any must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__include_any = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_any(self):
    self.__include_any = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_srlg_exclude(self):
    """
    Getter method for srlg_exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/srlg_exclude (leafref)

    YANG Description: list of references to named SRLGs to be excluded
    """
    return self.__srlg_exclude
      
  def _set_srlg_exclude(self, v, load=False):
    """
    Setter method for srlg_exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/srlg_exclude (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srlg_exclude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srlg_exclude() directly.

    YANG Description: list of references to named SRLGs to be excluded
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srlg_exclude must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__srlg_exclude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srlg_exclude(self):
    self.__srlg_exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_algo_flags(self):
    """
    Getter method for algo_flags, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/algo_flags (boolean)

    YANG Description: Advertise flex-algo definition flags
    """
    return self.__algo_flags
      
  def _set_algo_flags(self, v, load=False):
    """
    Setter method for algo_flags, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/algo_flags (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algo_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algo_flags() directly.

    YANG Description: Advertise flex-algo definition flags
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algo_flags must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)""",
        })

    self.__algo_flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algo_flags(self):
    self.__algo_flags = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)

  flex_algo_id = __builtin__.property(_get_flex_algo_id)
  flex_algo_name = __builtin__.property(_get_flex_algo_name)
  flex_algo_description = __builtin__.property(_get_flex_algo_description)
  metric_type = __builtin__.property(_get_metric_type)
  calc_type = __builtin__.property(_get_calc_type)
  priority = __builtin__.property(_get_priority)
  exclude = __builtin__.property(_get_exclude)
  include_all = __builtin__.property(_get_include_all)
  include_any = __builtin__.property(_get_include_any)
  srlg_exclude = __builtin__.property(_get_srlg_exclude)
  algo_flags = __builtin__.property(_get_algo_flags)


  _pyangbind_elements = OrderedDict([('flex_algo_id', flex_algo_id), ('flex_algo_name', flex_algo_name), ('flex_algo_description', flex_algo_description), ('metric_type', metric_type), ('calc_type', calc_type), ('priority', priority), ('exclude', exclude), ('include_all', include_all), ('include_any', include_any), ('srlg_exclude', srlg_exclude), ('algo_flags', algo_flags), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/flex-algorithm/flex-algorithm-definition/algorithm/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Attributes for a Flexible Algorithm
  """
  __slots__ = ('_path_helper', '_extmethods', '__flex_algo_id','__flex_algo_name','__flex_algo_description','__metric_type','__calc_type','__priority','__exclude','__include_all','__include_any','__srlg_exclude','__algo_flags',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flex_algo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)
    self.__flex_algo_name = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    self.__flex_algo_description = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)
    self.__calc_type = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)
    self.__exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__include_all = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__include_any = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__srlg_exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    self.__algo_flags = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'flex-algorithm', 'flex-algorithm-definition', 'algorithm', 'state']

  def _get_flex_algo_id(self):
    """
    Getter method for flex_algo_id, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_id (flex-algo-id)

    YANG Description: Flex Algorithm Identifier
    """
    return self.__flex_algo_id
      
  def _set_flex_algo_id(self, v, load=False):
    """
    Setter method for flex_algo_id, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_id (flex-algo-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_id() directly.

    YANG Description: Flex Algorithm Identifier
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_id must be of a type compatible with flex-algo-id""",
          'defined-type': "openconfig-flexalgo:flex-algo-id",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)""",
        })

    self.__flex_algo_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_id(self):
    self.__flex_algo_id = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['128..255']}), is_leaf=True, yang_name="flex-algo-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-id', is_config=False)


  def _get_flex_algo_name(self):
    """
    Getter method for flex_algo_name, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_name (string)

    YANG Description: Flexible Algorithm name
    """
    return self.__flex_algo_name
      
  def _set_flex_algo_name(self, v, load=False):
    """
    Setter method for flex_algo_name, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_name() directly.

    YANG Description: Flexible Algorithm name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)""",
        })

    self.__flex_algo_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_name(self):
    self.__flex_algo_name = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)


  def _get_flex_algo_description(self):
    """
    Getter method for flex_algo_description, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_description (string)

    YANG Description: Description of this flex-algo
    """
    return self.__flex_algo_description
      
  def _set_flex_algo_description(self, v, load=False):
    """
    Setter method for flex_algo_description, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/flex_algo_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flex_algo_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flex_algo_description() directly.

    YANG Description: Description of this flex-algo
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flex_algo_description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)""",
        })

    self.__flex_algo_description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flex_algo_description(self):
    self.__flex_algo_description = YANGDynClass(base=str, is_leaf=True, yang_name="flex-algo-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='string', is_config=False)


  def _get_metric_type(self):
    """
    Getter method for metric_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/metric_type (flex-algo-metric-type)

    YANG Description: Indicates which is the corresponding metric type for
this algorithm
    """
    return self.__metric_type
      
  def _set_metric_type(self, v, load=False):
    """
    Setter method for metric_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/metric_type (flex-algo-metric-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_type() directly.

    YANG Description: Indicates which is the corresponding metric type for
this algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """metric_type must be of a type compatible with flex-algo-metric-type""",
          'defined-type': "openconfig-flexalgo:flex-algo-metric-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)""",
        })

    self.__metric_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_metric_type(self):
    self.__metric_type = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'IGP': {'value': 0}, 'MIN_DELAY': {'value': 1}, 'TE_METRIC': {'value': 2}},), default=str("IGP"), is_leaf=True, yang_name="metric-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-metric-type', is_config=False)


  def _get_calc_type(self):
    """
    Getter method for calc_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/calc_type (flex-algo-calc-type)

    YANG Description: Indicates the calculation type, if advertised
    """
    return self.__calc_type
      
  def _set_calc_type(self, v, load=False):
    """
    Setter method for calc_type, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/calc_type (flex-algo-calc-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_calc_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_calc_type() directly.

    YANG Description: Indicates the calculation type, if advertised
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """calc_type must be of a type compatible with flex-algo-calc-type""",
          'defined-type': "openconfig-flexalgo:flex-algo-calc-type",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)""",
        })

    self.__calc_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_calc_type(self):
    self.__calc_type = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['0..127']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(0), is_leaf=True, yang_name="calc-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='flex-algo-calc-type', is_config=False)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/priority (uint8)

    YANG Description: Indicates the priority for this algorithm
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Indicates the priority for this algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8)(237), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='uint8', is_config=False)


  def _get_exclude(self):
    """
    Getter method for exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/exclude (leafref)

    YANG Description: extended-admin-groups to exclude in path calculation.
    """
    return self.__exclude
      
  def _set_exclude(self, v, load=False):
    """
    Setter method for exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/exclude (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_exclude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_exclude() directly.

    YANG Description: extended-admin-groups to exclude in path calculation.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """exclude must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__exclude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_exclude(self):
    self.__exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_include_all(self):
    """
    Getter method for include_all, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_all (leafref)

    YANG Description: extended-admin-groups, all of which must be included
    """
    return self.__include_all
      
  def _set_include_all(self, v, load=False):
    """
    Setter method for include_all, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_all (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_all is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_all() directly.

    YANG Description: extended-admin-groups, all of which must be included
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_all must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__include_all = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_all(self):
    self.__include_all = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-all", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_include_any(self):
    """
    Getter method for include_any, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_any (leafref)

    YANG Description: extended-admin-groups, one of which must be included
    """
    return self.__include_any
      
  def _set_include_any(self, v, load=False):
    """
    Setter method for include_any, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/include_any (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_include_any is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_include_any() directly.

    YANG Description: extended-admin-groups, one of which must be included
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """include_any must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__include_any = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_include_any(self):
    self.__include_any = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="include-any", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_srlg_exclude(self):
    """
    Getter method for srlg_exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/srlg_exclude (leafref)

    YANG Description: list of references to named SRLGs to be excluded
    """
    return self.__srlg_exclude
      
  def _set_srlg_exclude(self, v, load=False):
    """
    Setter method for srlg_exclude, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/srlg_exclude (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_srlg_exclude is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_srlg_exclude() directly.

    YANG Description: list of references to named SRLGs to be excluded
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """srlg_exclude must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)""",
        })

    self.__srlg_exclude = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_srlg_exclude(self):
    self.__srlg_exclude = YANGDynClass(unique=True, base=TypedListType(allowed_type=str), is_leaf=False, yang_name="srlg-exclude", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='leafref', is_config=False)


  def _get_algo_flags(self):
    """
    Getter method for algo_flags, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/algo_flags (boolean)

    YANG Description: Advertise flex-algo definition flags
    """
    return self.__algo_flags
      
  def _set_algo_flags(self, v, load=False):
    """
    Setter method for algo_flags, mapped from YANG variable /network_instances/network_instance/flex_algorithm/flex_algorithm_definition/algorithm/state/algo_flags (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algo_flags is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algo_flags() directly.

    YANG Description: Advertise flex-algo definition flags
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """algo_flags must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)""",
        })

    self.__algo_flags = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_algo_flags(self):
    self.__algo_flags = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="algo-flags", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/flexalgo', defining_module='openconfig-flexalgo', yang_type='boolean', is_config=False)

  flex_algo_id = __builtin__.property(_get_flex_algo_id)
  flex_algo_name = __builtin__.property(_get_flex_algo_name)
  flex_algo_description = __builtin__.property(_get_flex_algo_description)
  metric_type = __builtin__.property(_get_metric_type)
  calc_type = __builtin__.property(_get_calc_type)
  priority = __builtin__.property(_get_priority)
  exclude = __builtin__.property(_get_exclude)
  include_all = __builtin__.property(_get_include_all)
  include_any = __builtin__.property(_get_include_any)
  srlg_exclude = __builtin__.property(_get_srlg_exclude)
  algo_flags = __builtin__.property(_get_algo_flags)


  _pyangbind_elements = OrderedDict([('flex_algo_id', flex_algo_id), ('flex_algo_name', flex_algo_name), ('flex_algo_description', flex_algo_description), ('metric_type', metric_type), ('calc_type', calc_type), ('priority', priority), ('exclude', exclude), ('include_all', include_all), ('include_any', include_any), ('srlg_exclude', srlg_exclude), ('algo_flags', algo_flags), ])


