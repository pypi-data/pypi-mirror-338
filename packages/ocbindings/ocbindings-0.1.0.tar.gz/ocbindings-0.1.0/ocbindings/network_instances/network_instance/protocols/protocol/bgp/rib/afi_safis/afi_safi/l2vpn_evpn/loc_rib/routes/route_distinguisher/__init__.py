# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
from . import state
from . import type_one_ethernet_auto_discovery
from . import type_two_mac_ip_advertisement
from . import type_three_inclusive_multicast_ethernet_tag
from . import type_four_ethernet_segment
from . import type_five_ip_prefix
class route_distinguisher(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/bgp/rib/afi-safis/afi-safi/l2vpn-evpn/loc-rib/routes/route-distinguisher. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of route distinguishers
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_distinguisher','__state','__type_one_ethernet_auto_discovery','__type_two_mac_ip_advertisement','__type_three_inclusive_multicast_ethernet_tag','__type_four_ethernet_segment','__type_five_ip_prefix',)

  _yang_name = 'route-distinguisher'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_distinguisher = YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_one_ethernet_auto_discovery = YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_two_mac_ip_advertisement = YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_three_inclusive_multicast_ethernet_tag = YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_four_ethernet_segment = YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_five_ip_prefix = YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'l2vpn-evpn', 'loc-rib', 'routes', 'route-distinguisher']

  def _get_route_distinguisher(self):
    """
    Getter method for route_distinguisher, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/route_distinguisher (leafref)

    YANG Description: An EVPN instance requires a Route Distinguisher (RD) that is
unique per MAC-VRF
    """
    return self.__route_distinguisher
      
  def _set_route_distinguisher(self, v, load=False):
    """
    Setter method for route_distinguisher, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/route_distinguisher (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher() directly.

    YANG Description: An EVPN instance requires a Route Distinguisher (RD) that is
unique per MAC-VRF
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher(self):
    self.__route_distinguisher = YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/state (container)

    YANG Description: Top level container for L2VPN EVPN RDs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level container for L2VPN EVPN RDs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_one_ethernet_auto_discovery(self):
    """
    Getter method for type_one_ethernet_auto_discovery, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_one_ethernet_auto_discovery (container)

    YANG Description: Top level container BGP EVPN Ethernet Auto-discovery routes
    """
    return self.__type_one_ethernet_auto_discovery
      
  def _set_type_one_ethernet_auto_discovery(self, v, load=False):
    """
    Setter method for type_one_ethernet_auto_discovery, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_one_ethernet_auto_discovery (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_one_ethernet_auto_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_one_ethernet_auto_discovery() directly.

    YANG Description: Top level container BGP EVPN Ethernet Auto-discovery routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_one_ethernet_auto_discovery must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_one_ethernet_auto_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_one_ethernet_auto_discovery(self):
    self.__type_one_ethernet_auto_discovery = YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_two_mac_ip_advertisement(self):
    """
    Getter method for type_two_mac_ip_advertisement, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_two_mac_ip_advertisement (container)

    YANG Description: Top level container for MAC_IP Advertisement L2VPN EVPN routes
    """
    return self.__type_two_mac_ip_advertisement
      
  def _set_type_two_mac_ip_advertisement(self, v, load=False):
    """
    Setter method for type_two_mac_ip_advertisement, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_two_mac_ip_advertisement (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_two_mac_ip_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_two_mac_ip_advertisement() directly.

    YANG Description: Top level container for MAC_IP Advertisement L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_two_mac_ip_advertisement must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_two_mac_ip_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_two_mac_ip_advertisement(self):
    self.__type_two_mac_ip_advertisement = YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_three_inclusive_multicast_ethernet_tag(self):
    """
    Getter method for type_three_inclusive_multicast_ethernet_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_three_inclusive_multicast_ethernet_tag (container)

    YANG Description: Top level container for Inclusive Multicast Ethernet Tag L2VPN EVPN
routes
    """
    return self.__type_three_inclusive_multicast_ethernet_tag
      
  def _set_type_three_inclusive_multicast_ethernet_tag(self, v, load=False):
    """
    Setter method for type_three_inclusive_multicast_ethernet_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_three_inclusive_multicast_ethernet_tag (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_three_inclusive_multicast_ethernet_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_three_inclusive_multicast_ethernet_tag() directly.

    YANG Description: Top level container for Inclusive Multicast Ethernet Tag L2VPN EVPN
routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_three_inclusive_multicast_ethernet_tag must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_three_inclusive_multicast_ethernet_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_three_inclusive_multicast_ethernet_tag(self):
    self.__type_three_inclusive_multicast_ethernet_tag = YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_four_ethernet_segment(self):
    """
    Getter method for type_four_ethernet_segment, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_four_ethernet_segment (container)

    YANG Description: Top level container for Ethernet Segment L2VPN EVPN routes
    """
    return self.__type_four_ethernet_segment
      
  def _set_type_four_ethernet_segment(self, v, load=False):
    """
    Setter method for type_four_ethernet_segment, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_four_ethernet_segment (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_four_ethernet_segment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_four_ethernet_segment() directly.

    YANG Description: Top level container for Ethernet Segment L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_four_ethernet_segment must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_four_ethernet_segment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_four_ethernet_segment(self):
    self.__type_four_ethernet_segment = YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_five_ip_prefix(self):
    """
    Getter method for type_five_ip_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_five_ip_prefix (container)

    YANG Description: Top level container for IP Prefix Advertisement L2VPN EVPN routes
    """
    return self.__type_five_ip_prefix
      
  def _set_type_five_ip_prefix(self, v, load=False):
    """
    Setter method for type_five_ip_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_five_ip_prefix (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_five_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_five_ip_prefix() directly.

    YANG Description: Top level container for IP Prefix Advertisement L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_five_ip_prefix must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_five_ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_five_ip_prefix(self):
    self.__type_five_ip_prefix = YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  route_distinguisher = __builtin__.property(_get_route_distinguisher)
  state = __builtin__.property(_get_state)
  type_one_ethernet_auto_discovery = __builtin__.property(_get_type_one_ethernet_auto_discovery)
  type_two_mac_ip_advertisement = __builtin__.property(_get_type_two_mac_ip_advertisement)
  type_three_inclusive_multicast_ethernet_tag = __builtin__.property(_get_type_three_inclusive_multicast_ethernet_tag)
  type_four_ethernet_segment = __builtin__.property(_get_type_four_ethernet_segment)
  type_five_ip_prefix = __builtin__.property(_get_type_five_ip_prefix)


  _pyangbind_elements = OrderedDict([('route_distinguisher', route_distinguisher), ('state', state), ('type_one_ethernet_auto_discovery', type_one_ethernet_auto_discovery), ('type_two_mac_ip_advertisement', type_two_mac_ip_advertisement), ('type_three_inclusive_multicast_ethernet_tag', type_three_inclusive_multicast_ethernet_tag), ('type_four_ethernet_segment', type_four_ethernet_segment), ('type_five_ip_prefix', type_five_ip_prefix), ])


from . import state
from . import type_one_ethernet_auto_discovery
from . import type_two_mac_ip_advertisement
from . import type_three_inclusive_multicast_ethernet_tag
from . import type_four_ethernet_segment
from . import type_five_ip_prefix
class route_distinguisher(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/bgp/rib/afi-safis/afi-safi/l2vpn-evpn/loc-rib/routes/route-distinguisher. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of route distinguishers
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_distinguisher','__state','__type_one_ethernet_auto_discovery','__type_two_mac_ip_advertisement','__type_three_inclusive_multicast_ethernet_tag','__type_four_ethernet_segment','__type_five_ip_prefix',)

  _yang_name = 'route-distinguisher'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_distinguisher = YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_one_ethernet_auto_discovery = YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_two_mac_ip_advertisement = YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_three_inclusive_multicast_ethernet_tag = YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_four_ethernet_segment = YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_five_ip_prefix = YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'l2vpn-evpn', 'loc-rib', 'routes', 'route-distinguisher']

  def _get_route_distinguisher(self):
    """
    Getter method for route_distinguisher, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/route_distinguisher (leafref)

    YANG Description: An EVPN instance requires a Route Distinguisher (RD) that is
unique per MAC-VRF
    """
    return self.__route_distinguisher
      
  def _set_route_distinguisher(self, v, load=False):
    """
    Setter method for route_distinguisher, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/route_distinguisher (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher() directly.

    YANG Description: An EVPN instance requires a Route Distinguisher (RD) that is
unique per MAC-VRF
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher(self):
    self.__route_distinguisher = YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/state (container)

    YANG Description: Top level container for L2VPN EVPN RDs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level container for L2VPN EVPN RDs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_one_ethernet_auto_discovery(self):
    """
    Getter method for type_one_ethernet_auto_discovery, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_one_ethernet_auto_discovery (container)

    YANG Description: Top level container BGP EVPN Ethernet Auto-discovery routes
    """
    return self.__type_one_ethernet_auto_discovery
      
  def _set_type_one_ethernet_auto_discovery(self, v, load=False):
    """
    Setter method for type_one_ethernet_auto_discovery, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_one_ethernet_auto_discovery (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_one_ethernet_auto_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_one_ethernet_auto_discovery() directly.

    YANG Description: Top level container BGP EVPN Ethernet Auto-discovery routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_one_ethernet_auto_discovery must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_one_ethernet_auto_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_one_ethernet_auto_discovery(self):
    self.__type_one_ethernet_auto_discovery = YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_two_mac_ip_advertisement(self):
    """
    Getter method for type_two_mac_ip_advertisement, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_two_mac_ip_advertisement (container)

    YANG Description: Top level container for MAC_IP Advertisement L2VPN EVPN routes
    """
    return self.__type_two_mac_ip_advertisement
      
  def _set_type_two_mac_ip_advertisement(self, v, load=False):
    """
    Setter method for type_two_mac_ip_advertisement, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_two_mac_ip_advertisement (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_two_mac_ip_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_two_mac_ip_advertisement() directly.

    YANG Description: Top level container for MAC_IP Advertisement L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_two_mac_ip_advertisement must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_two_mac_ip_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_two_mac_ip_advertisement(self):
    self.__type_two_mac_ip_advertisement = YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_three_inclusive_multicast_ethernet_tag(self):
    """
    Getter method for type_three_inclusive_multicast_ethernet_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_three_inclusive_multicast_ethernet_tag (container)

    YANG Description: Top level container for Inclusive Multicast Ethernet Tag L2VPN EVPN
routes
    """
    return self.__type_three_inclusive_multicast_ethernet_tag
      
  def _set_type_three_inclusive_multicast_ethernet_tag(self, v, load=False):
    """
    Setter method for type_three_inclusive_multicast_ethernet_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_three_inclusive_multicast_ethernet_tag (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_three_inclusive_multicast_ethernet_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_three_inclusive_multicast_ethernet_tag() directly.

    YANG Description: Top level container for Inclusive Multicast Ethernet Tag L2VPN EVPN
routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_three_inclusive_multicast_ethernet_tag must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_three_inclusive_multicast_ethernet_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_three_inclusive_multicast_ethernet_tag(self):
    self.__type_three_inclusive_multicast_ethernet_tag = YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_four_ethernet_segment(self):
    """
    Getter method for type_four_ethernet_segment, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_four_ethernet_segment (container)

    YANG Description: Top level container for Ethernet Segment L2VPN EVPN routes
    """
    return self.__type_four_ethernet_segment
      
  def _set_type_four_ethernet_segment(self, v, load=False):
    """
    Setter method for type_four_ethernet_segment, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_four_ethernet_segment (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_four_ethernet_segment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_four_ethernet_segment() directly.

    YANG Description: Top level container for Ethernet Segment L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_four_ethernet_segment must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_four_ethernet_segment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_four_ethernet_segment(self):
    self.__type_four_ethernet_segment = YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_five_ip_prefix(self):
    """
    Getter method for type_five_ip_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_five_ip_prefix (container)

    YANG Description: Top level container for IP Prefix Advertisement L2VPN EVPN routes
    """
    return self.__type_five_ip_prefix
      
  def _set_type_five_ip_prefix(self, v, load=False):
    """
    Setter method for type_five_ip_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_five_ip_prefix (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_five_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_five_ip_prefix() directly.

    YANG Description: Top level container for IP Prefix Advertisement L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_five_ip_prefix must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_five_ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_five_ip_prefix(self):
    self.__type_five_ip_prefix = YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  route_distinguisher = __builtin__.property(_get_route_distinguisher)
  state = __builtin__.property(_get_state)
  type_one_ethernet_auto_discovery = __builtin__.property(_get_type_one_ethernet_auto_discovery)
  type_two_mac_ip_advertisement = __builtin__.property(_get_type_two_mac_ip_advertisement)
  type_three_inclusive_multicast_ethernet_tag = __builtin__.property(_get_type_three_inclusive_multicast_ethernet_tag)
  type_four_ethernet_segment = __builtin__.property(_get_type_four_ethernet_segment)
  type_five_ip_prefix = __builtin__.property(_get_type_five_ip_prefix)


  _pyangbind_elements = OrderedDict([('route_distinguisher', route_distinguisher), ('state', state), ('type_one_ethernet_auto_discovery', type_one_ethernet_auto_discovery), ('type_two_mac_ip_advertisement', type_two_mac_ip_advertisement), ('type_three_inclusive_multicast_ethernet_tag', type_three_inclusive_multicast_ethernet_tag), ('type_four_ethernet_segment', type_four_ethernet_segment), ('type_five_ip_prefix', type_five_ip_prefix), ])


from . import state
from . import type_one_ethernet_auto_discovery
from . import type_two_mac_ip_advertisement
from . import type_three_inclusive_multicast_ethernet_tag
from . import type_four_ethernet_segment
from . import type_five_ip_prefix
class route_distinguisher(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/bgp/rib/afi-safis/afi-safi/l2vpn-evpn/loc-rib/routes/route-distinguisher. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of route distinguishers
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_distinguisher','__state','__type_one_ethernet_auto_discovery','__type_two_mac_ip_advertisement','__type_three_inclusive_multicast_ethernet_tag','__type_four_ethernet_segment','__type_five_ip_prefix',)

  _yang_name = 'route-distinguisher'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_distinguisher = YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_one_ethernet_auto_discovery = YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_two_mac_ip_advertisement = YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_three_inclusive_multicast_ethernet_tag = YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_four_ethernet_segment = YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_five_ip_prefix = YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'l2vpn-evpn', 'loc-rib', 'routes', 'route-distinguisher']

  def _get_route_distinguisher(self):
    """
    Getter method for route_distinguisher, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/route_distinguisher (leafref)

    YANG Description: An EVPN instance requires a Route Distinguisher (RD) that is
unique per MAC-VRF
    """
    return self.__route_distinguisher
      
  def _set_route_distinguisher(self, v, load=False):
    """
    Setter method for route_distinguisher, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/route_distinguisher (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher() directly.

    YANG Description: An EVPN instance requires a Route Distinguisher (RD) that is
unique per MAC-VRF
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher(self):
    self.__route_distinguisher = YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/state (container)

    YANG Description: Top level container for L2VPN EVPN RDs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level container for L2VPN EVPN RDs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_one_ethernet_auto_discovery(self):
    """
    Getter method for type_one_ethernet_auto_discovery, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_one_ethernet_auto_discovery (container)

    YANG Description: Top level container BGP EVPN Ethernet Auto-discovery routes
    """
    return self.__type_one_ethernet_auto_discovery
      
  def _set_type_one_ethernet_auto_discovery(self, v, load=False):
    """
    Setter method for type_one_ethernet_auto_discovery, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_one_ethernet_auto_discovery (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_one_ethernet_auto_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_one_ethernet_auto_discovery() directly.

    YANG Description: Top level container BGP EVPN Ethernet Auto-discovery routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_one_ethernet_auto_discovery must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_one_ethernet_auto_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_one_ethernet_auto_discovery(self):
    self.__type_one_ethernet_auto_discovery = YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_two_mac_ip_advertisement(self):
    """
    Getter method for type_two_mac_ip_advertisement, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_two_mac_ip_advertisement (container)

    YANG Description: Top level container for MAC_IP Advertisement L2VPN EVPN routes
    """
    return self.__type_two_mac_ip_advertisement
      
  def _set_type_two_mac_ip_advertisement(self, v, load=False):
    """
    Setter method for type_two_mac_ip_advertisement, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_two_mac_ip_advertisement (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_two_mac_ip_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_two_mac_ip_advertisement() directly.

    YANG Description: Top level container for MAC_IP Advertisement L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_two_mac_ip_advertisement must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_two_mac_ip_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_two_mac_ip_advertisement(self):
    self.__type_two_mac_ip_advertisement = YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_three_inclusive_multicast_ethernet_tag(self):
    """
    Getter method for type_three_inclusive_multicast_ethernet_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_three_inclusive_multicast_ethernet_tag (container)

    YANG Description: Top level container for Inclusive Multicast Ethernet Tag L2VPN EVPN
routes
    """
    return self.__type_three_inclusive_multicast_ethernet_tag
      
  def _set_type_three_inclusive_multicast_ethernet_tag(self, v, load=False):
    """
    Setter method for type_three_inclusive_multicast_ethernet_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_three_inclusive_multicast_ethernet_tag (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_three_inclusive_multicast_ethernet_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_three_inclusive_multicast_ethernet_tag() directly.

    YANG Description: Top level container for Inclusive Multicast Ethernet Tag L2VPN EVPN
routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_three_inclusive_multicast_ethernet_tag must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_three_inclusive_multicast_ethernet_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_three_inclusive_multicast_ethernet_tag(self):
    self.__type_three_inclusive_multicast_ethernet_tag = YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_four_ethernet_segment(self):
    """
    Getter method for type_four_ethernet_segment, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_four_ethernet_segment (container)

    YANG Description: Top level container for Ethernet Segment L2VPN EVPN routes
    """
    return self.__type_four_ethernet_segment
      
  def _set_type_four_ethernet_segment(self, v, load=False):
    """
    Setter method for type_four_ethernet_segment, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_four_ethernet_segment (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_four_ethernet_segment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_four_ethernet_segment() directly.

    YANG Description: Top level container for Ethernet Segment L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_four_ethernet_segment must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_four_ethernet_segment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_four_ethernet_segment(self):
    self.__type_four_ethernet_segment = YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_five_ip_prefix(self):
    """
    Getter method for type_five_ip_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_five_ip_prefix (container)

    YANG Description: Top level container for IP Prefix Advertisement L2VPN EVPN routes
    """
    return self.__type_five_ip_prefix
      
  def _set_type_five_ip_prefix(self, v, load=False):
    """
    Setter method for type_five_ip_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_five_ip_prefix (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_five_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_five_ip_prefix() directly.

    YANG Description: Top level container for IP Prefix Advertisement L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_five_ip_prefix must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_five_ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_five_ip_prefix(self):
    self.__type_five_ip_prefix = YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  route_distinguisher = __builtin__.property(_get_route_distinguisher)
  state = __builtin__.property(_get_state)
  type_one_ethernet_auto_discovery = __builtin__.property(_get_type_one_ethernet_auto_discovery)
  type_two_mac_ip_advertisement = __builtin__.property(_get_type_two_mac_ip_advertisement)
  type_three_inclusive_multicast_ethernet_tag = __builtin__.property(_get_type_three_inclusive_multicast_ethernet_tag)
  type_four_ethernet_segment = __builtin__.property(_get_type_four_ethernet_segment)
  type_five_ip_prefix = __builtin__.property(_get_type_five_ip_prefix)


  _pyangbind_elements = OrderedDict([('route_distinguisher', route_distinguisher), ('state', state), ('type_one_ethernet_auto_discovery', type_one_ethernet_auto_discovery), ('type_two_mac_ip_advertisement', type_two_mac_ip_advertisement), ('type_three_inclusive_multicast_ethernet_tag', type_three_inclusive_multicast_ethernet_tag), ('type_four_ethernet_segment', type_four_ethernet_segment), ('type_five_ip_prefix', type_five_ip_prefix), ])


from . import state
from . import type_one_ethernet_auto_discovery
from . import type_two_mac_ip_advertisement
from . import type_three_inclusive_multicast_ethernet_tag
from . import type_four_ethernet_segment
from . import type_five_ip_prefix
class route_distinguisher(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/bgp/rib/afi-safis/afi-safi/l2vpn-evpn/loc-rib/routes/route-distinguisher. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of route distinguishers
  """
  __slots__ = ('_path_helper', '_extmethods', '__route_distinguisher','__state','__type_one_ethernet_auto_discovery','__type_two_mac_ip_advertisement','__type_three_inclusive_multicast_ethernet_tag','__type_four_ethernet_segment','__type_five_ip_prefix',)

  _yang_name = 'route-distinguisher'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__route_distinguisher = YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_one_ethernet_auto_discovery = YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_two_mac_ip_advertisement = YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_three_inclusive_multicast_ethernet_tag = YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_four_ethernet_segment = YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    self.__type_five_ip_prefix = YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'bgp', 'rib', 'afi-safis', 'afi-safi', 'l2vpn-evpn', 'loc-rib', 'routes', 'route-distinguisher']

  def _get_route_distinguisher(self):
    """
    Getter method for route_distinguisher, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/route_distinguisher (leafref)

    YANG Description: An EVPN instance requires a Route Distinguisher (RD) that is
unique per MAC-VRF
    """
    return self.__route_distinguisher
      
  def _set_route_distinguisher(self, v, load=False):
    """
    Setter method for route_distinguisher, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/route_distinguisher (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_route_distinguisher is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_route_distinguisher() directly.

    YANG Description: An EVPN instance requires a Route Distinguisher (RD) that is
unique per MAC-VRF
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """route_distinguisher must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)""",
        })

    self.__route_distinguisher = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_route_distinguisher(self):
    self.__route_distinguisher = YANGDynClass(base=str, is_leaf=True, yang_name="route-distinguisher", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=False)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/state (container)

    YANG Description: Top level container for L2VPN EVPN RDs
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Top level container for L2VPN EVPN RDs
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=state.state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_one_ethernet_auto_discovery(self):
    """
    Getter method for type_one_ethernet_auto_discovery, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_one_ethernet_auto_discovery (container)

    YANG Description: Top level container BGP EVPN Ethernet Auto-discovery routes
    """
    return self.__type_one_ethernet_auto_discovery
      
  def _set_type_one_ethernet_auto_discovery(self, v, load=False):
    """
    Setter method for type_one_ethernet_auto_discovery, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_one_ethernet_auto_discovery (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_one_ethernet_auto_discovery is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_one_ethernet_auto_discovery() directly.

    YANG Description: Top level container BGP EVPN Ethernet Auto-discovery routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_one_ethernet_auto_discovery must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_one_ethernet_auto_discovery = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_one_ethernet_auto_discovery(self):
    self.__type_one_ethernet_auto_discovery = YANGDynClass(base=type_one_ethernet_auto_discovery.type_one_ethernet_auto_discovery, is_container='container', yang_name="type-one-ethernet-auto-discovery", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_two_mac_ip_advertisement(self):
    """
    Getter method for type_two_mac_ip_advertisement, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_two_mac_ip_advertisement (container)

    YANG Description: Top level container for MAC_IP Advertisement L2VPN EVPN routes
    """
    return self.__type_two_mac_ip_advertisement
      
  def _set_type_two_mac_ip_advertisement(self, v, load=False):
    """
    Setter method for type_two_mac_ip_advertisement, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_two_mac_ip_advertisement (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_two_mac_ip_advertisement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_two_mac_ip_advertisement() directly.

    YANG Description: Top level container for MAC_IP Advertisement L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_two_mac_ip_advertisement must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_two_mac_ip_advertisement = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_two_mac_ip_advertisement(self):
    self.__type_two_mac_ip_advertisement = YANGDynClass(base=type_two_mac_ip_advertisement.type_two_mac_ip_advertisement, is_container='container', yang_name="type-two-mac-ip-advertisement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_three_inclusive_multicast_ethernet_tag(self):
    """
    Getter method for type_three_inclusive_multicast_ethernet_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_three_inclusive_multicast_ethernet_tag (container)

    YANG Description: Top level container for Inclusive Multicast Ethernet Tag L2VPN EVPN
routes
    """
    return self.__type_three_inclusive_multicast_ethernet_tag
      
  def _set_type_three_inclusive_multicast_ethernet_tag(self, v, load=False):
    """
    Setter method for type_three_inclusive_multicast_ethernet_tag, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_three_inclusive_multicast_ethernet_tag (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_three_inclusive_multicast_ethernet_tag is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_three_inclusive_multicast_ethernet_tag() directly.

    YANG Description: Top level container for Inclusive Multicast Ethernet Tag L2VPN EVPN
routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_three_inclusive_multicast_ethernet_tag must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_three_inclusive_multicast_ethernet_tag = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_three_inclusive_multicast_ethernet_tag(self):
    self.__type_three_inclusive_multicast_ethernet_tag = YANGDynClass(base=type_three_inclusive_multicast_ethernet_tag.type_three_inclusive_multicast_ethernet_tag, is_container='container', yang_name="type-three-inclusive-multicast-ethernet-tag", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_four_ethernet_segment(self):
    """
    Getter method for type_four_ethernet_segment, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_four_ethernet_segment (container)

    YANG Description: Top level container for Ethernet Segment L2VPN EVPN routes
    """
    return self.__type_four_ethernet_segment
      
  def _set_type_four_ethernet_segment(self, v, load=False):
    """
    Setter method for type_four_ethernet_segment, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_four_ethernet_segment (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_four_ethernet_segment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_four_ethernet_segment() directly.

    YANG Description: Top level container for Ethernet Segment L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_four_ethernet_segment must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_four_ethernet_segment = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_four_ethernet_segment(self):
    self.__type_four_ethernet_segment = YANGDynClass(base=type_four_ethernet_segment.type_four_ethernet_segment, is_container='container', yang_name="type-four-ethernet-segment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)


  def _get_type_five_ip_prefix(self):
    """
    Getter method for type_five_ip_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_five_ip_prefix (container)

    YANG Description: Top level container for IP Prefix Advertisement L2VPN EVPN routes
    """
    return self.__type_five_ip_prefix
      
  def _set_type_five_ip_prefix(self, v, load=False):
    """
    Setter method for type_five_ip_prefix, mapped from YANG variable /network_instances/network_instance/protocols/protocol/bgp/rib/afi_safis/afi_safi/l2vpn_evpn/loc_rib/routes/route_distinguisher/type_five_ip_prefix (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_five_ip_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_five_ip_prefix() directly.

    YANG Description: Top level container for IP Prefix Advertisement L2VPN EVPN routes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type_five_ip_prefix must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)""",
        })

    self.__type_five_ip_prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type_five_ip_prefix(self):
    self.__type_five_ip_prefix = YANGDynClass(base=type_five_ip_prefix.type_five_ip_prefix, is_container='container', yang_name="type-five-ip-prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=False)

  route_distinguisher = __builtin__.property(_get_route_distinguisher)
  state = __builtin__.property(_get_state)
  type_one_ethernet_auto_discovery = __builtin__.property(_get_type_one_ethernet_auto_discovery)
  type_two_mac_ip_advertisement = __builtin__.property(_get_type_two_mac_ip_advertisement)
  type_three_inclusive_multicast_ethernet_tag = __builtin__.property(_get_type_three_inclusive_multicast_ethernet_tag)
  type_four_ethernet_segment = __builtin__.property(_get_type_four_ethernet_segment)
  type_five_ip_prefix = __builtin__.property(_get_type_five_ip_prefix)


  _pyangbind_elements = OrderedDict([('route_distinguisher', route_distinguisher), ('state', state), ('type_one_ethernet_auto_discovery', type_one_ethernet_auto_discovery), ('type_two_mac_ip_advertisement', type_two_mac_ip_advertisement), ('type_three_inclusive_multicast_ethernet_tag', type_three_inclusive_multicast_ethernet_tag), ('type_four_ethernet_segment', type_four_ethernet_segment), ('type_five_ip_prefix', type_five_ip_prefix), ])


