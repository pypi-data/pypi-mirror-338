# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable-bfd/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to enabing BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__desired_minimum_tx_interval','__required_minimum_receive','__detection_multiplier',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'ospfv3', 'areas', 'area', 'interfaces', 'interface', 'enable-bfd', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/enabled (boolean)

    YANG Description: When this leaf is set to true, BFD is used to detect the
liveliness of the remote peer or next-hop.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When this leaf is set to true, BFD is used to detect the
liveliness of the remote peer or next-hop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_desired_minimum_tx_interval(self):
    """
    Getter method for desired_minimum_tx_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/desired_minimum_tx_interval (uint32)

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    return self.__desired_minimum_tx_interval
      
  def _set_desired_minimum_tx_interval(self, v, load=False):
    """
    Setter method for desired_minimum_tx_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/desired_minimum_tx_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_desired_minimum_tx_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_desired_minimum_tx_interval() directly.

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """desired_minimum_tx_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__desired_minimum_tx_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_desired_minimum_tx_interval(self):
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_required_minimum_receive(self):
    """
    Getter method for required_minimum_receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/required_minimum_receive (uint32)

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    return self.__required_minimum_receive
      
  def _set_required_minimum_receive(self, v, load=False):
    """
    Setter method for required_minimum_receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/required_minimum_receive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required_minimum_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required_minimum_receive() directly.

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required_minimum_receive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__required_minimum_receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required_minimum_receive(self):
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_detection_multiplier(self):
    """
    Getter method for detection_multiplier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/detection_multiplier (uint8)

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    return self.__detection_multiplier
      
  def _set_detection_multiplier(self, v, load=False):
    """
    Setter method for detection_multiplier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/detection_multiplier (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detection_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detection_multiplier() directly.

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detection_multiplier must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)""",
        })

    self.__detection_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detection_multiplier(self):
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  desired_minimum_tx_interval = __builtin__.property(_get_desired_minimum_tx_interval)
  required_minimum_receive = __builtin__.property(_get_required_minimum_receive)
  detection_multiplier = __builtin__.property(_get_detection_multiplier)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('desired_minimum_tx_interval', desired_minimum_tx_interval), ('required_minimum_receive', required_minimum_receive), ('detection_multiplier', detection_multiplier), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable-bfd/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to enabing BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__desired_minimum_tx_interval','__required_minimum_receive','__detection_multiplier',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'ospfv3', 'areas', 'area', 'interfaces', 'interface', 'enable-bfd', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/enabled (boolean)

    YANG Description: When this leaf is set to true, BFD is used to detect the
liveliness of the remote peer or next-hop.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When this leaf is set to true, BFD is used to detect the
liveliness of the remote peer or next-hop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_desired_minimum_tx_interval(self):
    """
    Getter method for desired_minimum_tx_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/desired_minimum_tx_interval (uint32)

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    return self.__desired_minimum_tx_interval
      
  def _set_desired_minimum_tx_interval(self, v, load=False):
    """
    Setter method for desired_minimum_tx_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/desired_minimum_tx_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_desired_minimum_tx_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_desired_minimum_tx_interval() directly.

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """desired_minimum_tx_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__desired_minimum_tx_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_desired_minimum_tx_interval(self):
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_required_minimum_receive(self):
    """
    Getter method for required_minimum_receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/required_minimum_receive (uint32)

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    return self.__required_minimum_receive
      
  def _set_required_minimum_receive(self, v, load=False):
    """
    Setter method for required_minimum_receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/required_minimum_receive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required_minimum_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required_minimum_receive() directly.

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required_minimum_receive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__required_minimum_receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required_minimum_receive(self):
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_detection_multiplier(self):
    """
    Getter method for detection_multiplier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/detection_multiplier (uint8)

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    return self.__detection_multiplier
      
  def _set_detection_multiplier(self, v, load=False):
    """
    Setter method for detection_multiplier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/detection_multiplier (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detection_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detection_multiplier() directly.

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detection_multiplier must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)""",
        })

    self.__detection_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detection_multiplier(self):
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  desired_minimum_tx_interval = __builtin__.property(_get_desired_minimum_tx_interval)
  required_minimum_receive = __builtin__.property(_get_required_minimum_receive)
  detection_multiplier = __builtin__.property(_get_detection_multiplier)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('desired_minimum_tx_interval', desired_minimum_tx_interval), ('required_minimum_receive', required_minimum_receive), ('detection_multiplier', detection_multiplier), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable-bfd/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to enabing BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__desired_minimum_tx_interval','__required_minimum_receive','__detection_multiplier',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'ospfv3', 'areas', 'area', 'interfaces', 'interface', 'enable-bfd', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/enabled (boolean)

    YANG Description: When this leaf is set to true, BFD is used to detect the
liveliness of the remote peer or next-hop.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When this leaf is set to true, BFD is used to detect the
liveliness of the remote peer or next-hop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_desired_minimum_tx_interval(self):
    """
    Getter method for desired_minimum_tx_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/desired_minimum_tx_interval (uint32)

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    return self.__desired_minimum_tx_interval
      
  def _set_desired_minimum_tx_interval(self, v, load=False):
    """
    Setter method for desired_minimum_tx_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/desired_minimum_tx_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_desired_minimum_tx_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_desired_minimum_tx_interval() directly.

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """desired_minimum_tx_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__desired_minimum_tx_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_desired_minimum_tx_interval(self):
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_required_minimum_receive(self):
    """
    Getter method for required_minimum_receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/required_minimum_receive (uint32)

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    return self.__required_minimum_receive
      
  def _set_required_minimum_receive(self, v, load=False):
    """
    Setter method for required_minimum_receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/required_minimum_receive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required_minimum_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required_minimum_receive() directly.

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required_minimum_receive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__required_minimum_receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required_minimum_receive(self):
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_detection_multiplier(self):
    """
    Getter method for detection_multiplier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/detection_multiplier (uint8)

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    return self.__detection_multiplier
      
  def _set_detection_multiplier(self, v, load=False):
    """
    Setter method for detection_multiplier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/detection_multiplier (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detection_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detection_multiplier() directly.

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detection_multiplier must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)""",
        })

    self.__detection_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detection_multiplier(self):
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  desired_minimum_tx_interval = __builtin__.property(_get_desired_minimum_tx_interval)
  required_minimum_receive = __builtin__.property(_get_required_minimum_receive)
  detection_multiplier = __builtin__.property(_get_detection_multiplier)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('desired_minimum_tx_interval', desired_minimum_tx_interval), ('required_minimum_receive', required_minimum_receive), ('detection_multiplier', detection_multiplier), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable-bfd/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to enabing BFD.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enabled','__desired_minimum_tx_interval','__required_minimum_receive','__detection_multiplier',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'ospfv3', 'areas', 'area', 'interfaces', 'interface', 'enable-bfd', 'state']

  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/enabled (boolean)

    YANG Description: When this leaf is set to true, BFD is used to detect the
liveliness of the remote peer or next-hop.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When this leaf is set to true, BFD is used to detect the
liveliness of the remote peer or next-hop.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=False)


  def _get_desired_minimum_tx_interval(self):
    """
    Getter method for desired_minimum_tx_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/desired_minimum_tx_interval (uint32)

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    return self.__desired_minimum_tx_interval
      
  def _set_desired_minimum_tx_interval(self, v, load=False):
    """
    Setter method for desired_minimum_tx_interval, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/desired_minimum_tx_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_desired_minimum_tx_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_desired_minimum_tx_interval() directly.

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """desired_minimum_tx_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__desired_minimum_tx_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_desired_minimum_tx_interval(self):
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_required_minimum_receive(self):
    """
    Getter method for required_minimum_receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/required_minimum_receive (uint32)

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    return self.__required_minimum_receive
      
  def _set_required_minimum_receive(self, v, load=False):
    """
    Setter method for required_minimum_receive, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/required_minimum_receive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required_minimum_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required_minimum_receive() directly.

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required_minimum_receive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)""",
        })

    self.__required_minimum_receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required_minimum_receive(self):
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint32', is_config=False)


  def _get_detection_multiplier(self):
    """
    Getter method for detection_multiplier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/detection_multiplier (uint8)

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    return self.__detection_multiplier
      
  def _set_detection_multiplier(self, v, load=False):
    """
    Setter method for detection_multiplier, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/areas/area/interfaces/interface/enable_bfd/state/detection_multiplier (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detection_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detection_multiplier() directly.

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detection_multiplier must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)""",
        })

    self.__detection_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detection_multiplier(self):
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='uint8', is_config=False)

  enabled = __builtin__.property(_get_enabled)
  desired_minimum_tx_interval = __builtin__.property(_get_desired_minimum_tx_interval)
  required_minimum_receive = __builtin__.property(_get_required_minimum_receive)
  detection_multiplier = __builtin__.property(_get_detection_multiplier)


  _pyangbind_elements = OrderedDict([('enabled', enabled), ('desired_minimum_tx_interval', desired_minimum_tx_interval), ('required_minimum_receive', required_minimum_receive), ('detection_multiplier', detection_multiplier), ])


