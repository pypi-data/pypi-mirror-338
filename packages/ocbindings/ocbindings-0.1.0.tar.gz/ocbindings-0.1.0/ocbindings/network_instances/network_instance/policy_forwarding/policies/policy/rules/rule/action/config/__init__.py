# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/action/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters relating to the forwarding
rule's action.
  """
  __slots__ = ('_path_helper', '_extmethods', '__discard','__decapsulate_gre','__decap_network_instance','__decap_fallback_network_instance','__post_decap_network_instance','__network_instance','__path_selection_group','__next_hop','__decapsulate_mpls_in_udp','__decapsulate_gue',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__discard = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decapsulate_gre = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__decap_fallback_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__post_decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__path_selection_group = YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)
    self.__decapsulate_mpls_in_udp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decapsulate_gue = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'policy-forwarding', 'policies', 'policy', 'rules', 'rule', 'action', 'config']

  def _get_discard(self):
    """
    Getter method for discard, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/discard (boolean)

    YANG Description: When this leaf is set to true, the local system should drop
packets that match the rule.
    """
    return self.__discard
      
  def _set_discard(self, v, load=False):
    """
    Setter method for discard, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/discard (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discard() directly.

    YANG Description: When this leaf is set to true, the local system should drop
packets that match the rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discard must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__discard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discard(self):
    self.__discard = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decapsulate_gre(self):
    """
    Getter method for decapsulate_gre, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gre (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the GRE header from the packet matching the rule. Following
the decapsulation it should subsequently forward the
encapsulated packet according to the relevant lookup (e.g., if
the encapsulated packet is IP, the packet should be routed
according to the IP destination).
    """
    return self.__decapsulate_gre
      
  def _set_decapsulate_gre(self, v, load=False):
    """
    Setter method for decapsulate_gre, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gre (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_gre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_gre() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the GRE header from the packet matching the rule. Following
the decapsulation it should subsequently forward the
encapsulated packet according to the relevant lookup (e.g., if
the encapsulated packet is IP, the packet should be routed
according to the IP destination).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_gre must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_gre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_gre(self):
    self.__decapsulate_gre = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decap_network_instance(self):
    """
    Getter method for decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_network_instance (leafref)

    YANG Description: This leaf is mutually exclusive with ../network-instance.
This leaf should be used along with
../decap-fallback-network-instance and ../post-decap-network-instance.
This leaf is normally used with NIs (network instances) that are
populated by SDN controllers (e.g. via gRIBI), where we want:
 - The decapsulation decision to be controlled by the
   controllers.
 - The new header after decapsulation is to be looked up in
   another NI, and the NI is chosen by fields (e.g. source IP,
   DSCP, etc) that are not used for route resolution.
When this leaf is set, packets matching the match criteria for
the forwarding rule should be looked up in the specified NI.
It is expected that the NI should only contain routes that have
next hop action as decapsulation.
 - If there is a match, the packet should be decapsulated.
   The route lookup on the new header should happen in the
   ../post-decap-network-instance.
 - If there is no match, the packet should be looked up in the
   NI set by ../decap-fallback-network-instance.
    """
    return self.__decap_network_instance
      
  def _set_decap_network_instance(self, v, load=False):
    """
    Setter method for decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decap_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decap_network_instance() directly.

    YANG Description: This leaf is mutually exclusive with ../network-instance.
This leaf should be used along with
../decap-fallback-network-instance and ../post-decap-network-instance.
This leaf is normally used with NIs (network instances) that are
populated by SDN controllers (e.g. via gRIBI), where we want:
 - The decapsulation decision to be controlled by the
   controllers.
 - The new header after decapsulation is to be looked up in
   another NI, and the NI is chosen by fields (e.g. source IP,
   DSCP, etc) that are not used for route resolution.
When this leaf is set, packets matching the match criteria for
the forwarding rule should be looked up in the specified NI.
It is expected that the NI should only contain routes that have
next hop action as decapsulation.
 - If there is a match, the packet should be decapsulated.
   The route lookup on the new header should happen in the
   ../post-decap-network-instance.
 - If there is no match, the packet should be looked up in the
   NI set by ../decap-fallback-network-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decap_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__decap_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decap_network_instance(self):
    self.__decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_decap_fallback_network_instance(self):
    """
    Getter method for decap_fallback_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_fallback_network_instance (leafref)

    YANG Description: This leaf has to be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used as a
fallback instance for lookup when
../decap-network-instance produces no match for the packet.
NI specified by this leaf might contain different mixed next hop
actions (e.g. next hop IP, decapsulation, redirect to another NI,
etc).
    """
    return self.__decap_fallback_network_instance
      
  def _set_decap_fallback_network_instance(self, v, load=False):
    """
    Setter method for decap_fallback_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_fallback_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decap_fallback_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decap_fallback_network_instance() directly.

    YANG Description: This leaf has to be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used as a
fallback instance for lookup when
../decap-network-instance produces no match for the packet.
NI specified by this leaf might contain different mixed next hop
actions (e.g. next hop IP, decapsulation, redirect to another NI,
etc).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decap_fallback_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__decap_fallback_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decap_fallback_network_instance(self):
    self.__decap_fallback_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_post_decap_network_instance(self):
    """
    Getter method for post_decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/post_decap_network_instance (leafref)

    YANG Description: This leaf can only be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used for lookup
on the new header after ../decap-network-instance does decap for
the matched packet. NI specified by this leaf might contain different
mixed next hop actions (e.g. next hop IP, decapsulation,
redirect to another NI, etc).
    """
    return self.__post_decap_network_instance
      
  def _set_post_decap_network_instance(self, v, load=False):
    """
    Setter method for post_decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/post_decap_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_decap_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_decap_network_instance() directly.

    YANG Description: This leaf can only be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used for lookup
on the new header after ../decap-network-instance does decap for
the matched packet. NI specified by this leaf might contain different
mixed next hop actions (e.g. next hop IP, decapsulation,
redirect to another NI, etc).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_decap_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__post_decap_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_decap_network_instance(self):
    self.__post_decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/network_instance (leafref)

    YANG Description: This leaf is mutually exclusive with ../decap-network-instance.
When this leaf is set, packets matching the match criteria
for the forwarding rule should be looked up in the
network-instance that is referenced rather than the
network-instance with which the interface is associated.
Such configuration allows policy-routing into multiple
sub-topologies from a single ingress access interface, or
different send and receive contexts for a particular
interface (sometimes referred to as half-duplex VRF).
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: This leaf is mutually exclusive with ../decap-network-instance.
When this leaf is set, packets matching the match criteria
for the forwarding rule should be looked up in the
network-instance that is referenced rather than the
network-instance with which the interface is associated.
Such configuration allows policy-routing into multiple
sub-topologies from a single ingress access interface, or
different send and receive contexts for a particular
interface (sometimes referred to as half-duplex VRF).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_path_selection_group(self):
    """
    Getter method for path_selection_group, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/path_selection_group (leafref)

    YANG Description: When path-selection-group is set, packets matching the
match criteria for the forwarding rule should be forwarded
only via one of the paths that is specified within the
referenced path-selection-group. The next-hop of the packet
within the routing context should be used to determine between
multiple paths that are specified within the group.
    """
    return self.__path_selection_group
      
  def _set_path_selection_group(self, v, load=False):
    """
    Setter method for path_selection_group, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/path_selection_group (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_selection_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_selection_group() directly.

    YANG Description: When path-selection-group is set, packets matching the
match criteria for the forwarding rule should be forwarded
only via one of the paths that is specified within the
referenced path-selection-group. The next-hop of the packet
within the routing context should be used to determine between
multiple paths that are specified within the group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_selection_group must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__path_selection_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_selection_group(self):
    self.__path_selection_group = YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/next_hop (oc-inet:ip-address)

    YANG Description: When an IP next-hop is specified in the next-hop field,
packets matching the match criteria for the forwarding rule
should be forwarded to the next-hop IP address, bypassing any
lookup on the local system.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/next_hop (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: When an IP next-hop is specified in the next-hop field,
packets matching the match criteria for the forwarding rule
should be forwarded to the next-hop IP address, bypassing any
lookup on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)


  def _get_decapsulate_mpls_in_udp(self):
    """
    Getter method for decapsulate_mpls_in_udp, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_mpls_in_udp (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the UDP header from the packet matching the rule.
Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying MPLS label.
    """
    return self.__decapsulate_mpls_in_udp
      
  def _set_decapsulate_mpls_in_udp(self, v, load=False):
    """
    Setter method for decapsulate_mpls_in_udp, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_mpls_in_udp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_mpls_in_udp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_mpls_in_udp() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the UDP header from the packet matching the rule.
Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying MPLS label.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_mpls_in_udp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_mpls_in_udp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_mpls_in_udp(self):
    self.__decapsulate_mpls_in_udp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decapsulate_gue(self):
    """
    Getter method for decapsulate_gue, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gue (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the Generic UDP Encapsulation (GUE) header from the packet matching
the rule. Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying IPv4 or IPv6 header.
    """
    return self.__decapsulate_gue
      
  def _set_decapsulate_gue(self, v, load=False):
    """
    Setter method for decapsulate_gue, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gue (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_gue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_gue() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the Generic UDP Encapsulation (GUE) header from the packet matching
the rule. Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying IPv4 or IPv6 header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_gue must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_gue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_gue(self):
    self.__decapsulate_gue = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)

  discard = __builtin__.property(_get_discard, _set_discard)
  decapsulate_gre = __builtin__.property(_get_decapsulate_gre, _set_decapsulate_gre)
  decap_network_instance = __builtin__.property(_get_decap_network_instance, _set_decap_network_instance)
  decap_fallback_network_instance = __builtin__.property(_get_decap_fallback_network_instance, _set_decap_fallback_network_instance)
  post_decap_network_instance = __builtin__.property(_get_post_decap_network_instance, _set_post_decap_network_instance)
  network_instance = __builtin__.property(_get_network_instance, _set_network_instance)
  path_selection_group = __builtin__.property(_get_path_selection_group, _set_path_selection_group)
  next_hop = __builtin__.property(_get_next_hop, _set_next_hop)
  decapsulate_mpls_in_udp = __builtin__.property(_get_decapsulate_mpls_in_udp, _set_decapsulate_mpls_in_udp)
  decapsulate_gue = __builtin__.property(_get_decapsulate_gue, _set_decapsulate_gue)


  _pyangbind_elements = OrderedDict([('discard', discard), ('decapsulate_gre', decapsulate_gre), ('decap_network_instance', decap_network_instance), ('decap_fallback_network_instance', decap_fallback_network_instance), ('post_decap_network_instance', post_decap_network_instance), ('network_instance', network_instance), ('path_selection_group', path_selection_group), ('next_hop', next_hop), ('decapsulate_mpls_in_udp', decapsulate_mpls_in_udp), ('decapsulate_gue', decapsulate_gue), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/action/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters relating to the forwarding
rule's action.
  """
  __slots__ = ('_path_helper', '_extmethods', '__discard','__decapsulate_gre','__decap_network_instance','__decap_fallback_network_instance','__post_decap_network_instance','__network_instance','__path_selection_group','__next_hop','__decapsulate_mpls_in_udp','__decapsulate_gue',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__discard = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decapsulate_gre = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__decap_fallback_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__post_decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__path_selection_group = YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)
    self.__decapsulate_mpls_in_udp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decapsulate_gue = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'policy-forwarding', 'policies', 'policy', 'rules', 'rule', 'action', 'config']

  def _get_discard(self):
    """
    Getter method for discard, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/discard (boolean)

    YANG Description: When this leaf is set to true, the local system should drop
packets that match the rule.
    """
    return self.__discard
      
  def _set_discard(self, v, load=False):
    """
    Setter method for discard, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/discard (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discard() directly.

    YANG Description: When this leaf is set to true, the local system should drop
packets that match the rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discard must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__discard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discard(self):
    self.__discard = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decapsulate_gre(self):
    """
    Getter method for decapsulate_gre, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gre (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the GRE header from the packet matching the rule. Following
the decapsulation it should subsequently forward the
encapsulated packet according to the relevant lookup (e.g., if
the encapsulated packet is IP, the packet should be routed
according to the IP destination).
    """
    return self.__decapsulate_gre
      
  def _set_decapsulate_gre(self, v, load=False):
    """
    Setter method for decapsulate_gre, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gre (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_gre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_gre() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the GRE header from the packet matching the rule. Following
the decapsulation it should subsequently forward the
encapsulated packet according to the relevant lookup (e.g., if
the encapsulated packet is IP, the packet should be routed
according to the IP destination).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_gre must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_gre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_gre(self):
    self.__decapsulate_gre = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decap_network_instance(self):
    """
    Getter method for decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_network_instance (leafref)

    YANG Description: This leaf is mutually exclusive with ../network-instance.
This leaf should be used along with
../decap-fallback-network-instance and ../post-decap-network-instance.
This leaf is normally used with NIs (network instances) that are
populated by SDN controllers (e.g. via gRIBI), where we want:
 - The decapsulation decision to be controlled by the
   controllers.
 - The new header after decapsulation is to be looked up in
   another NI, and the NI is chosen by fields (e.g. source IP,
   DSCP, etc) that are not used for route resolution.
When this leaf is set, packets matching the match criteria for
the forwarding rule should be looked up in the specified NI.
It is expected that the NI should only contain routes that have
next hop action as decapsulation.
 - If there is a match, the packet should be decapsulated.
   The route lookup on the new header should happen in the
   ../post-decap-network-instance.
 - If there is no match, the packet should be looked up in the
   NI set by ../decap-fallback-network-instance.
    """
    return self.__decap_network_instance
      
  def _set_decap_network_instance(self, v, load=False):
    """
    Setter method for decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decap_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decap_network_instance() directly.

    YANG Description: This leaf is mutually exclusive with ../network-instance.
This leaf should be used along with
../decap-fallback-network-instance and ../post-decap-network-instance.
This leaf is normally used with NIs (network instances) that are
populated by SDN controllers (e.g. via gRIBI), where we want:
 - The decapsulation decision to be controlled by the
   controllers.
 - The new header after decapsulation is to be looked up in
   another NI, and the NI is chosen by fields (e.g. source IP,
   DSCP, etc) that are not used for route resolution.
When this leaf is set, packets matching the match criteria for
the forwarding rule should be looked up in the specified NI.
It is expected that the NI should only contain routes that have
next hop action as decapsulation.
 - If there is a match, the packet should be decapsulated.
   The route lookup on the new header should happen in the
   ../post-decap-network-instance.
 - If there is no match, the packet should be looked up in the
   NI set by ../decap-fallback-network-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decap_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__decap_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decap_network_instance(self):
    self.__decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_decap_fallback_network_instance(self):
    """
    Getter method for decap_fallback_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_fallback_network_instance (leafref)

    YANG Description: This leaf has to be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used as a
fallback instance for lookup when
../decap-network-instance produces no match for the packet.
NI specified by this leaf might contain different mixed next hop
actions (e.g. next hop IP, decapsulation, redirect to another NI,
etc).
    """
    return self.__decap_fallback_network_instance
      
  def _set_decap_fallback_network_instance(self, v, load=False):
    """
    Setter method for decap_fallback_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_fallback_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decap_fallback_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decap_fallback_network_instance() directly.

    YANG Description: This leaf has to be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used as a
fallback instance for lookup when
../decap-network-instance produces no match for the packet.
NI specified by this leaf might contain different mixed next hop
actions (e.g. next hop IP, decapsulation, redirect to another NI,
etc).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decap_fallback_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__decap_fallback_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decap_fallback_network_instance(self):
    self.__decap_fallback_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_post_decap_network_instance(self):
    """
    Getter method for post_decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/post_decap_network_instance (leafref)

    YANG Description: This leaf can only be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used for lookup
on the new header after ../decap-network-instance does decap for
the matched packet. NI specified by this leaf might contain different
mixed next hop actions (e.g. next hop IP, decapsulation,
redirect to another NI, etc).
    """
    return self.__post_decap_network_instance
      
  def _set_post_decap_network_instance(self, v, load=False):
    """
    Setter method for post_decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/post_decap_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_decap_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_decap_network_instance() directly.

    YANG Description: This leaf can only be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used for lookup
on the new header after ../decap-network-instance does decap for
the matched packet. NI specified by this leaf might contain different
mixed next hop actions (e.g. next hop IP, decapsulation,
redirect to another NI, etc).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_decap_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__post_decap_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_decap_network_instance(self):
    self.__post_decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/network_instance (leafref)

    YANG Description: This leaf is mutually exclusive with ../decap-network-instance.
When this leaf is set, packets matching the match criteria
for the forwarding rule should be looked up in the
network-instance that is referenced rather than the
network-instance with which the interface is associated.
Such configuration allows policy-routing into multiple
sub-topologies from a single ingress access interface, or
different send and receive contexts for a particular
interface (sometimes referred to as half-duplex VRF).
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: This leaf is mutually exclusive with ../decap-network-instance.
When this leaf is set, packets matching the match criteria
for the forwarding rule should be looked up in the
network-instance that is referenced rather than the
network-instance with which the interface is associated.
Such configuration allows policy-routing into multiple
sub-topologies from a single ingress access interface, or
different send and receive contexts for a particular
interface (sometimes referred to as half-duplex VRF).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_path_selection_group(self):
    """
    Getter method for path_selection_group, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/path_selection_group (leafref)

    YANG Description: When path-selection-group is set, packets matching the
match criteria for the forwarding rule should be forwarded
only via one of the paths that is specified within the
referenced path-selection-group. The next-hop of the packet
within the routing context should be used to determine between
multiple paths that are specified within the group.
    """
    return self.__path_selection_group
      
  def _set_path_selection_group(self, v, load=False):
    """
    Setter method for path_selection_group, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/path_selection_group (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_selection_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_selection_group() directly.

    YANG Description: When path-selection-group is set, packets matching the
match criteria for the forwarding rule should be forwarded
only via one of the paths that is specified within the
referenced path-selection-group. The next-hop of the packet
within the routing context should be used to determine between
multiple paths that are specified within the group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_selection_group must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__path_selection_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_selection_group(self):
    self.__path_selection_group = YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/next_hop (oc-inet:ip-address)

    YANG Description: When an IP next-hop is specified in the next-hop field,
packets matching the match criteria for the forwarding rule
should be forwarded to the next-hop IP address, bypassing any
lookup on the local system.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/next_hop (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: When an IP next-hop is specified in the next-hop field,
packets matching the match criteria for the forwarding rule
should be forwarded to the next-hop IP address, bypassing any
lookup on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)


  def _get_decapsulate_mpls_in_udp(self):
    """
    Getter method for decapsulate_mpls_in_udp, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_mpls_in_udp (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the UDP header from the packet matching the rule.
Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying MPLS label.
    """
    return self.__decapsulate_mpls_in_udp
      
  def _set_decapsulate_mpls_in_udp(self, v, load=False):
    """
    Setter method for decapsulate_mpls_in_udp, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_mpls_in_udp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_mpls_in_udp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_mpls_in_udp() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the UDP header from the packet matching the rule.
Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying MPLS label.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_mpls_in_udp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_mpls_in_udp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_mpls_in_udp(self):
    self.__decapsulate_mpls_in_udp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decapsulate_gue(self):
    """
    Getter method for decapsulate_gue, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gue (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the Generic UDP Encapsulation (GUE) header from the packet matching
the rule. Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying IPv4 or IPv6 header.
    """
    return self.__decapsulate_gue
      
  def _set_decapsulate_gue(self, v, load=False):
    """
    Setter method for decapsulate_gue, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gue (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_gue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_gue() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the Generic UDP Encapsulation (GUE) header from the packet matching
the rule. Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying IPv4 or IPv6 header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_gue must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_gue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_gue(self):
    self.__decapsulate_gue = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)

  discard = __builtin__.property(_get_discard, _set_discard)
  decapsulate_gre = __builtin__.property(_get_decapsulate_gre, _set_decapsulate_gre)
  decap_network_instance = __builtin__.property(_get_decap_network_instance, _set_decap_network_instance)
  decap_fallback_network_instance = __builtin__.property(_get_decap_fallback_network_instance, _set_decap_fallback_network_instance)
  post_decap_network_instance = __builtin__.property(_get_post_decap_network_instance, _set_post_decap_network_instance)
  network_instance = __builtin__.property(_get_network_instance, _set_network_instance)
  path_selection_group = __builtin__.property(_get_path_selection_group, _set_path_selection_group)
  next_hop = __builtin__.property(_get_next_hop, _set_next_hop)
  decapsulate_mpls_in_udp = __builtin__.property(_get_decapsulate_mpls_in_udp, _set_decapsulate_mpls_in_udp)
  decapsulate_gue = __builtin__.property(_get_decapsulate_gue, _set_decapsulate_gue)


  _pyangbind_elements = OrderedDict([('discard', discard), ('decapsulate_gre', decapsulate_gre), ('decap_network_instance', decap_network_instance), ('decap_fallback_network_instance', decap_fallback_network_instance), ('post_decap_network_instance', post_decap_network_instance), ('network_instance', network_instance), ('path_selection_group', path_selection_group), ('next_hop', next_hop), ('decapsulate_mpls_in_udp', decapsulate_mpls_in_udp), ('decapsulate_gue', decapsulate_gue), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/action/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters relating to the forwarding
rule's action.
  """
  __slots__ = ('_path_helper', '_extmethods', '__discard','__decapsulate_gre','__decap_network_instance','__decap_fallback_network_instance','__post_decap_network_instance','__network_instance','__path_selection_group','__next_hop','__decapsulate_mpls_in_udp','__decapsulate_gue',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__discard = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decapsulate_gre = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__decap_fallback_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__post_decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__path_selection_group = YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)
    self.__decapsulate_mpls_in_udp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decapsulate_gue = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'policy-forwarding', 'policies', 'policy', 'rules', 'rule', 'action', 'config']

  def _get_discard(self):
    """
    Getter method for discard, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/discard (boolean)

    YANG Description: When this leaf is set to true, the local system should drop
packets that match the rule.
    """
    return self.__discard
      
  def _set_discard(self, v, load=False):
    """
    Setter method for discard, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/discard (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discard() directly.

    YANG Description: When this leaf is set to true, the local system should drop
packets that match the rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discard must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__discard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discard(self):
    self.__discard = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decapsulate_gre(self):
    """
    Getter method for decapsulate_gre, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gre (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the GRE header from the packet matching the rule. Following
the decapsulation it should subsequently forward the
encapsulated packet according to the relevant lookup (e.g., if
the encapsulated packet is IP, the packet should be routed
according to the IP destination).
    """
    return self.__decapsulate_gre
      
  def _set_decapsulate_gre(self, v, load=False):
    """
    Setter method for decapsulate_gre, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gre (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_gre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_gre() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the GRE header from the packet matching the rule. Following
the decapsulation it should subsequently forward the
encapsulated packet according to the relevant lookup (e.g., if
the encapsulated packet is IP, the packet should be routed
according to the IP destination).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_gre must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_gre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_gre(self):
    self.__decapsulate_gre = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decap_network_instance(self):
    """
    Getter method for decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_network_instance (leafref)

    YANG Description: This leaf is mutually exclusive with ../network-instance.
This leaf should be used along with
../decap-fallback-network-instance and ../post-decap-network-instance.
This leaf is normally used with NIs (network instances) that are
populated by SDN controllers (e.g. via gRIBI), where we want:
 - The decapsulation decision to be controlled by the
   controllers.
 - The new header after decapsulation is to be looked up in
   another NI, and the NI is chosen by fields (e.g. source IP,
   DSCP, etc) that are not used for route resolution.
When this leaf is set, packets matching the match criteria for
the forwarding rule should be looked up in the specified NI.
It is expected that the NI should only contain routes that have
next hop action as decapsulation.
 - If there is a match, the packet should be decapsulated.
   The route lookup on the new header should happen in the
   ../post-decap-network-instance.
 - If there is no match, the packet should be looked up in the
   NI set by ../decap-fallback-network-instance.
    """
    return self.__decap_network_instance
      
  def _set_decap_network_instance(self, v, load=False):
    """
    Setter method for decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decap_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decap_network_instance() directly.

    YANG Description: This leaf is mutually exclusive with ../network-instance.
This leaf should be used along with
../decap-fallback-network-instance and ../post-decap-network-instance.
This leaf is normally used with NIs (network instances) that are
populated by SDN controllers (e.g. via gRIBI), where we want:
 - The decapsulation decision to be controlled by the
   controllers.
 - The new header after decapsulation is to be looked up in
   another NI, and the NI is chosen by fields (e.g. source IP,
   DSCP, etc) that are not used for route resolution.
When this leaf is set, packets matching the match criteria for
the forwarding rule should be looked up in the specified NI.
It is expected that the NI should only contain routes that have
next hop action as decapsulation.
 - If there is a match, the packet should be decapsulated.
   The route lookup on the new header should happen in the
   ../post-decap-network-instance.
 - If there is no match, the packet should be looked up in the
   NI set by ../decap-fallback-network-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decap_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__decap_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decap_network_instance(self):
    self.__decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_decap_fallback_network_instance(self):
    """
    Getter method for decap_fallback_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_fallback_network_instance (leafref)

    YANG Description: This leaf has to be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used as a
fallback instance for lookup when
../decap-network-instance produces no match for the packet.
NI specified by this leaf might contain different mixed next hop
actions (e.g. next hop IP, decapsulation, redirect to another NI,
etc).
    """
    return self.__decap_fallback_network_instance
      
  def _set_decap_fallback_network_instance(self, v, load=False):
    """
    Setter method for decap_fallback_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_fallback_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decap_fallback_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decap_fallback_network_instance() directly.

    YANG Description: This leaf has to be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used as a
fallback instance for lookup when
../decap-network-instance produces no match for the packet.
NI specified by this leaf might contain different mixed next hop
actions (e.g. next hop IP, decapsulation, redirect to another NI,
etc).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decap_fallback_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__decap_fallback_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decap_fallback_network_instance(self):
    self.__decap_fallback_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_post_decap_network_instance(self):
    """
    Getter method for post_decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/post_decap_network_instance (leafref)

    YANG Description: This leaf can only be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used for lookup
on the new header after ../decap-network-instance does decap for
the matched packet. NI specified by this leaf might contain different
mixed next hop actions (e.g. next hop IP, decapsulation,
redirect to another NI, etc).
    """
    return self.__post_decap_network_instance
      
  def _set_post_decap_network_instance(self, v, load=False):
    """
    Setter method for post_decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/post_decap_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_decap_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_decap_network_instance() directly.

    YANG Description: This leaf can only be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used for lookup
on the new header after ../decap-network-instance does decap for
the matched packet. NI specified by this leaf might contain different
mixed next hop actions (e.g. next hop IP, decapsulation,
redirect to another NI, etc).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_decap_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__post_decap_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_decap_network_instance(self):
    self.__post_decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/network_instance (leafref)

    YANG Description: This leaf is mutually exclusive with ../decap-network-instance.
When this leaf is set, packets matching the match criteria
for the forwarding rule should be looked up in the
network-instance that is referenced rather than the
network-instance with which the interface is associated.
Such configuration allows policy-routing into multiple
sub-topologies from a single ingress access interface, or
different send and receive contexts for a particular
interface (sometimes referred to as half-duplex VRF).
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: This leaf is mutually exclusive with ../decap-network-instance.
When this leaf is set, packets matching the match criteria
for the forwarding rule should be looked up in the
network-instance that is referenced rather than the
network-instance with which the interface is associated.
Such configuration allows policy-routing into multiple
sub-topologies from a single ingress access interface, or
different send and receive contexts for a particular
interface (sometimes referred to as half-duplex VRF).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_path_selection_group(self):
    """
    Getter method for path_selection_group, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/path_selection_group (leafref)

    YANG Description: When path-selection-group is set, packets matching the
match criteria for the forwarding rule should be forwarded
only via one of the paths that is specified within the
referenced path-selection-group. The next-hop of the packet
within the routing context should be used to determine between
multiple paths that are specified within the group.
    """
    return self.__path_selection_group
      
  def _set_path_selection_group(self, v, load=False):
    """
    Setter method for path_selection_group, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/path_selection_group (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_selection_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_selection_group() directly.

    YANG Description: When path-selection-group is set, packets matching the
match criteria for the forwarding rule should be forwarded
only via one of the paths that is specified within the
referenced path-selection-group. The next-hop of the packet
within the routing context should be used to determine between
multiple paths that are specified within the group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_selection_group must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__path_selection_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_selection_group(self):
    self.__path_selection_group = YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/next_hop (oc-inet:ip-address)

    YANG Description: When an IP next-hop is specified in the next-hop field,
packets matching the match criteria for the forwarding rule
should be forwarded to the next-hop IP address, bypassing any
lookup on the local system.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/next_hop (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: When an IP next-hop is specified in the next-hop field,
packets matching the match criteria for the forwarding rule
should be forwarded to the next-hop IP address, bypassing any
lookup on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)


  def _get_decapsulate_mpls_in_udp(self):
    """
    Getter method for decapsulate_mpls_in_udp, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_mpls_in_udp (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the UDP header from the packet matching the rule.
Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying MPLS label.
    """
    return self.__decapsulate_mpls_in_udp
      
  def _set_decapsulate_mpls_in_udp(self, v, load=False):
    """
    Setter method for decapsulate_mpls_in_udp, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_mpls_in_udp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_mpls_in_udp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_mpls_in_udp() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the UDP header from the packet matching the rule.
Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying MPLS label.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_mpls_in_udp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_mpls_in_udp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_mpls_in_udp(self):
    self.__decapsulate_mpls_in_udp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decapsulate_gue(self):
    """
    Getter method for decapsulate_gue, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gue (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the Generic UDP Encapsulation (GUE) header from the packet matching
the rule. Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying IPv4 or IPv6 header.
    """
    return self.__decapsulate_gue
      
  def _set_decapsulate_gue(self, v, load=False):
    """
    Setter method for decapsulate_gue, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gue (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_gue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_gue() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the Generic UDP Encapsulation (GUE) header from the packet matching
the rule. Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying IPv4 or IPv6 header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_gue must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_gue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_gue(self):
    self.__decapsulate_gue = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)

  discard = __builtin__.property(_get_discard, _set_discard)
  decapsulate_gre = __builtin__.property(_get_decapsulate_gre, _set_decapsulate_gre)
  decap_network_instance = __builtin__.property(_get_decap_network_instance, _set_decap_network_instance)
  decap_fallback_network_instance = __builtin__.property(_get_decap_fallback_network_instance, _set_decap_fallback_network_instance)
  post_decap_network_instance = __builtin__.property(_get_post_decap_network_instance, _set_post_decap_network_instance)
  network_instance = __builtin__.property(_get_network_instance, _set_network_instance)
  path_selection_group = __builtin__.property(_get_path_selection_group, _set_path_selection_group)
  next_hop = __builtin__.property(_get_next_hop, _set_next_hop)
  decapsulate_mpls_in_udp = __builtin__.property(_get_decapsulate_mpls_in_udp, _set_decapsulate_mpls_in_udp)
  decapsulate_gue = __builtin__.property(_get_decapsulate_gue, _set_decapsulate_gue)


  _pyangbind_elements = OrderedDict([('discard', discard), ('decapsulate_gre', decapsulate_gre), ('decap_network_instance', decap_network_instance), ('decap_fallback_network_instance', decap_fallback_network_instance), ('post_decap_network_instance', post_decap_network_instance), ('network_instance', network_instance), ('path_selection_group', path_selection_group), ('next_hop', next_hop), ('decapsulate_mpls_in_udp', decapsulate_mpls_in_udp), ('decapsulate_gue', decapsulate_gue), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/policy-forwarding/policies/policy/rules/rule/action/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters relating to the forwarding
rule's action.
  """
  __slots__ = ('_path_helper', '_extmethods', '__discard','__decapsulate_gre','__decap_network_instance','__decap_fallback_network_instance','__post_decap_network_instance','__network_instance','__path_selection_group','__next_hop','__decapsulate_mpls_in_udp','__decapsulate_gue',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__discard = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decapsulate_gre = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__decap_fallback_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__post_decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__path_selection_group = YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)
    self.__decapsulate_mpls_in_udp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__decapsulate_gue = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'policy-forwarding', 'policies', 'policy', 'rules', 'rule', 'action', 'config']

  def _get_discard(self):
    """
    Getter method for discard, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/discard (boolean)

    YANG Description: When this leaf is set to true, the local system should drop
packets that match the rule.
    """
    return self.__discard
      
  def _set_discard(self, v, load=False):
    """
    Setter method for discard, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/discard (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_discard is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_discard() directly.

    YANG Description: When this leaf is set to true, the local system should drop
packets that match the rule.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """discard must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__discard = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_discard(self):
    self.__discard = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="discard", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decapsulate_gre(self):
    """
    Getter method for decapsulate_gre, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gre (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the GRE header from the packet matching the rule. Following
the decapsulation it should subsequently forward the
encapsulated packet according to the relevant lookup (e.g., if
the encapsulated packet is IP, the packet should be routed
according to the IP destination).
    """
    return self.__decapsulate_gre
      
  def _set_decapsulate_gre(self, v, load=False):
    """
    Setter method for decapsulate_gre, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gre (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_gre is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_gre() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the GRE header from the packet matching the rule. Following
the decapsulation it should subsequently forward the
encapsulated packet according to the relevant lookup (e.g., if
the encapsulated packet is IP, the packet should be routed
according to the IP destination).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_gre must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_gre = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_gre(self):
    self.__decapsulate_gre = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gre", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decap_network_instance(self):
    """
    Getter method for decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_network_instance (leafref)

    YANG Description: This leaf is mutually exclusive with ../network-instance.
This leaf should be used along with
../decap-fallback-network-instance and ../post-decap-network-instance.
This leaf is normally used with NIs (network instances) that are
populated by SDN controllers (e.g. via gRIBI), where we want:
 - The decapsulation decision to be controlled by the
   controllers.
 - The new header after decapsulation is to be looked up in
   another NI, and the NI is chosen by fields (e.g. source IP,
   DSCP, etc) that are not used for route resolution.
When this leaf is set, packets matching the match criteria for
the forwarding rule should be looked up in the specified NI.
It is expected that the NI should only contain routes that have
next hop action as decapsulation.
 - If there is a match, the packet should be decapsulated.
   The route lookup on the new header should happen in the
   ../post-decap-network-instance.
 - If there is no match, the packet should be looked up in the
   NI set by ../decap-fallback-network-instance.
    """
    return self.__decap_network_instance
      
  def _set_decap_network_instance(self, v, load=False):
    """
    Setter method for decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decap_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decap_network_instance() directly.

    YANG Description: This leaf is mutually exclusive with ../network-instance.
This leaf should be used along with
../decap-fallback-network-instance and ../post-decap-network-instance.
This leaf is normally used with NIs (network instances) that are
populated by SDN controllers (e.g. via gRIBI), where we want:
 - The decapsulation decision to be controlled by the
   controllers.
 - The new header after decapsulation is to be looked up in
   another NI, and the NI is chosen by fields (e.g. source IP,
   DSCP, etc) that are not used for route resolution.
When this leaf is set, packets matching the match criteria for
the forwarding rule should be looked up in the specified NI.
It is expected that the NI should only contain routes that have
next hop action as decapsulation.
 - If there is a match, the packet should be decapsulated.
   The route lookup on the new header should happen in the
   ../post-decap-network-instance.
 - If there is no match, the packet should be looked up in the
   NI set by ../decap-fallback-network-instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decap_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__decap_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decap_network_instance(self):
    self.__decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_decap_fallback_network_instance(self):
    """
    Getter method for decap_fallback_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_fallback_network_instance (leafref)

    YANG Description: This leaf has to be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used as a
fallback instance for lookup when
../decap-network-instance produces no match for the packet.
NI specified by this leaf might contain different mixed next hop
actions (e.g. next hop IP, decapsulation, redirect to another NI,
etc).
    """
    return self.__decap_fallback_network_instance
      
  def _set_decap_fallback_network_instance(self, v, load=False):
    """
    Setter method for decap_fallback_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decap_fallback_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decap_fallback_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decap_fallback_network_instance() directly.

    YANG Description: This leaf has to be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used as a
fallback instance for lookup when
../decap-network-instance produces no match for the packet.
NI specified by this leaf might contain different mixed next hop
actions (e.g. next hop IP, decapsulation, redirect to another NI,
etc).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decap_fallback_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__decap_fallback_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decap_fallback_network_instance(self):
    self.__decap_fallback_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="decap-fallback-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_post_decap_network_instance(self):
    """
    Getter method for post_decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/post_decap_network_instance (leafref)

    YANG Description: This leaf can only be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used for lookup
on the new header after ../decap-network-instance does decap for
the matched packet. NI specified by this leaf might contain different
mixed next hop actions (e.g. next hop IP, decapsulation,
redirect to another NI, etc).
    """
    return self.__post_decap_network_instance
      
  def _set_post_decap_network_instance(self, v, load=False):
    """
    Setter method for post_decap_network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/post_decap_network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_post_decap_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_post_decap_network_instance() directly.

    YANG Description: This leaf can only be set when ../decap-network-instance is set.
When this leaf is set, the specified NI should be used for lookup
on the new header after ../decap-network-instance does decap for
the matched packet. NI specified by this leaf might contain different
mixed next hop actions (e.g. next hop IP, decapsulation,
redirect to another NI, etc).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """post_decap_network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__post_decap_network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_post_decap_network_instance(self):
    self.__post_decap_network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="post-decap-network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_network_instance(self):
    """
    Getter method for network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/network_instance (leafref)

    YANG Description: This leaf is mutually exclusive with ../decap-network-instance.
When this leaf is set, packets matching the match criteria
for the forwarding rule should be looked up in the
network-instance that is referenced rather than the
network-instance with which the interface is associated.
Such configuration allows policy-routing into multiple
sub-topologies from a single ingress access interface, or
different send and receive contexts for a particular
interface (sometimes referred to as half-duplex VRF).
    """
    return self.__network_instance
      
  def _set_network_instance(self, v, load=False):
    """
    Setter method for network_instance, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/network_instance (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instance is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instance() directly.

    YANG Description: This leaf is mutually exclusive with ../decap-network-instance.
When this leaf is set, packets matching the match criteria
for the forwarding rule should be looked up in the
network-instance that is referenced rather than the
network-instance with which the interface is associated.
Such configuration allows policy-routing into multiple
sub-topologies from a single ingress access interface, or
different send and receive contexts for a particular
interface (sometimes referred to as half-duplex VRF).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instance must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__network_instance = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instance(self):
    self.__network_instance = YANGDynClass(base=str, is_leaf=True, yang_name="network-instance", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_path_selection_group(self):
    """
    Getter method for path_selection_group, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/path_selection_group (leafref)

    YANG Description: When path-selection-group is set, packets matching the
match criteria for the forwarding rule should be forwarded
only via one of the paths that is specified within the
referenced path-selection-group. The next-hop of the packet
within the routing context should be used to determine between
multiple paths that are specified within the group.
    """
    return self.__path_selection_group
      
  def _set_path_selection_group(self, v, load=False):
    """
    Setter method for path_selection_group, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/path_selection_group (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_path_selection_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_path_selection_group() directly.

    YANG Description: When path-selection-group is set, packets matching the
match criteria for the forwarding rule should be forwarded
only via one of the paths that is specified within the
referenced path-selection-group. The next-hop of the packet
within the routing context should be used to determine between
multiple paths that are specified within the group.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """path_selection_group must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)""",
        })

    self.__path_selection_group = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_path_selection_group(self):
    self.__path_selection_group = YANGDynClass(base=str, is_leaf=True, yang_name="path-selection-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='leafref', is_config=True)


  def _get_next_hop(self):
    """
    Getter method for next_hop, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/next_hop (oc-inet:ip-address)

    YANG Description: When an IP next-hop is specified in the next-hop field,
packets matching the match criteria for the forwarding rule
should be forwarded to the next-hop IP address, bypassing any
lookup on the local system.
    """
    return self.__next_hop
      
  def _set_next_hop(self, v, load=False):
    """
    Setter method for next_hop, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/next_hop (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_next_hop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_next_hop() directly.

    YANG Description: When an IP next-hop is specified in the next-hop field,
packets matching the match criteria for the forwarding rule
should be forwarded to the next-hop IP address, bypassing any
lookup on the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """next_hop must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__next_hop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_next_hop(self):
    self.__next_hop = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="next-hop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='oc-inet:ip-address', is_config=True)


  def _get_decapsulate_mpls_in_udp(self):
    """
    Getter method for decapsulate_mpls_in_udp, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_mpls_in_udp (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the UDP header from the packet matching the rule.
Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying MPLS label.
    """
    return self.__decapsulate_mpls_in_udp
      
  def _set_decapsulate_mpls_in_udp(self, v, load=False):
    """
    Setter method for decapsulate_mpls_in_udp, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_mpls_in_udp (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_mpls_in_udp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_mpls_in_udp() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the UDP header from the packet matching the rule.
Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying MPLS label.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_mpls_in_udp must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_mpls_in_udp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_mpls_in_udp(self):
    self.__decapsulate_mpls_in_udp = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-mpls-in-udp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_decapsulate_gue(self):
    """
    Getter method for decapsulate_gue, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gue (boolean)

    YANG Description: When this leaf is set to true, the local system should remove
the Generic UDP Encapsulation (GUE) header from the packet matching
the rule. Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying IPv4 or IPv6 header.
    """
    return self.__decapsulate_gue
      
  def _set_decapsulate_gue(self, v, load=False):
    """
    Setter method for decapsulate_gue, mapped from YANG variable /network_instances/network_instance/policy_forwarding/policies/policy/rules/rule/action/config/decapsulate_gue (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_decapsulate_gue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_decapsulate_gue() directly.

    YANG Description: When this leaf is set to true, the local system should remove
the Generic UDP Encapsulation (GUE) header from the packet matching
the rule. Following the decapsulation it should subsequently forward the
encapsulated packet according to the underlying IPv4 or IPv6 header.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """decapsulate_gue must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__decapsulate_gue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_decapsulate_gue(self):
    self.__decapsulate_gue = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="decapsulate-gue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)

  discard = __builtin__.property(_get_discard, _set_discard)
  decapsulate_gre = __builtin__.property(_get_decapsulate_gre, _set_decapsulate_gre)
  decap_network_instance = __builtin__.property(_get_decap_network_instance, _set_decap_network_instance)
  decap_fallback_network_instance = __builtin__.property(_get_decap_fallback_network_instance, _set_decap_fallback_network_instance)
  post_decap_network_instance = __builtin__.property(_get_post_decap_network_instance, _set_post_decap_network_instance)
  network_instance = __builtin__.property(_get_network_instance, _set_network_instance)
  path_selection_group = __builtin__.property(_get_path_selection_group, _set_path_selection_group)
  next_hop = __builtin__.property(_get_next_hop, _set_next_hop)
  decapsulate_mpls_in_udp = __builtin__.property(_get_decapsulate_mpls_in_udp, _set_decapsulate_mpls_in_udp)
  decapsulate_gue = __builtin__.property(_get_decapsulate_gue, _set_decapsulate_gue)


  _pyangbind_elements = OrderedDict([('discard', discard), ('decapsulate_gre', decapsulate_gre), ('decap_network_instance', decap_network_instance), ('decap_fallback_network_instance', decap_fallback_network_instance), ('post_decap_network_instance', post_decap_network_instance), ('network_instance', network_instance), ('path_selection_group', path_selection_group), ('next_hop', next_hop), ('decapsulate_mpls_in_udp', decapsulate_mpls_in_udp), ('decapsulate_gue', decapsulate_gue), ])


