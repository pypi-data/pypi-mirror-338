# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
from . import oam
class openconfig_oam(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /openconfig-oam. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG data model for configuring and managing
EthernetOAM functions
  """
  __slots__ = ('_path_helper', '_extmethods', '__oam',)

  _yang_name = 'openconfig-oam'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oam = YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_oam(self):
    """
    Getter method for oam, mapped from YANG variable /oam (container)

    YANG Description: Operational state and configuration parameters relating to
Ethernet OAM
    """
    return self.__oam
      
  def _set_oam(self, v, load=False):
    """
    Setter method for oam, mapped from YANG variable /oam (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oam is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oam() directly.

    YANG Description: Operational state and configuration parameters relating to
Ethernet OAM
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=oam.oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oam must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)""",
        })

    self.__oam = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oam(self):
    self.__oam = YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)

  oam = __builtin__.property(_get_oam, _set_oam)


  _pyangbind_elements = OrderedDict([('oam', oam), ])


class openconfig_cfm_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-cfm-types - based on the path /openconfig-cfm-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in CFM
  """
  _pyangbind_elements = {}

  

class openconfig_oam_cfm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam-cfm - based on the path /openconfig-oam-cfm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG data model for configuring and managing CFM
(Connectivity Fault Management) in a network device. The module includes
maintenance domains, associations, maintenance endpoints,
performance management policies and remote defect handling features
  """
  _pyangbind_elements = {}

  

from . import provision_aps
from . import joined_aps
class openconfig_ap_manager(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /openconfig-ap-manager. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the top level configuration and state data for a
system which manages Access Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__provision_aps','__joined_aps',)

  _yang_name = 'openconfig-ap-manager'
  _yang_namespace = 'http://openconfig.net/yang/ap-manager'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__provision_aps = YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    self.__joined_aps = YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_provision_aps(self):
    """
    Getter method for provision_aps, mapped from YANG variable /provision_aps (container)

    YANG Description: Top most container for assigning hostnames to APs.
    """
    return self.__provision_aps
      
  def _set_provision_aps(self, v, load=False):
    """
    Setter method for provision_aps, mapped from YANG variable /provision_aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provision_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provision_aps() directly.

    YANG Description: Top most container for assigning hostnames to APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provision_aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__provision_aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provision_aps(self):
    self.__provision_aps = YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)


  def _get_joined_aps(self):
    """
    Getter method for joined_aps, mapped from YANG variable /joined_aps (container)

    YANG Description: Top most container for joined-aps.
    """
    return self.__joined_aps
      
  def _set_joined_aps(self, v, load=False):
    """
    Setter method for joined_aps, mapped from YANG variable /joined_aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_joined_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_joined_aps() directly.

    YANG Description: Top most container for joined-aps.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """joined_aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__joined_aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_joined_aps(self):
    self.__joined_aps = YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

  provision_aps = __builtin__.property(_get_provision_aps, _set_provision_aps)
  joined_aps = __builtin__.property(_get_joined_aps, _set_joined_aps)


  _pyangbind_elements = OrderedDict([('provision_aps', provision_aps), ('joined_aps', joined_aps), ])


from . import access_points
class openconfig_access_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /openconfig-access-points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the top level WiFi Configurations for a list of
Access Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__access_points',)

  _yang_name = 'openconfig-access-points'
  _yang_namespace = 'http://openconfig.net/yang/wifi/access-points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__access_points = YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_access_points(self):
    """
    Getter method for access_points, mapped from YANG variable /access_points (container)

    YANG Description: Top most container for configuration and state data for Access
Points.
    """
    return self.__access_points
      
  def _set_access_points(self, v, load=False):
    """
    Setter method for access_points, mapped from YANG variable /access_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_points() directly.

    YANG Description: Top most container for configuration and state data for Access
Points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__access_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_points(self):
    self.__access_points = YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  access_points = __builtin__.property(_get_access_points, _set_access_points)


  _pyangbind_elements = OrderedDict([('access_points', access_points), ])


from . import ssids
class openconfig_wifi_mac(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /openconfig-wifi-mac. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing MAC layer configuration of Radio interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ssids',)

  _yang_name = 'openconfig-wifi-mac'
  _yang_namespace = 'http://openconfig.net/yang/wifi-mac'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssids = YANGDynClass(base=ssids.ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ssids(self):
    """
    Getter method for ssids, mapped from YANG variable /ssids (container)

    YANG Description: Top level container for SSIDs, including configuration
and state data.
    """
    return self.__ssids
      
  def _set_ssids(self, v, load=False):
    """
    Setter method for ssids, mapped from YANG variable /ssids (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssids() directly.

    YANG Description: Top level container for SSIDs, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ssids.ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssids must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ssids.ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__ssids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssids(self):
    self.__ssids = YANGDynClass(base=ssids.ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  ssids = __builtin__.property(_get_ssids, _set_ssids)


  _pyangbind_elements = OrderedDict([('ssids', ssids), ])


class openconfig_ap_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-interfaces - based on the path /openconfig-ap-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the configuration and state data for
non-radio interfaces on WiFi Access Points.
  """
  _pyangbind_elements = {}

  

from . import radios
class openconfig_wifi_phy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-phy - based on the path /openconfig-wifi-phy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing PHY layer configuration of Radio interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__radios',)

  _yang_name = 'openconfig-wifi-phy'
  _yang_namespace = 'http://openconfig.net/yang/wifi-phy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__radios = YANGDynClass(base=radios.radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-phy', defining_module='openconfig-wifi-phy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_radios(self):
    """
    Getter method for radios, mapped from YANG variable /radios (container)

    YANG Description: Top level container for radios, including configuration
and state data.
    """
    return self.__radios
      
  def _set_radios(self, v, load=False):
    """
    Setter method for radios, mapped from YANG variable /radios (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radios is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radios() directly.

    YANG Description: Top level container for radios, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=radios.radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-phy', defining_module='openconfig-wifi-phy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radios must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=radios.radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-phy', defining_module='openconfig-wifi-phy', yang_type='container', is_config=True)""",
        })

    self.__radios = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radios(self):
    self.__radios = YANGDynClass(base=radios.radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-phy', defining_module='openconfig-wifi-phy', yang_type='container', is_config=True)

  radios = __builtin__.property(_get_radios, _set_radios)


  _pyangbind_elements = OrderedDict([('radios', radios), ])


class openconfig_wifi_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-types - based on the path /openconfig-wifi-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a set of WiFi-specific type definitions
that are used in the openconfig-wifi modules. It can be
imported by any module to make use of these types.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-ext - based on the path /openconfig-rib-bgp-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines additional data nodes for the OpenConfig BGP RIB model.
These items reflect extensions that are desirable features but
are not currently supported in a majority of BGP
implementations.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_tables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-tables - based on the path /openconfig-rib-bgp-tables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
BGP routing tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-attributes - based on the path /openconfig-rib-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_shared_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-shared-attributes - based on the path /openconfig-rib-bgp-shared-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
attribute sets shared across routes.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_table_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-table-attributes - based on the path /openconfig-rib-bgp-table-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for data
related to a RIB entry, or RIB table.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp - based on the path /openconfig-rib-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a data model for representing BGP routing table (RIB)
contents.  The model supports 5 logical RIBs per address family:

loc-rib: This is the main BGP routing table for the local routing
instance, containing best-path selections for each prefix. The
loc-rib table may contain multiple routes for a given prefix,
with an attribute to indicate which was selected as the best
path.  Note that multiple paths may be used or advertised even if
only one path is marked as best, e.g., when using BGP
add-paths.  An implementation may choose to mark multiple
paths in the RIB as best path by setting the flag to true for
multiple entries.

adj-rib-in-pre: This is a per-neighbor table containing the NLRI
updates received from the neighbor before any local input policy
rules or filters have been applied.  This can be considered the
'raw' updates from a given neighbor.

adj-rib-in-post: This is a per-neighbor table containing the
routes received from the neighbor that are eligible for
best-path selection after local input policy rules have been
applied.

adj-rib-out-pre: This is a per-neighbor table containing routes
eligible for sending (advertising) to the neighbor before output
policy rules have been applied.

adj-rib-out-post: This is a per-neighbor table containing routes
eligible for sending (advertising) to the neighbor after output
policy rules have been applied.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_tables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-tables - based on the path /openconfig-rib-bgp-tables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
BGP routing tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_shared_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-shared-attributes - based on the path /openconfig-rib-bgp-shared-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
attribute sets shared across routes.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-attributes - based on the path /openconfig-rib-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_table_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-table-attributes - based on the path /openconfig-rib-bgp-table-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for data
related to a RIB entry, or RIB table.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-attributes - based on the path /openconfig-rib-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_shared_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-shared-attributes - based on the path /openconfig-rib-bgp-shared-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
attribute sets shared across routes.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-attributes - based on the path /openconfig-rib-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_table_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-table-attributes - based on the path /openconfig-rib-bgp-table-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for data
related to a RIB entry, or RIB table.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-types - based on the path /openconfig-rib-bgp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines identity and type defintions associated with
the OpenConfig BGP RIB modules
  """
  _pyangbind_elements = {}

  

class openconfig_rsvp_sr_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rsvp-sr-ext - based on the path /openconfig-rsvp-sr-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds extensions to the OpenConfig MPLS models to
provide extensions which allow the coexistence of RSVP-TE and
Segment Routing (SR) within the same network. It augments the
existing OpenConfig segment routing (SR) and RSVP-TE models
where required.
  """
  _pyangbind_elements = {}

  

class openconfig_segment_routing_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-segment-routing-types - based on the path /openconfig-segment-routing-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Types associated with a network instance
  """
  _pyangbind_elements = {}

  

class openconfig_srte_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-srte-policy - based on the path /openconfig-srte-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a collection of segment routing traffic
engineering policy operational states.

Each policy, identified by a combination of color and endpoint,
has one or more candidate paths learned from one or more sources.
The best valid/usable path is marked as active and programmed in
forwarding plane.

A candidate path, identified by protocol-origin, originator and
discriminator, can have one and more segment-list defining the
path traffic should take. Each segment-list is associated with a
weight for weighted load balancing.

Traffic counters related to SR policies are also defined in this
module.
  """
  _pyangbind_elements = {}

  

class openconfig_segment_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-segment-routing - based on the path /openconfig-segment-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and operational state parameters relating to the
segment routing. This module defines a number of elements which are
instantiated in multiple places throughout the OpenConfig collection
of models.

Particularly:
 - SRGB+LB dataplane instances - directly instantied by SR.
 - SRGB+LB dataplane reservations - instantiated within MPLS and future SR
                                 dataplanes.
 - SR SID advertisements - instantiated within the relevant IGP.
 - SR-specific counters - instantied within the relevant dataplane.
  """
  _pyangbind_elements = {}

  

from . import probes
class openconfig_probes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-probes - based on the path /openconfig-probes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for the probes.
A probe consists on a group of tests, each test being a
source-destination pair to poll. The destination can be either
IP Address (and eventually port) or URL, depending on the
nature of the test. The test can send ICMP, UDP, TCP, or HTTP
requests.
Each test groups a list of test items, the test results
being an overall view or average of the items list.
However, the test preserves only a limited set of history
items, whose length can be controlled using the history-size.
  """
  __slots__ = ('_path_helper', '_extmethods', '__probes',)

  _yang_name = 'openconfig-probes'
  _yang_namespace = 'http://openconfig.net/yang/probes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__probes = YANGDynClass(base=probes.probes, is_container='container', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/probes', defining_module='openconfig-probes', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_probes(self):
    """
    Getter method for probes, mapped from YANG variable /probes (container)

    YANG Description: The container containing the list of probes.
    """
    return self.__probes
      
  def _set_probes(self, v, load=False):
    """
    Setter method for probes, mapped from YANG variable /probes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_probes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_probes() directly.

    YANG Description: The container containing the list of probes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=probes.probes, is_container='container', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/probes', defining_module='openconfig-probes', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """probes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=probes.probes, is_container='container', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/probes', defining_module='openconfig-probes', yang_type='container', is_config=True)""",
        })

    self.__probes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_probes(self):
    self.__probes = YANGDynClass(base=probes.probes, is_container='container', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/probes', defining_module='openconfig-probes', yang_type='container', is_config=True)

  probes = __builtin__.property(_get_probes, _set_probes)


  _pyangbind_elements = OrderedDict([('probes', probes), ])


class openconfig_probes_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-probes-types - based on the path /openconfig-probes-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the probes.
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_sr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-sr - based on the path /openconfig-mpls-sr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for MPLS with segment routing-based LSPs,
including global parameters, and LSP-specific configuration for
both constrained-path and IGP-congruent LSPs
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_ldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-ldp - based on the path /openconfig-mpls-ldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of Label Distribution Protocol global and LSP-
specific parameters for IGP-congruent LSPs.

This model reuses data items defined in the IETF YANG model for
LDP described by draft-ietf-mpls-ldp-yang-04, YANG Data Model for
MPLS LDP, following an alternate structure.

Portions of this code were derived from draft-ietf-mpls-ldp-yang-04.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_rsvp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-rsvp - based on the path /openconfig-mpls-rsvp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for RSVP-TE signaling, including global protocol
parameters and LSP-specific configuration for constrained-path
LSPs
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-types - based on the path /openconfig-mpls-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: General types for MPLS / TE data model
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_te(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-te - based on the path /openconfig-mpls-te. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration related to constrained-path LSPs and traffic
engineering.  These definitions are not specific to a particular
signaling protocol or mechanism (see related submodules for
signaling protocol-specific configuration).
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_igp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-igp - based on the path /openconfig-mpls-igp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration generic configuration parameters for IGP-congruent
LSPs
  """
  _pyangbind_elements = {}

  

class openconfig_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls - based on the path /openconfig-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides data definitions for configuration of
Multiprotocol Label Switching (MPLS) and associated protocols for
signaling and traffic engineering.

RFC 3031: Multiprotocol Label Switching Architecture

The MPLS / TE data model consists of several modules and
submodules as shown below.  The top-level MPLS module describes
the overall framework.  Three types of LSPs are supported:

i) traffic-engineered (or constrained-path)

ii) IGP-congruent (LSPs that follow the IGP path)

iii) static LSPs which are not signaled

The structure of each of these LSP configurations is defined in
corresponding submodules.  Companion modules define the relevant
configuration and operational data specific to key signaling
protocols used in operational practice.


                         +-------+
       +---------------->| MPLS  |<--------------+
       |                 +-------+               |
       |                     ^                   |
       |                     |                   |
  +----+-----+      +--------+-------+     +-----+-----+
  | TE LSPs  |      | IGP-based LSPs |     |static LSPs|
  |          |      |                |     |           |
  +----------+      +----------------+     +-----------+
      ^  ^                    ^  ^
      |  +----------------+   |  +--------+
      |                   |   |           |
      |   +------+      +-+---+-+      +--+--+
      +---+ RSVP |      |SEGMENT|      | LDP |
          +------+      |ROUTING|      +-----+
                        +-------+

  """
  _pyangbind_elements = {}

  

class openconfig_mpls_te(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-te - based on the path /openconfig-mpls-te. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration related to constrained-path LSPs and traffic
engineering.  These definitions are not specific to a particular
signaling protocol or mechanism (see related submodules for
signaling protocol-specific configuration).
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_igp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-igp - based on the path /openconfig-mpls-igp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration generic configuration parameters for IGP-congruent
LSPs
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_static(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-static - based on the path /openconfig-mpls-static. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines static LSP configuration
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_static(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-static - based on the path /openconfig-mpls-static. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines static LSP configuration
  """
  _pyangbind_elements = {}

  

class openconfig_yang_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-yang-types - based on the path /openconfig-yang-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a set of extension types to the
YANG builtin types that are used across multiple
OpenConfig models.

Portions of this code were derived from IETF RFC 6021.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_inet_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-inet-types - based on the path /openconfig-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a set of Internet address related
types for use in OpenConfig modules.

Portions of this code were derived from IETF RFC 6021.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-types - based on the path /openconfig-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a set of general type definitions that
are used across OpenConfig models. It can be imported by modules
that make use of these types.
  """
  _pyangbind_elements = {}

  

class openconfig_gnpsi_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnpsi-types - based on the path /openconfig-gnpsi-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds gRPC server type relating to gNPSI running on
a network device.
  """
  _pyangbind_elements = {}

  

class openconfig_igmp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-igmp - based on the path /openconfig-igmp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for Internet Group Management Protocol (IGMP).
  """
  _pyangbind_elements = {}

  

class openconfig_pim(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pim - based on the path /openconfig-pim. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for Protocol Independent Multicast (PIM) that supports IPv4 address family.
  """
  _pyangbind_elements = {}

  

class openconfig_igmp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-igmp-types - based on the path /openconfig-igmp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the IGMP protocol model.
  """
  _pyangbind_elements = {}

  

class openconfig_pim_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pim-types - based on the path /openconfig-pim-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the PIM protocol model.
  """
  _pyangbind_elements = {}

  

class openconfig_p4rt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-p4rt - based on the path /openconfig-p4rt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a set of extensions that provide P4Runtime (P4RT)
specific extensions to the OpenConfig data models. Specifically, these
parameters for configuration and state provide extensions that control
the P4RT service, or allow it to be used alongside other OpenConfig
data models.

The P4RT protocol specification is linked from https://p4.org/specs/
under the P4Runtime heading.
  """
  _pyangbind_elements = {}

  

from . import bfd
class openconfig_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bfd - based on the path /openconfig-bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model of Bi-Directional Forwarding Detection (BFD)
configuration and operational state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bfd',)

  _yang_name = 'openconfig-bfd'
  _yang_namespace = 'http://openconfig.net/yang/bfd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bfd = YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /bfd (container)

    YANG Description: Configuration and operational state parameters for BFD.
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.

    YANG Description: Configuration and operational state parameters for BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bfd.bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='container', is_config=True)

  bfd = __builtin__.property(_get_bfd, _set_bfd)


  _pyangbind_elements = OrderedDict([('bfd', bfd), ])


class openconfig_ptp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp-types - based on the path /openconfig-ptp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types and identities used in OpenConfig
models related to Precision Time Protocol (PTP).

IEEE code is subject to the following copyright and license:
Copyright (c) 2020 by The Institute of Electrical and Electronics
Engineers, Inc. All rights reserved.
  """
  _pyangbind_elements = {}

  

from . import ptp
class openconfig_ptp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /openconfig-ptp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines a data model for the configuration
and state of IEEE Std 1588 clocks. IEEE Std 1588 specifies the
Precision Time Protocol (PTP).

The nodes in this YANG module are designed for compatibility
with ietf-ptp.yang, the YANG data model for IEEE Std 1588-2008,
as specified in IETF RFC 8575.

NOTE regarding default value:
PTP's concept of 'initialization value' is analogous to YANG's
concept of a 'default value'. According to 8.1.3.4 of
IEEE Std 1588-2019, the initialization value for configuration
is specified in IEEE Std 1588, but that value can be overridden
by a PTP Profile specification, or by the product that
implements PTP. This makes it challenging to repeat the
specification of initialization value using a YANG 'default'
statement, because there is no straightforward mechanism for
a PTP Profile's (or product's) YANG module to import this
module and override its YANG default. Since a YANG management
client can read the default value from the operational
datastore, there is no need to re-specify the default in YANG.
The implementer of PTP refers to the relevant PTP
specifications for the default (not YANG modules).
Therefore, this YANG module avoids use of the YANG 'default'
statement.

NOTE regarding IEEE Std 1588 classification:
8.1.2 of IEEE Std 1588-2019 specifies a classification of
each data set member, which corresponds to a leaf in YANG.
The relationship between 1588 classification and
YANG 'config' (i.e., whether the leaf is read-write) is:
- 1588 static: The leaf is 'config false' (read-only).
- 1588 configurable: The leaf is 'config true', which is
 the default value for a YANG leaf.
- 1588 dynamic: A judgement is made on a member-by-member
 basis. If the member corresponds to the first item of
 8.1.2.1.2 of IEEE Std 1588-2019 (i.e., value from protocol
 only, such as log of protocol behavior), the YANG leaf
 is 'config false'. Otherwise, the member's value can be
 provided by an entity outside PTP (e.g., NETCONF or
 RESTCONF client), and therefore the YANG leaf is
 'config true'.

NOTE regarding terminology (two YANG modules):
To accommodate the need by some organizations to use the
original terminology specified by IEEE Std 1588, and the
need by some other organizations to use the alternative
terminology specified in 4.4 of IEEE Std 1588g-2022,
two YANG modules are provided by IEEE Std 1588e (MIB and
YANG Data Models). For a detailed explanation, see 15.4.2.11
of IEEE Std 1588e.
This module uses the original terminology specified by
IEEE Std 1588 (master/slave).

IEEE code is subject to the following copyright and license:
Copyright (c) 2020 by The Institute of Electrical and Electronics
Engineers, Inc. All rights reserved.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ptp',)

  _yang_name = 'openconfig-ptp'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ptp = YANGDynClass(base=ptp.ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ptp(self):
    """
    Getter method for ptp, mapped from YANG variable /ptp (container)

    YANG Description: Contains all YANG nodes for the PTP data sets. This hierarchy can be
augmented with YANG nodes for a specific vendor or PTP Profile.
    """
    return self.__ptp
      
  def _set_ptp(self, v, load=False):
    """
    Setter method for ptp, mapped from YANG variable /ptp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptp() directly.

    YANG Description: Contains all YANG nodes for the PTP data sets. This hierarchy can be
augmented with YANG nodes for a specific vendor or PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ptp.ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ptp.ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__ptp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptp(self):
    self.__ptp = YANGDynClass(base=ptp.ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

  ptp = __builtin__.property(_get_ptp, _set_ptp)


  _pyangbind_elements = OrderedDict([('ptp', ptp), ])


class openconfig_grpc_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-grpc-types - based on the path /openconfig-grpc-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds gRPC server type relating to gRPC services running on
a network device.
The GRPC_SERVICE identity is used to create an extensible list of services
that can be instantiated, with a base set defined in this module. New
services can extend the identity to be included in the list.
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_l3(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l3 - based on the path /openconfig-network-instance-l3. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains groupings which specifically relate to
Layer 3 network instance configuration and operational state
parameters.
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-policy - based on the path /openconfig-network-instance-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines routing policy statements (conditions and
actions) for the network instance model.  These statements are
generally added to the routing policy model.
  """
  _pyangbind_elements = {}

  

from . import network_instances
class openconfig_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /openconfig-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig description of a network-instance. This may be
a Layer 3 forwarding construct such as a virtual routing and
forwarding (VRF) instance, or a Layer 2 instance such as a
virtual switch instance (VSI). Mixed Layer 2 and Layer 3
instances are also supported.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instances',)

  _yang_name = 'openconfig-network-instance'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instances = YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instances(self):
    """
    Getter method for network_instances, mapped from YANG variable /network_instances (container)

    YANG Description: The L2, L3, or L2+L3 forwarding instances that are
configured on the local system
    """
    return self.__network_instances
      
  def _set_network_instances(self, v, load=False):
    """
    Setter method for network_instances, mapped from YANG variable /network_instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instances() directly.

    YANG Description: The L2, L3, or L2+L3 forwarding instances that are
configured on the local system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instances(self):
    self.__network_instances = YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  network_instances = __builtin__.property(_get_network_instances, _set_network_instances)


  _pyangbind_elements = OrderedDict([('network_instances', network_instances), ])


from . import network_instances
class openconfig_network_instance_l2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /openconfig-network-instance-l2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains groupings which specifically relate to
Layer 2 network instance configuration and operational state
parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instances',)

  _yang_name = 'openconfig-network-instance-l2'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instances = YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instances(self):
    """
    Getter method for network_instances, mapped from YANG variable /network_instances (container)

    YANG Description: The L2, L3, or L2+L3 forwarding instances that are
configured on the local system
    """
    return self.__network_instances
      
  def _set_network_instances(self, v, load=False):
    """
    Setter method for network_instances, mapped from YANG variable /network_instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instances() directly.

    YANG Description: The L2, L3, or L2+L3 forwarding instances that are
configured on the local system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instances(self):
    self.__network_instances = YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  network_instances = __builtin__.property(_get_network_instances, _set_network_instances)


  _pyangbind_elements = OrderedDict([('network_instances', network_instances), ])


class openconfig_programming_errors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-programming-errors - based on the path /openconfig-programming-errors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides detailed information about the hardware programming
state of various types of routes within a particular network instance.
It can be used to track where there are routing hardware programming errors
on a device.
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_static(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-static - based on the path /openconfig-network-instance-static. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Static configurations associated with a network instance
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_l2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /openconfig-network-instance-l2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains groupings which specifically relate to
Layer 2 network instance configuration and operational state
parameters.
  """
  _pyangbind_elements = {}

  

class openconfig_evpn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-evpn - based on the path /openconfig-evpn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in EVPN.
The model contains the configuration and state attributes
imported by the OpenConfig network instance module that is
the primary holder of these properties.

The module describes the configuration and state parameters
to support the instantiation of the MAC-VRF concept defined
in the RFC 7432: BGP MPLS-Based Ethernet VPN.
The EVPN concept allows the  Media Access Control (MAC) addresses
forwarding through the control plane on a PE.

Within the OpenConfig model, a single network instance represents
an individual MAC VRF. Whilst it is possible that there may be
cases where a single MAC VRF may support multiple broadcast
domains, this is not currently supported and requires an extension
of the model.
  """
  _pyangbind_elements = {}

  

class openconfig_evpn_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-evpn-types - based on the path /openconfig-evpn-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in EVPN
policy. It can be imported by modules that make use of EVPN
attributes
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-types - based on the path /openconfig-network-instance-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Types associated with a network instance
  """
  _pyangbind_elements = {}

  

from . import defined_sets
class openconfig_defined_sets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-defined-sets - based on the path /openconfig-defined-sets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state
data for defined sets (sets of IPv4 prefixes, sets of
IPv6 prefixes, sets of ports, etc). These sets are used,
for example, in network access control lists (i.e., filters,
rules, etc.) in the matching fields.
  """
  __slots__ = ('_path_helper', '_extmethods', '__defined_sets',)

  _yang_name = 'openconfig-defined-sets'
  _yang_namespace = 'http://openconfig.net/yang/defined-sets'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__defined_sets = YANGDynClass(base=defined_sets.defined_sets, is_container='container', yang_name="defined-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/defined-sets', defining_module='openconfig-defined-sets', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_defined_sets(self):
    """
    Getter method for defined_sets, mapped from YANG variable /defined_sets (container)

    YANG Description: Top level enclosing container for defined-set model
config and operational state data.
    """
    return self.__defined_sets
      
  def _set_defined_sets(self, v, load=False):
    """
    Setter method for defined_sets, mapped from YANG variable /defined_sets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defined_sets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defined_sets() directly.

    YANG Description: Top level enclosing container for defined-set model
config and operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=defined_sets.defined_sets, is_container='container', yang_name="defined-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/defined-sets', defining_module='openconfig-defined-sets', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defined_sets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=defined_sets.defined_sets, is_container='container', yang_name="defined-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/defined-sets', defining_module='openconfig-defined-sets', yang_type='container', is_config=True)""",
        })

    self.__defined_sets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defined_sets(self):
    self.__defined_sets = YANGDynClass(base=defined_sets.defined_sets, is_container='container', yang_name="defined-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/defined-sets', defining_module='openconfig-defined-sets', yang_type='container', is_config=True)

  defined_sets = __builtin__.property(_get_defined_sets, _set_defined_sets)


  _pyangbind_elements = OrderedDict([('defined_sets', defined_sets), ])


from . import lldp
class openconfig_lldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lldp - based on the path /openconfig-lldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for the LLDP protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lldp',)

  _yang_name = 'openconfig-lldp'
  _yang_namespace = 'http://openconfig.net/yang/lldp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lldp = YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_lldp(self):
    """
    Getter method for lldp, mapped from YANG variable /lldp (container)

    YANG Description: Top-level container for LLDP configuration and state data
    """
    return self.__lldp
      
  def _set_lldp(self, v, load=False):
    """
    Setter method for lldp, mapped from YANG variable /lldp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lldp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lldp() directly.

    YANG Description: Top-level container for LLDP configuration and state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lldp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)""",
        })

    self.__lldp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lldp(self):
    self.__lldp = YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)

  lldp = __builtin__.property(_get_lldp, _set_lldp)


  _pyangbind_elements = OrderedDict([('lldp', lldp), ])


class openconfig_lldp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lldp-types - based on the path /openconfig-lldp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the LLDP protocol model.
  """
  _pyangbind_elements = {}

  

class openconfig_qos_elements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /openconfig-qos-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated with QoS elements.  The primary elements of
the model include:

 classifiers: match packets with a specific characteristic

 forwarding groups: logical class of packets that receive
 common forwarding treatment

 queues:  collection of packets to be scheduled, including
 a queue management scheme

 schedulers: sequence of one more elements that schedule
 packets for transmission, including policer and shaper
 functions
  """
  _pyangbind_elements = {}

  

class openconfig_qos_mem_mgmt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-mem-mgmt - based on the path /openconfig-qos-mem-mgmt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated related to queue management features of QoS
particularly:

- buffer-allocation-profiles: these profiles are applied on
 a per-interface basis, and determine how memory is to be managed
 across the queues that are instantiated on the system.

- queue-management-profiles: these profiles are applied on a per-interface
 per-queue basis, and determine how packets are marked/dropped within
 the queue instantiation.
  """
  _pyangbind_elements = {}

  

class openconfig_qos_elements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /openconfig-qos-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated with QoS elements.  The primary elements of
the model include:

 classifiers: match packets with a specific characteristic

 forwarding groups: logical class of packets that receive
 common forwarding treatment

 queues:  collection of packets to be scheduled, including
 a queue management scheme

 schedulers: sequence of one more elements that schedule
 packets for transmission, including policer and shaper
 functions
  """
  _pyangbind_elements = {}

  

class openconfig_qos_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-interfaces - based on the path /openconfig-qos-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines data related to quality-of-service
configuration and operational state associated with
interfaces.
  """
  _pyangbind_elements = {}

  

class openconfig_qos_elements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /openconfig-qos-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated with QoS elements.  The primary elements of
the model include:

 classifiers: match packets with a specific characteristic

 forwarding groups: logical class of packets that receive
 common forwarding treatment

 queues:  collection of packets to be scheduled, including
 a queue management scheme

 schedulers: sequence of one more elements that schedule
 packets for transmission, including policer and shaper
 functions
  """
  _pyangbind_elements = {}

  

class openconfig_qos_mem_mgmt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-mem-mgmt - based on the path /openconfig-qos-mem-mgmt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated related to queue management features of QoS
particularly:

- buffer-allocation-profiles: these profiles are applied on
 a per-interface basis, and determine how memory is to be managed
 across the queues that are instantiated on the system.

- queue-management-profiles: these profiles are applied on a per-interface
 per-queue basis, and determine how packets are marked/dropped within
 the queue instantiation.
  """
  _pyangbind_elements = {}

  

from . import qos
class openconfig_qos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos - based on the path /openconfig-qos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to network quality-of-service.
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos',)

  _yang_name = 'openconfig-qos'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)

    YANG Description: Top-level container for QoS data
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: Top-level container for QoS data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = OrderedDict([('qos', qos), ])


from . import qos
class openconfig_qos_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-interfaces - based on the path /openconfig-qos-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines data related to quality-of-service
configuration and operational state associated with
interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos',)

  _yang_name = 'openconfig-qos-interfaces'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)

    YANG Description: Top-level container for QoS data
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: Top-level container for QoS data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = OrderedDict([('qos', qos), ])


from . import qos
class openconfig_qos_elements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /openconfig-qos-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated with QoS elements.  The primary elements of
the model include:

 classifiers: match packets with a specific characteristic

 forwarding groups: logical class of packets that receive
 common forwarding treatment

 queues:  collection of packets to be scheduled, including
 a queue management scheme

 schedulers: sequence of one more elements that schedule
 packets for transmission, including policer and shaper
 functions
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos',)

  _yang_name = 'openconfig-qos-elements'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)

    YANG Description: Top-level container for QoS data
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: Top-level container for QoS data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = OrderedDict([('qos', qos), ])


from . import qos
class openconfig_qos_mem_mgmt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-mem-mgmt - based on the path /openconfig-qos-mem-mgmt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated related to queue management features of QoS
particularly:

- buffer-allocation-profiles: these profiles are applied on
 a per-interface basis, and determine how memory is to be managed
 across the queues that are instantiated on the system.

- queue-management-profiles: these profiles are applied on a per-interface
 per-queue basis, and determine how packets are marked/dropped within
 the queue instantiation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos',)

  _yang_name = 'openconfig-qos-mem-mgmt'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)

    YANG Description: Top-level container for QoS data
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: Top-level container for QoS data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = OrderedDict([('qos', qos), ])


class openconfig_qos_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-types - based on the path /openconfig-qos-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types and identities used in OpenConfig
models related to quality-of-service (QoS)
  """
  _pyangbind_elements = {}

  

class openconfig_catalog_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-catalog-types - based on the path /openconfig-catalog-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types and identities used by the OpenConfig
YANG module catalog model.
  """
  _pyangbind_elements = {}

  

from . import organizations
class openconfig_module_catalog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-module-catalog - based on the path /openconfig-module-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a schema for cataloging and descrbing
YANG models published across various organizations.  The catalog
contains several categories of data:

* organizations -- entities that publish and/or maintain
 individual YANG modules or groups of modules

* modules -- information regarding individual YANG modules,
 including their versions, dependencies, submodules, and how
 to access them

* release bundles -- groups of modules that are compatible and
 consistent with each other (as determined by the publisher of
 of the bundle).  The release bundle does not necessarily
 correspond to a functional area, e.g., it could the entire
 set of modules published by an organization

* feature bundles -- sets of schema paths across a
 release bundle that provide a specific set of functionality

* implementations -- information about available module and/or
 bundle implementations and their status
  """
  __slots__ = ('_path_helper', '_extmethods', '__organizations',)

  _yang_name = 'openconfig-module-catalog'
  _yang_namespace = 'http://openconfig.net/yang/module-catalog'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__organizations = YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/module-catalog', defining_module='openconfig-module-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_organizations(self):
    """
    Getter method for organizations, mapped from YANG variable /organizations (container)

    YANG Description: List of organizations owning modules
    """
    return self.__organizations
      
  def _set_organizations(self, v, load=False):
    """
    Setter method for organizations, mapped from YANG variable /organizations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_organizations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_organizations() directly.

    YANG Description: List of organizations owning modules
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=organizations.organizations, is_container='container', yang_name="organizations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/module-catalog', defining_module='openconfig-module-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """organizations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/module-catalog', defining_module='openconfig-module-catalog', yang_type='container', is_config=True)""",
        })

    self.__organizations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_organizations(self):
    self.__organizations = YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/module-catalog', defining_module='openconfig-module-catalog', yang_type='container', is_config=True)

  organizations = __builtin__.property(_get_organizations, _set_organizations)


  _pyangbind_elements = OrderedDict([('organizations', organizations), ])


class openconfig_platform_healthz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-healthz - based on the path /openconfig-platform-healthz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model defines health-related variables for components
within the openconfig-platform model (which defines the
the /components hierarchy). It is designed to be used in
conjunction with the gNOI Healthz service (see
https://github.com/openconfig/gnoi/blob/main/healthz/README.md).

The health variables included in this model are streamed via
telemetry interfaces, where gNOI.Healthz is used to retrieve
further diagnostic and debugging informaton from a network
device.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /openconfig-platform-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This modules contains common groupings that are used in multiple
components within the platform module.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_fan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-fan - based on the path /openconfig-platform-fan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to FAN components in the
OpenConfig platform model.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_psu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-psu - based on the path /openconfig-platform-psu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a schema for power supply components in
the OpenConfig platform model.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-types - based on the path /openconfig-platform-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data types (e.g., YANG identities)
to support the OpenConfig component inventory model.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-ext - based on the path /openconfig-platform-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines optional extensions to the OpenConfig
platform model.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-storage - based on the path /openconfig-platform-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to STORAGE components in the
OpenConfig platform model.

 Portions of this code were derived from the following copyright holders.
 References to each copyright holder are mentioned where related content
 is used.

 NVM Express Base Specification Revision 2.0a
 https://nvmexpress.org/wp-content/uploads/NVMe-NVM-Express-2.0a-2021.07.26-Ratified.pdf
 (c) Copyright 2007 to 2021 NVM Express, Inc. ALL RIGHTS RESERVED.
 This NVM Express Base Specification, revision 2.0a is proprietary to the
 NVM Express, Inc. (also referred to as Company) and/or its successors
 and assigns.

 S.M.A.R.T. Attribute: Reallocated Sectors Count | Knowledge Base
 http://kb.acronis.com.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_fabric(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-fabric - based on the path /openconfig-platform-fabric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to FABRIC components in
the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_software(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-software - based on the path /openconfig-platform-software. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to software components in
 the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-port - based on the path /openconfig-platform-port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to PORT components in the
openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_transceiver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-transceiver - based on the path /openconfig-platform-transceiver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for transceivers (i.e., pluggable optics).  The module should be
used in conjunction with the platform model where other
physical entity data are represented.

In the platform model, a component of type=TRANSCEIVER is
expected to be a subcomponent of a PORT component.  This
module defines a concrete schema for the associated data for
components with type=TRANSCEIVER.

A transceiver will always contain physical-channel(s), however
when a line side optical-channel is present (i.e. ZR+ optics)
the physical-channel will reference its optical-channel.
In this case, the optical-channels components must be
subcomponents of the transceiver. The relationship between the
physical-channel and the optical-channel allows for multiple
optical-channels to be associated with a transceiver in addition
to ensuring certain leaves (i.e. output-power) are not duplicated
in multiple components.

If a transceiver contains a digital signal processor (DSP), such
as with ZR+ optics, the modeling will utilize hierarchical
components as follows:
PORT --> TRANSCEIVER --> OPTICAL_CHANNEL(s)
The signal will then traverse through a series of
terminal-device/logical-channels as required. The first
logical-channel connected to the OPTICAL_CHANNEL will utilize the
assignment/optical-channel leaf to create the relationship. At the
conclusion of the series of logical-channels, the logical-channel
will be associated to its host / client side based on:
* If the TRANSCEIVER is directly within a router or switch, then
 it will use the logical-channel ingress leaf to specify the
 interface it is associated with.
* If the TRANSCEIVER is within a dedicated terminal (Layer 1)
 device, then it will use the logical-channel ingress leaf to
 specify a physical-channel within a TRANSCEIVER component
 (i.e. gray optic) that it is associated with.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_linecard(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-linecard - based on the path /openconfig-platform-linecard. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to LINECARD components in
the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_controller_card(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-controller-card - based on the path /openconfig-platform-controller-card. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to CONTROLLER_CARD components in
the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_integrated_circuit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-integrated-circuit - based on the path /openconfig-platform-integrated-circuit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines extensions to the OpenConfig platform model
that apply to integrated circuit (INTEGRATED_CIRCUIT) components.
These components are generically forwarding NPUs or ASICs within
the system for which configuration or state is applicable.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_pipeline_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-pipeline-counters - based on the path /openconfig-platform-pipeline-counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provide fine grain, per-Integrated Circuit (IC), telemetry data streams
that will identify the health, any packet drops, and any errors on the IC.
With this additional telemetry, the health of the IC, packet drops and
errors, can be explicitly monitored not only on a specific router, but also
on a specific IC on a specific router. The IC is divided into 5 platform
independent sub-blocks.
 1. IC Interface Subsystem
 2. Queueing Subsystem
 3. Lookup Subsystem
 4. Host Interface
 5. Fabric Interface.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
|                                                                   |
| +---------------------------------------------------------------+ |
| | Integrated +---------------------------------------+          | |
| | Circuit    |     Host Interface                    |          | |
| |            +---------------------------------------+          | |
| |               +------------+                                  | |
| | +-----------+ |  Lookup    |                  +-------------+ | |
| | | IC        | |  Subsystem |                  |  Fabric     | | |
| | | Interface | |            |                  | Interface   | | |
| | | Subsystem | +------------+                  |             | | |
| | +-----------+                +-------------+  +-------------+ | |
| |                              | Queueing    |                  | |
| |                              | Subsystem   |                  | |
| |                              +-------------+                  | |
| |                                                               | |
| +---------------------------------------------------------------+ |
|                                                                   |
+-------------------------------------------------------------------+
Each IC implementation inside forwarding engines may have a different set of
counters. Some counters have different names but the same
functionality and can be grouped together. Most counters are different
between IC families and will have to be aggregated as generic counters. The
aggregation could mean either a specific IC counter needs to be mapped to
one of the values specified in this model, or it may require multiple IC
counters aggregated to produce one of the values in this model.
The following classes of counters will generalize the types of
statistics that are provided from each of the above 5 blocks.
 A. Packet Counters
 B. Drop Counters
 C. Error Counters
The advantage of grouping all the packet counters for all 5 blocks,
all drop counters from all 5 blocks, and all error counters from all
5 blocks, is to have the abililty to receive all drop counters from
all 5 blocks, for example, with one request.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-cpu - based on the path /openconfig-platform-cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to FAN components in the
OpenConfig platform model.
  """
  _pyangbind_elements = {}

  

from . import components
class openconfig_platform(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /openconfig-platform. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a data model for representing a system
component inventory, which can include hardware or software
elements arranged in an arbitrary structure. The primary
relationship supported by the model is containment, e.g.,
components containing subcomponents.

It is expected that this model reflects every field replacable
unit on the device at a minimum (i.e., additional information
may be supplied about non-replacable components).

Every element in the inventory is termed a 'component' with each
component expected to have a unique name and type, and optionally
a unique system-assigned identifier and FRU number.  The
uniqueness is guaranteed by the system within the device.

Components may have properties defined by the system that are
modeled as a list of key-value pairs. These may or may not be
user-configurable.  The model provides a flag for the system
to optionally indicate which properties are user configurable.

Each component also has a list of 'subcomponents' which are
references to other components. Appearance in a list of
subcomponents indicates a containment relationship as described
above.  For example, a linecard component may have a list of
references to port components that reside on the linecard.

This schema is generic to allow devices to express their own
platform-specific structure.  It may be augmented by additional
component type-specific schemas that provide a common structure
for well-known component types.  In these cases, the system is
expected to populate the common component schema, and may
optionally also represent the component and its properties in the
generic structure.

The properties for each component may include dynamic values,
e.g., in the 'state' part of the schema.  For example, a CPU
component may report its utilization, temperature, or other
physical properties.  The intent is to capture all platform-
specific physical data in one location, including inventory
(presence or absence of a component) and state (physical
attributes or status).
  """
  __slots__ = ('_path_helper', '_extmethods', '__components',)

  _yang_name = 'openconfig-platform'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__components = YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_components(self):
    """
    Getter method for components, mapped from YANG variable /components (container)

    YANG Description: Enclosing container for the components in the system.
    """
    return self.__components
      
  def _set_components(self, v, load=False):
    """
    Setter method for components, mapped from YANG variable /components (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_components is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_components() directly.

    YANG Description: Enclosing container for the components in the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """components must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__components = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_components(self):
    self.__components = YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  components = __builtin__.property(_get_components, _set_components)


  _pyangbind_elements = OrderedDict([('components', components), ])


from . import components
class openconfig_platform_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /openconfig-platform-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This modules contains common groupings that are used in multiple
components within the platform module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__components',)

  _yang_name = 'openconfig-platform-common'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__components = YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_components(self):
    """
    Getter method for components, mapped from YANG variable /components (container)

    YANG Description: Enclosing container for the components in the system.
    """
    return self.__components
      
  def _set_components(self, v, load=False):
    """
    Setter method for components, mapped from YANG variable /components (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_components is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_components() directly.

    YANG Description: Enclosing container for the components in the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """components must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__components = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_components(self):
    self.__components = YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  components = __builtin__.property(_get_components, _set_components)


  _pyangbind_elements = OrderedDict([('components', components), ])


class openconfig_ate_intf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ate-intf - based on the path /openconfig-ate-intf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines augments to the OpenConfig tree specifically for
automated test equipment (ATE) devices. These parameters are not widely
supported by non-ATE devices.
  """
  _pyangbind_elements = {}

  

from . import flows
class openconfig_ate_flow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ate-flow - based on the path /openconfig-ate-flow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines telemetry that relates to flows that are tracked
by a network device, or automated test equipment. A flow is an arbitrary
stream of packets whose definition is outside of the context of this
module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__flows',)

  _yang_name = 'openconfig-ate-flow'
  _yang_namespace = 'http://openconfig.net/yang/ate-flow'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flows = YANGDynClass(base=flows.flows, is_container='container', yang_name="flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ate-flow', defining_module='openconfig-ate-flow', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_flows(self):
    """
    Getter method for flows, mapped from YANG variable /flows (container)

    YANG Description: Flow statistics collected by the network device. A flow is defined to
be an arbitrary stream of packets whose definition is outside of the
context of the module.
    """
    return self.__flows
      
  def _set_flows(self, v, load=False):
    """
    Setter method for flows, mapped from YANG variable /flows (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flows is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flows() directly.

    YANG Description: Flow statistics collected by the network device. A flow is defined to
be an arbitrary stream of packets whose definition is outside of the
context of the module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=flows.flows, is_container='container', yang_name="flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ate-flow', defining_module='openconfig-ate-flow', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flows must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=flows.flows, is_container='container', yang_name="flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ate-flow', defining_module='openconfig-ate-flow', yang_type='container', is_config=True)""",
        })

    self.__flows = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flows(self):
    self.__flows = YANGDynClass(base=flows.flows, is_container='container', yang_name="flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ate-flow', defining_module='openconfig-ate-flow', yang_type='container', is_config=True)

  flows = __builtin__.property(_get_flows, _set_flows)


  _pyangbind_elements = OrderedDict([('flows', flows), ])


class openconfig_flexalgo(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-flexalgo - based on the path /openconfig-flexalgo. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines the configurational and operational
parameters related to IGP Flex-Algorithms
  """
  _pyangbind_elements = {}

  

class openconfig_sampling_sflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-sampling-sflow - based on the path /openconfig-sampling-sflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to data plane traffic sampling based on sFlow.

RFC 3176 - InMon Corporation's sFlow: A Method for
Monitoring Traffic in Switched and Routed Networks
  """
  _pyangbind_elements = {}

  

from . import sampling
class openconfig_sampling(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-sampling - based on the path /openconfig-sampling. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines top-level configuration and operational
state data related to traffic sampling.

For modularity purposes, the top-level sampling container provides
a natural attachment point for implementations such as sFlow, IPFix,
NETFLOW
  """
  __slots__ = ('_path_helper', '_extmethods', '__sampling',)

  _yang_name = 'openconfig-sampling'
  _yang_namespace = 'http://openconfig.net/yang/sampling'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sampling = YANGDynClass(base=sampling.sampling, is_container='container', yang_name="sampling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/sampling', defining_module='openconfig-sampling', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_sampling(self):
    """
    Getter method for sampling, mapped from YANG variable /sampling (container)

    YANG Description: Top-level container for sampling-related configuration and
operational state data
    """
    return self.__sampling
      
  def _set_sampling(self, v, load=False):
    """
    Setter method for sampling, mapped from YANG variable /sampling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sampling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sampling() directly.

    YANG Description: Top-level container for sampling-related configuration and
operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sampling.sampling, is_container='container', yang_name="sampling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/sampling', defining_module='openconfig-sampling', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sampling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sampling.sampling, is_container='container', yang_name="sampling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/sampling', defining_module='openconfig-sampling', yang_type='container', is_config=True)""",
        })

    self.__sampling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sampling(self):
    self.__sampling = YANGDynClass(base=sampling.sampling, is_container='container', yang_name="sampling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/sampling', defining_module='openconfig-sampling', yang_type='container', is_config=True)

  sampling = __builtin__.property(_get_sampling, _set_sampling)


  _pyangbind_elements = OrderedDict([('sampling', sampling), ])


from . import terminal_device
class openconfig_terminal_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /openconfig-terminal-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a terminal optics device model for
managing the terminal systems (client and line side) in a
DWDM transport network.

Elements of the model:

physical port: corresponds to a physical, pluggable client
port on the terminal device. Examples includes 10G, 40G, 100G
(e.g., 10x10G, 4x25G or 1x100G) and 400G/1T in the future.
Physical client ports will have associated operational state or
PMs.

physical channel: a physical lane or channel in the
physical client port.  Each physical client port has 1 or more
channels. An example is 100GBASE-LR4 client physical port having
4x25G channels. Channels have their own optical PMs and can be
monitored independently within a client physical port (e.g.,
channel power).  Physical client channels are defined in the
model as part of a physical client port, and are modeled
primarily for reading their PMs.

logical channel: a logical grouping of logical grooming elements
that may be assigned to subsequent grooming stages for
multiplexing / de-multiplexing, or to an optical channel for
line side transmission.  The logical channels can represent, for
example, an ODU/OTU logical packing of the client
data onto the line side.  Tributaries are similarly logical
groupings of demand that can be represented in this structure and
assigned to an optical channel.  Note that different types of
logical channels may be present, each with their corresponding
PMs.

optical channel:  corresponds to an optical carrier and is
assigned a wavelength/frequency.  Optical channels have PMs
such as power, BER, and operational mode.

Directionality:

To maintain simplicity in the model, the configuration is
described from client-to-line direction.  The assumption is that
equivalent reverse configuration is implicit, resulting in
the same line-to-client configuration.

Physical layout:

The model does not assume a particular physical layout of client
and line ports on the terminal device (e.g., such as number of
ports per linecard, separate linecards for client and line ports,
etc.).
  """
  __slots__ = ('_path_helper', '_extmethods', '__terminal_device',)

  _yang_name = 'openconfig-terminal-device'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__terminal_device = YANGDynClass(base=terminal_device.terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_terminal_device(self):
    """
    Getter method for terminal_device, mapped from YANG variable /terminal_device (container)

    YANG Description: Top-level container for the terminal device
    """
    return self.__terminal_device
      
  def _set_terminal_device(self, v, load=False):
    """
    Setter method for terminal_device, mapped from YANG variable /terminal_device (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminal_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminal_device() directly.

    YANG Description: Top-level container for the terminal device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=terminal_device.terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminal_device must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=terminal_device.terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__terminal_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminal_device(self):
    self.__terminal_device = YANGDynClass(base=terminal_device.terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  terminal_device = __builtin__.property(_get_terminal_device, _set_terminal_device)


  _pyangbind_elements = OrderedDict([('terminal_device', terminal_device), ])


from . import connections
class openconfig_transport_line_connectivity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-connectivity - based on the path /openconfig-transport-line-connectivity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes the device-level connectivity
(e.g., internal port-to-port) for optical transport line
system elements such as wavelength routers (ROADMs) and
amplifiers. All connections are uni-directional. Note that
this model explicitly does not intend to model or provide
a path to any higher layer topology modeling and is only
for modeling internal links
  """
  __slots__ = ('_path_helper', '_extmethods', '__connections',)

  _yang_name = 'openconfig-transport-line-connectivity'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-transport-line-connectivity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__connections = YANGDynClass(base=connections.connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_connections(self):
    """
    Getter method for connections, mapped from YANG variable /connections (container)

    YANG Description: Enclosing container for line system connections list
    """
    return self.__connections
      
  def _set_connections(self, v, load=False):
    """
    Setter method for connections, mapped from YANG variable /connections (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connections is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connections() directly.

    YANG Description: Enclosing container for line system connections list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=connections.connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connections must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=connections.connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)""",
        })

    self.__connections = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connections(self):
    self.__connections = YANGDynClass(base=connections.connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)

  connections = __builtin__.property(_get_connections, _set_connections)


  _pyangbind_elements = OrderedDict([('connections', connections), ])


from . import optical_attenuator
class openconfig_optical_attenuator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /openconfig-optical-attenuator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for variable optical attenuators, deployed as part of a transport
line system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optical_attenuator',)

  _yang_name = 'openconfig-optical-attenuator'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_attenuator = YANGDynClass(base=optical_attenuator.optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_optical_attenuator(self):
    """
    Getter method for optical_attenuator, mapped from YANG variable /optical_attenuator (container)

    YANG Description: Enclosing container for attenuators
    """
    return self.__optical_attenuator
      
  def _set_optical_attenuator(self, v, load=False):
    """
    Setter method for optical_attenuator, mapped from YANG variable /optical_attenuator (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_attenuator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_attenuator() directly.

    YANG Description: Enclosing container for attenuators
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=optical_attenuator.optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_attenuator must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=optical_attenuator.optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)""",
        })

    self.__optical_attenuator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_attenuator(self):
    self.__optical_attenuator = YANGDynClass(base=optical_attenuator.optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

  optical_attenuator = __builtin__.property(_get_optical_attenuator, _set_optical_attenuator)


  _pyangbind_elements = OrderedDict([('optical_attenuator', optical_attenuator), ])


from . import wavelength_router
class openconfig_wavelength_router(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /openconfig-wavelength-router. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for an optical transport line system node, or ROADM (incl. CDC
ROADMs, WSS, Dynamic Gain Equalizer/DGE).

Nodes are modeled as a configurable switching element with
ingress and egress ports, as well as a number of add/drop ports
that can be set up to direct portions of the optical spectrum
to the appropriate degrees.

In relation to configuring target spectrum powers, there
are two, non-overlapping, configuration possibilities that are
supported.
1. Non-noise loaded wavelength router:
  - The target spectrum powers are configured on each media
    channel.
2. Noise-loaded wavelength router:
  - The target spectrum power values will be configured as a
    target spectrum power profile over the full spectrum instead
    of individual media channels.
  """
  __slots__ = ('_path_helper', '_extmethods', '__wavelength_router',)

  _yang_name = 'openconfig-wavelength-router'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__wavelength_router = YANGDynClass(base=wavelength_router.wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_wavelength_router(self):
    """
    Getter method for wavelength_router, mapped from YANG variable /wavelength_router (container)

    YANG Description: Top-level container for wavelength router device
    """
    return self.__wavelength_router
      
  def _set_wavelength_router(self, v, load=False):
    """
    Setter method for wavelength_router, mapped from YANG variable /wavelength_router (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wavelength_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wavelength_router() directly.

    YANG Description: Top-level container for wavelength router device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=wavelength_router.wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wavelength_router must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=wavelength_router.wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__wavelength_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wavelength_router(self):
    self.__wavelength_router = YANGDynClass(base=wavelength_router.wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  wavelength_router = __builtin__.property(_get_wavelength_router, _set_wavelength_router)


  _pyangbind_elements = OrderedDict([('wavelength_router', wavelength_router), ])


class openconfig_transport_line_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-common - based on the path /openconfig-transport-line-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines common data elements for OpenConfig data
models for optical transport line system elements, such as
amplifiers and ROADMs (wavelength routers).
  """
  _pyangbind_elements = {}

  

class openconfig_transport_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-types - based on the path /openconfig-transport-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general type definitions and identities
for optical transport models.
  """
  _pyangbind_elements = {}

  

from . import channel_monitors
class openconfig_channel_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /openconfig-channel-monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes operational state data for an optical
channel monitor (OCM) for optical transport line system
elements such as wavelength routers (ROADMs) and amplifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel_monitors',)

  _yang_name = 'openconfig-channel-monitor'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel_monitors = YANGDynClass(base=channel_monitors.channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_channel_monitors(self):
    """
    Getter method for channel_monitors, mapped from YANG variable /channel_monitors (container)

    YANG Description: Top-level container for optical channel monitors
    """
    return self.__channel_monitors
      
  def _set_channel_monitors(self, v, load=False):
    """
    Setter method for channel_monitors, mapped from YANG variable /channel_monitors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_monitors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_monitors() directly.

    YANG Description: Top-level container for optical channel monitors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=channel_monitors.channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_monitors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=channel_monitors.channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__channel_monitors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_monitors(self):
    self.__channel_monitors = YANGDynClass(base=channel_monitors.channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

  channel_monitors = __builtin__.property(_get_channel_monitors, _set_channel_monitors)


  _pyangbind_elements = OrderedDict([('channel_monitors', channel_monitors), ])


from . import optical_amplifier
class openconfig_optical_amplifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /openconfig-optical-amplifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for optical amplifiers, deployed as part of a transport
line system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optical_amplifier',)

  _yang_name = 'openconfig-optical-amplifier'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_amplifier = YANGDynClass(base=optical_amplifier.optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_optical_amplifier(self):
    """
    Getter method for optical_amplifier, mapped from YANG variable /optical_amplifier (container)

    YANG Description: Enclosing container for amplifiers and supervisory channels
    """
    return self.__optical_amplifier
      
  def _set_optical_amplifier(self, v, load=False):
    """
    Setter method for optical_amplifier, mapped from YANG variable /optical_amplifier (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_amplifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_amplifier() directly.

    YANG Description: Enclosing container for amplifiers and supervisory channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=optical_amplifier.optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_amplifier must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=optical_amplifier.optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__optical_amplifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_amplifier(self):
    self.__optical_amplifier = YANGDynClass(base=optical_amplifier.optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  optical_amplifier = __builtin__.property(_get_optical_amplifier, _set_optical_amplifier)


  _pyangbind_elements = OrderedDict([('optical_amplifier', optical_amplifier), ])


from . import aps
class openconfig_transport_line_protection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /openconfig-transport-line-protection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for optical line protection elements, deployed as part of a
transport line system. An Automatic Protection Switch (APS)
is typically installed in the same device as the amplifiers
and wave-router, however an APS can also be a standalone
device. In both scenarios, it serves the same purpose of
providing protection using two dark fiber pairs to ensure the
amplifiers can still receive a signal if one of the two fiber
pairs is broken. The APS port details and directionality are
shown below. The three major attributes, together with their
modifiers, define the behavior of the APS and can be prioritized
in the descending order as shown in the following table
  """
  __slots__ = ('_path_helper', '_extmethods', '__aps',)

  _yang_name = 'openconfig-transport-line-protection'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aps = YANGDynClass(base=aps.aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_aps(self):
    """
    Getter method for aps, mapped from YANG variable /aps (container)

    YANG Description: Top level grouping for automatic protection switch data
    """
    return self.__aps
      
  def _set_aps(self, v, load=False):
    """
    Setter method for aps, mapped from YANG variable /aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aps() directly.

    YANG Description: Top level grouping for automatic protection switch data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=aps.aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=aps.aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aps(self):
    self.__aps = YANGDynClass(base=aps.aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  aps = __builtin__.property(_get_aps, _set_aps)


  _pyangbind_elements = OrderedDict([('aps', aps), ])


class openconfig_openflow_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-openflow-types - based on the path /openconfig-openflow-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the Openflow configuration
and operational state model.
  """
  _pyangbind_elements = {}

  

class openconfig_openflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-openflow - based on the path /openconfig-openflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data for
Openflow.
  """
  _pyangbind_elements = {}

  

from . import lacp
class openconfig_lacp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lacp - based on the path /openconfig-lacp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes configuration and operational state
data for Link Aggregation Control Protocol (LACP) for
managing aggregate interfaces.   It works in conjunction with
the OpenConfig interfaces and aggregate interfaces models.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lacp',)

  _yang_name = 'openconfig-lacp'
  _yang_namespace = 'http://openconfig.net/yang/lacp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lacp = YANGDynClass(base=lacp.lacp, is_container='container', yang_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_lacp(self):
    """
    Getter method for lacp, mapped from YANG variable /lacp (container)

    YANG Description: Configuration and operational state data for LACP protocol
operation on the aggregate interface
    """
    return self.__lacp
      
  def _set_lacp(self, v, load=False):
    """
    Setter method for lacp, mapped from YANG variable /lacp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lacp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lacp() directly.

    YANG Description: Configuration and operational state data for LACP protocol
operation on the aggregate interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lacp.lacp, is_container='container', yang_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lacp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lacp.lacp, is_container='container', yang_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=True)""",
        })

    self.__lacp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lacp(self):
    self.__lacp = YANGDynClass(base=lacp.lacp, is_container='container', yang_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=True)

  lacp = __builtin__.property(_get_lacp, _set_lacp)


  _pyangbind_elements = OrderedDict([('lacp', lacp), ])


class openconfig_spanning_tree_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-spanning-tree-types - based on the path /openconfig-spanning-tree-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the
spanning-tree protocol model.
  """
  _pyangbind_elements = {}

  

from . import stp
class openconfig_spanning_tree(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-spanning-tree - based on the path /openconfig-spanning-tree. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for the spanning tree protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stp',)

  _yang_name = 'openconfig-spanning-tree'
  _yang_namespace = 'http://openconfig.net/yang/spanning-tree'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stp = YANGDynClass(base=stp.stp, is_container='container', yang_name="stp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/spanning-tree', defining_module='openconfig-spanning-tree', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_stp(self):
    """
    Getter method for stp, mapped from YANG variable /stp (container)

    YANG Description: Top-level container for spanning tree configuration and
state data
    """
    return self.__stp
      
  def _set_stp(self, v, load=False):
    """
    Setter method for stp, mapped from YANG variable /stp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stp() directly.

    YANG Description: Top-level container for spanning tree configuration and
state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=stp.stp, is_container='container', yang_name="stp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/spanning-tree', defining_module='openconfig-spanning-tree', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=stp.stp, is_container='container', yang_name="stp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/spanning-tree', defining_module='openconfig-spanning-tree', yang_type='container', is_config=True)""",
        })

    self.__stp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stp(self):
    self.__stp = YANGDynClass(base=stp.stp, is_container='container', yang_name="stp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/spanning-tree', defining_module='openconfig-spanning-tree', yang_type='container', is_config=True)

  stp = __builtin__.property(_get_stp, _set_stp)


  _pyangbind_elements = OrderedDict([('stp', stp), ])


class openconfig_pcep(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pcep - based on the path /openconfig-pcep. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
relating to Path Computation Element Protocol (PCEP) for communications
between a network element (router) acting as PCC and a PCE server,
according to RFC4655 definitions:

-PCC:  Path Computation Client; any client application requesting a
 path computation to be performed by a Path Computation Element.

-PCE:  Path Computation Element; an entity (component, application, or
 network node) that is capable of computing a network path or route
 based on a network graph and applying computational constraints.

Also according to RFC4655, a PCE can be either stateful or
stateless. In the former case, there is a strict synchronization
between the PCE and not only the network states (in term of
topology and resource information), but also the set of computed
paths and reserved resources in use in the network. Conversely,
stateless PCEs do not have to remember any computed path and each
set of request(s) is processed independently of each other. For
example, stateless PCEs may compute paths based on current TED
information, which could be out of sync with actual network state
given other recent PCE-computed paths changes.

On the other hand, RFC8051 defines for Stateful PCE two modes of
operation:

  -Passive Stateful PCE:  a PCE that uses LSP state information
   learned from PCCs to optimize path computations.  It does not
   actively update LSP state. A PCC maintains synchronization with
   the PCE.

  -Active Stateful PCE:  a PCE that may issue recommendations to
   the network. For example, an Active Stateful PCE may use the
   Delegation mechanism to update.

 LSP parameters in those PCCs that delegate control over their LSPs to
 the PCE.
  """
  _pyangbind_elements = {}

  

from . import ha_groups
class openconfig_fw_high_availability(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-fw-high-availability - based on the path /openconfig-fw-high-availability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model used to configure & monitor firewall High Availability(HA).
The model is comprised primarily of the following sections -
- Various global config parameters
(such as ha-group-id, ha-mode etc.)
- Control link configuration parameters
(control link is used to exchange HA control msgs)
- Data link configuration parameters
(data link is used to exchange information for seamless failover)
- HA timers

This model also imports/uses the link-monitoring module, to
determine  health of firewall cluster based on the status of the
interfaces being  monitored. Please see that module description
for additional details
  """
  __slots__ = ('_path_helper', '_extmethods', '__ha_groups',)

  _yang_name = 'openconfig-fw-high-availability'
  _yang_namespace = 'http://openconfig.net/yang/oc-fw-ha'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ha_groups = YANGDynClass(base=ha_groups.ha_groups, is_container='container', yang_name="ha-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ha_groups(self):
    """
    Getter method for ha_groups, mapped from YANG variable /ha_groups (container)

    YANG Description: Top level container for HA groups
    """
    return self.__ha_groups
      
  def _set_ha_groups(self, v, load=False):
    """
    Setter method for ha_groups, mapped from YANG variable /ha_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_groups() directly.

    YANG Description: Top level container for HA groups
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ha_groups.ha_groups, is_container='container', yang_name="ha-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ha_groups.ha_groups, is_container='container', yang_name="ha-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='container', is_config=True)""",
        })

    self.__ha_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_groups(self):
    self.__ha_groups = YANGDynClass(base=ha_groups.ha_groups, is_container='container', yang_name="ha-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='container', is_config=True)

  ha_groups = __builtin__.property(_get_ha_groups, _set_ha_groups)


  _pyangbind_elements = OrderedDict([('ha_groups', ha_groups), ])


class openconfig_fw_link_monitoring(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-fw-link-monitoring - based on the path /openconfig-fw-link-monitoring. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model defines interface groups and corresponding monitoring
policies for firewall HA groups.  It also provides modeling for a
global health monitoring policy for the HA group.
  """
  _pyangbind_elements = {}

  

class openconfig_codegen_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-codegen-extensions - based on the path /openconfig-codegen-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides OpenConfig-specific code generation extensions to the
YANG language.
  """
  _pyangbind_elements = {}

  

class openconfig_metadata(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-metadata - based on the path /openconfig-metadata. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines metadata types that are defined by
the OpenConfig group.
  """
  _pyangbind_elements = {}

  

class openconfig_vlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-vlan - based on the path /openconfig-vlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state variables for VLANs,
in addition to VLAN parameters associated with interfaces
  """
  _pyangbind_elements = {}

  

class openconfig_vlan_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-vlan-types - based on the path /openconfig-vlan-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state variables for VLANs,
in addition to VLAN parameters associated with interfaces
  """
  _pyangbind_elements = {}

  

class openconfig_system_utilization(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-utilization - based on the path /openconfig-system-utilization. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state for
system wide resource utilization thresholds.
  """
  _pyangbind_elements = {}

  

class openconfig_system_controlplane(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-controlplane - based on the path /openconfig-system-controlplane. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state relating to
policies for traffic destined to the system's control-plane.
Particularly, it allows for mechanisms to:
 - apply an ACL that forwards or drops traffic towards the control-plane.
 - classify traffic that is destined to the control-plane according to
   a QoS classifier.
 - schedule traffic that has been forwarded towards the control-plane,
   to allow for policies such as rate limits to be applied.
The configured policies apply generically to all control-planes that
exist within the system, and should be mapped to the internal interfaces
via which packets are forwarded to control-plane modules.
When a packet is received at an input interface - it is classified into a
forwarding group which drains to a specific queue. If this input mapping
is sufficient, the CPU-facing interface uses the specified scheduler
to determine how to drain queues. If more granular remapping is required
(e.g., to classify control-plane traffic more granularly), a user specifies
an alternate classifier that is used to reclassify traffic into
a new set of forwarding-groups (and hence queues) that can subsequently
be scheduled by the specified scheduler.
The specified control-plane ACL is applied to traffic received by the
control-plane of the system.
  """
  _pyangbind_elements = {}

  

class openconfig_hashing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-hashing - based on the path /openconfig-hashing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing hashing policies that would be referenced by the
interfaces model.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-types - based on the path /openconfig-aaa-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines shared types for data related to AAA
(authentication, authorization, accounting).
  """
  _pyangbind_elements = {}

  

class openconfig_system_terminal(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-terminal - based on the path /openconfig-system-terminal. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to remote terminal services such as ssh and telnet.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa - based on the path /openconfig-aaa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to authorization, authentication, and accounting (AAA)
management.

Portions of this model reuse data definitions or structure from
RFC 7317 - A YANG Data Model for System Management
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_tacacs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-tacacs - based on the path /openconfig-aaa-tacacs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the TACACS+ protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_radius(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-radius - based on the path /openconfig-aaa-radius. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the RADIUS protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_license(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-license - based on the path /openconfig-license. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational
state data for licenses.
  """
  _pyangbind_elements = {}

  

class openconfig_alarm_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-alarm-types - based on the path /openconfig-alarm-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines operational state data related to alarms
that the device is reporting.

This model reuses some data items defined in the draft IETF
YANG Alarm Module:
https://tools.ietf.org/html/draft-vallin-netmod-alarm-module-02

Portions of this code were derived from the draft IETF YANG Alarm
Module. Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_system_grpc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-grpc - based on the path /openconfig-system-grpc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state relating to gRPC
services running on a network device. The GRPC_SERVICE identity is used
to create an extensible list of services that can be instantiated, with
a base set defined in this module. New services can extend the identity
to be included in the list.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_tacacs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-tacacs - based on the path /openconfig-aaa-tacacs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the TACACS+ protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_alarms(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-alarms - based on the path /openconfig-alarms. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines operational state data related to alarms
that the device is reporting.

This model reuses some data items defined in the draft IETF
YANG Alarm Module:
https://tools.ietf.org/html/draft-vallin-netmod-alarm-module-02

Portions of this code were derived from the draft IETF YANG Alarm
Module. Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_procmon(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-procmon - based on the path /openconfig-procmon. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides data definitions for process health
monitoring of one or more processes running on the system.
  """
  _pyangbind_elements = {}

  

from . import system
class openconfig_system(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system - based on the path /openconfig-system. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing system-wide services and functions on
network devices.

Portions of this code were derived from IETF RFC 7317.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  __slots__ = ('_path_helper', '_extmethods', '__system',)

  _yang_name = 'openconfig-system'
  _yang_namespace = 'http://openconfig.net/yang/system'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__system = YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_system(self):
    """
    Getter method for system, mapped from YANG variable /system (container)

    YANG Description: Enclosing container for system-related configuration and
operational state data
    """
    return self.__system
      
  def _set_system(self, v, load=False):
    """
    Setter method for system, mapped from YANG variable /system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system() directly.

    YANG Description: Enclosing container for system-related configuration and
operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system(self):
    self.__system = YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)

  system = __builtin__.property(_get_system, _set_system)


  _pyangbind_elements = OrderedDict([('system', system), ])


class openconfig_messages(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-messages - based on the path /openconfig-messages. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to Syslog messages that a device may generate.

These messages are historically obtained through the Syslog
transport, however this module allows for obtaining them through
an alternative transport, such as a Subscribe operation over an
RPC.

This module does not usurp traditional syslog servers, which may
still be configured through the
/yang/system/openconfig-system.yang model, rather it provies the
Operator with an alternative method of consuming messages.
  """
  _pyangbind_elements = {}

  

class openconfig_system_logging(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-logging - based on the path /openconfig-system-logging. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for common logging facilities on network systems.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_radius(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-radius - based on the path /openconfig-aaa-radius. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the RADIUS protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_system_bootz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-bootz - based on the path /openconfig-system-bootz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state relating to bootz
service running on a network device.
  """
  _pyangbind_elements = {}

  

from . import ethernet_segments
class openconfig_ethernet_segments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /openconfig-ethernet-segments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains definitions of ethernet segements.
The ethernet segments are used in EVPN services are
defined for the whole device
  """
  __slots__ = ('_path_helper', '_extmethods', '__ethernet_segments',)

  _yang_name = 'openconfig-ethernet-segments'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ethernet_segments = YANGDynClass(base=ethernet_segments.ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ethernet_segments(self):
    """
    Getter method for ethernet_segments, mapped from YANG variable /ethernet_segments (container)

    YANG Description: Top-level container for ethernet segments. An Ethernet Segment
is referenced by a name and an ESI
    """
    return self.__ethernet_segments
      
  def _set_ethernet_segments(self, v, load=False):
    """
    Setter method for ethernet_segments, mapped from YANG variable /ethernet_segments (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_segments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_segments() directly.

    YANG Description: Top-level container for ethernet segments. An Ethernet Segment
is referenced by a name and an ESI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ethernet_segments.ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_segments must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ethernet_segments.ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)""",
        })

    self.__ethernet_segments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_segments(self):
    self.__ethernet_segments = YANGDynClass(base=ethernet_segments.ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)

  ethernet_segments = __builtin__.property(_get_ethernet_segments, _set_ethernet_segments)


  _pyangbind_elements = OrderedDict([('ethernet_segments', ethernet_segments), ])


class openconfig_gnsi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi - based on the path /openconfig-gnsi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a set of extensions that provide gNSI (the gRPC
Network Security Interface) specific extensions to the OpenConfig data models.
Specifically, the parameters for the configuration of the service, and
configuration and state are added.

The gNSI protobufs and documentation are published at
https://github.com/openconfig/gnsi.
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_pathz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-pathz - based on the path /openconfig-gnsi-pathz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a data model for the metadata of
OpenConfig-path-based authorization policies installed on a networking
device.
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_acctz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-acctz - based on the path /openconfig-gnsi-acctz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides counters of gNSI accountZ requests and responses and
the quantity of data transferred.
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_credentialz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-credentialz - based on the path /openconfig-gnsi-credentialz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a data model for the metadata of SSH and console
credentials installed on a networking device.

The following leaves MUST be treated as invalid when the gNSI server is
enabled and credentialz is supported by the implementation:
 /system/aaa/authentication/users/user/config/ssh-key
 /system/aaa/authentication/users/user/state/ssh-key
 /system/aaa/authentication/users/user/config/password
 /system/aaa/authentication/users/user/state/password
 /system/aaa/authentication/users/user/config/password-hashed
 /system/aaa/authentication/users/user/state/password-hashed
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_certz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-certz - based on the path /openconfig-gnsi-certz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a data model for the metadata of gRPC credentials
installed on a networking device.
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_authz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-authz - based on the path /openconfig-gnsi-authz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a data model for the metadata of the gRPC
authorization policies installed on a networking device.
  """
  _pyangbind_elements = {}

  

from . import keychains
class openconfig_keychain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-keychain - based on the path /openconfig-keychain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for keychain configuration
and management. These keys can be changed frequently to
increase security in long-lived connections. A keychain can be used
for authenticaion in a number of scenarios, including in routing protocols
(e.g. BGP, IS-IS, OSPF).  A keychain provides a solution for storing
a number of different keys, each key string value is associated with a
specific key id, name, the lifetime that the key is valid and an
encryption algorithm.

This model defines a central location for defining named keychains,
which may be then referenced by other models such as routing protocol
management.
  """
  __slots__ = ('_path_helper', '_extmethods', '__keychains',)

  _yang_name = 'openconfig-keychain'
  _yang_namespace = 'http://openconfig.net/yang/oc-keychain'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__keychains = YANGDynClass(base=keychains.keychains, is_container='container', yang_name="keychains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-keychain', defining_module='openconfig-keychain', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_keychains(self):
    """
    Getter method for keychains, mapped from YANG variable /keychains (container)

    YANG Description: This container defines keychains.
    """
    return self.__keychains
      
  def _set_keychains(self, v, load=False):
    """
    Setter method for keychains, mapped from YANG variable /keychains (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keychains is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keychains() directly.

    YANG Description: This container defines keychains.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=keychains.keychains, is_container='container', yang_name="keychains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-keychain', defining_module='openconfig-keychain', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keychains must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=keychains.keychains, is_container='container', yang_name="keychains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-keychain', defining_module='openconfig-keychain', yang_type='container', is_config=True)""",
        })

    self.__keychains = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keychains(self):
    self.__keychains = YANGDynClass(base=keychains.keychains, is_container='container', yang_name="keychains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-keychain', defining_module='openconfig-keychain', yang_type='container', is_config=True)

  keychains = __builtin__.property(_get_keychains, _set_keychains)


  _pyangbind_elements = OrderedDict([('keychains', keychains), ])


class openconfig_keychain_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-keychain-types - based on the path /openconfig-keychain-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in
keychain-based authentication.
  """
  _pyangbind_elements = {}

  

class openconfig_local_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-local-routing - based on the path /openconfig-local-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes configuration and operational state data
for routes that are locally generated, i.e., not created by
dynamic routing protocols.  These include static routes, locally
created aggregate routes for reducing the number of constituent
routes that must be advertised, summary routes for IGPs, etc.

This model expresses locally generated routes as generically as
possible, avoiding configuration of protocol-specific attributes
at the time of route creation.  This is primarily to avoid
assumptions about how underlying router implementations handle
route attributes in various routing table data structures they
maintain.  Hence, the definition of locally generated routes
essentially creates 'bare' routes that do not have any protocol-
specific attributes.

When protocol-specific attributes must be attached to a route
(e.g., communities on a locally defined route meant to be
advertised via BGP), the attributes should be attached via a
protocol-specific policy after importing the route into the
protocol for distribution (again via routing policy).
  """
  _pyangbind_elements = {}

  

from . import telemetry_system
class openconfig_telemetry(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-telemetry - based on the path /openconfig-telemetry. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data model which creates the configuration for the telemetry
systems and functions on the device.
  """
  __slots__ = ('_path_helper', '_extmethods', '__telemetry_system',)

  _yang_name = 'openconfig-telemetry'
  _yang_namespace = 'http://openconfig.net/yang/telemetry'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__telemetry_system = YANGDynClass(base=telemetry_system.telemetry_system, is_container='container', yang_name="telemetry-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/telemetry', defining_module='openconfig-telemetry', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_telemetry_system(self):
    """
    Getter method for telemetry_system, mapped from YANG variable /telemetry_system (container)

    YANG Description: Top level configuration and state for the
device's telemetry system.
    """
    return self.__telemetry_system
      
  def _set_telemetry_system(self, v, load=False):
    """
    Setter method for telemetry_system, mapped from YANG variable /telemetry_system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telemetry_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telemetry_system() directly.

    YANG Description: Top level configuration and state for the
device's telemetry system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=telemetry_system.telemetry_system, is_container='container', yang_name="telemetry-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/telemetry', defining_module='openconfig-telemetry', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telemetry_system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=telemetry_system.telemetry_system, is_container='container', yang_name="telemetry-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/telemetry', defining_module='openconfig-telemetry', yang_type='container', is_config=True)""",
        })

    self.__telemetry_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telemetry_system(self):
    self.__telemetry_system = YANGDynClass(base=telemetry_system.telemetry_system, is_container='container', yang_name="telemetry-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/telemetry', defining_module='openconfig-telemetry', yang_type='container', is_config=True)

  telemetry_system = __builtin__.property(_get_telemetry_system, _set_telemetry_system)


  _pyangbind_elements = OrderedDict([('telemetry_system', telemetry_system), ])


class openconfig_telemetry_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-telemetry-types - based on the path /openconfig-telemetry-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines type and identities used by the OpenConfig
telemetry model.
  """
  _pyangbind_elements = {}

  

from . import relay_agent
class openconfig_relay_agent(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-relay-agent - based on the path /openconfig-relay-agent. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a model for configuration and operational
state related to relay agents typically used for DHCP and BOOTP
packets.  The supports both DHCP and DHCPv6 and device-wide and
per-interface settings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__relay_agent',)

  _yang_name = 'openconfig-relay-agent'
  _yang_namespace = 'http://openconfig.net/yang/relay-agent'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__relay_agent = YANGDynClass(base=relay_agent.relay_agent, is_container='container', yang_name="relay-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/relay-agent', defining_module='openconfig-relay-agent', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_relay_agent(self):
    """
    Getter method for relay_agent, mapped from YANG variable /relay_agent (container)

    YANG Description: Top level container for relay-agent configuration and
operational state data
    """
    return self.__relay_agent
      
  def _set_relay_agent(self, v, load=False):
    """
    Setter method for relay_agent, mapped from YANG variable /relay_agent (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relay_agent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relay_agent() directly.

    YANG Description: Top level container for relay-agent configuration and
operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=relay_agent.relay_agent, is_container='container', yang_name="relay-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/relay-agent', defining_module='openconfig-relay-agent', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relay_agent must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=relay_agent.relay_agent, is_container='container', yang_name="relay-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/relay-agent', defining_module='openconfig-relay-agent', yang_type='container', is_config=True)""",
        })

    self.__relay_agent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relay_agent(self):
    self.__relay_agent = YANGDynClass(base=relay_agent.relay_agent, is_container='container', yang_name="relay-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/relay-agent', defining_module='openconfig-relay-agent', yang_type='container', is_config=True)

  relay_agent = __builtin__.property(_get_relay_agent, _set_relay_agent)


  _pyangbind_elements = OrderedDict([('relay_agent', relay_agent), ])


from . import macsec
class openconfig_macsec(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-macsec - based on the path /openconfig-macsec. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state data for
MACsec IEEE Std 802.1AE-2018.
  """
  __slots__ = ('_path_helper', '_extmethods', '__macsec',)

  _yang_name = 'openconfig-macsec'
  _yang_namespace = 'http://openconfig.net/yang/macsec'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__macsec = YANGDynClass(base=macsec.macsec, is_container='container', yang_name="macsec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/macsec', defining_module='openconfig-macsec', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_macsec(self):
    """
    Getter method for macsec, mapped from YANG variable /macsec (container)

    YANG Description: The MACsec
    """
    return self.__macsec
      
  def _set_macsec(self, v, load=False):
    """
    Setter method for macsec, mapped from YANG variable /macsec (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_macsec is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_macsec() directly.

    YANG Description: The MACsec
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=macsec.macsec, is_container='container', yang_name="macsec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/macsec', defining_module='openconfig-macsec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """macsec must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=macsec.macsec, is_container='container', yang_name="macsec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/macsec', defining_module='openconfig-macsec', yang_type='container', is_config=True)""",
        })

    self.__macsec = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_macsec(self):
    self.__macsec = YANGDynClass(base=macsec.macsec, is_container='container', yang_name="macsec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/macsec', defining_module='openconfig-macsec', yang_type='container', is_config=True)

  macsec = __builtin__.property(_get_macsec, _set_macsec)


  _pyangbind_elements = OrderedDict([('macsec', macsec), ])


class openconfig_macsec_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-macsec-types - based on the path /openconfig-macsec-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the MACsec configuration
and operational state model.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-global - based on the path /openconfig-bgp-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
global context of the OpenConfig BGP module
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp - based on the path /openconfig-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for BGP protocol
configuration.It is a limited subset of all of the configuration
parameters available in the variety of vendor implementations,
hence it is expected that it would be augmented with vendor-
specific configuration data as needed. Additional modules or
submodules to handle other aspects of BGP configuration,
including policy, VRFs, VPNs, and additional address families
are also expected.

This model supports the following BGP configuration level
hierarchy:

 BGP
   |
   +-> [ global BGP configuration ]
     +-> AFI / SAFI global
   +-> peer group
     +-> [ peer group config ]
     +-> AFI / SAFI [ per-AFI overrides ]
   +-> neighbor
     +-> [ neighbor config ]
     +-> [ optional pointer to peer-group ]
     +-> AFI / SAFI [ per-AFI overrides ]

Most BGP features can be configured at multiple levels in the BGP
configuration level hierarchy. The common inheritance model allows
the more specific configuration (e.g. neighbor) to inherit from or
override the less specific configuration (e.g. global).
Leaf present at one level overrides leafs present at higher levels,
whereas leaf not present inherits its value from the leaf present
at the next higher level in the hierarchy.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-neighbor - based on the path /openconfig-bgp-neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
neighbor context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-global - based on the path /openconfig-bgp-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
global context of the OpenConfig BGP module
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-policy - based on the path /openconfig-bgp-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains data definitions for BGP routing policy.
It augments the base routing-policy module with BGP-specific
options for conditions and actions.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-neighbor - based on the path /openconfig-bgp-neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
neighbor context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_errors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-errors - based on the path /openconfig-bgp-errors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines BGP NOTIFICATION message error codes
and subcodes
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-types - based on the path /openconfig-bgp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in BGP
policy. It can be imported by modules that make use of BGP
attributes
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_errors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-errors - based on the path /openconfig-bgp-errors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines BGP NOTIFICATION message error codes
and subcodes
  """
  _pyangbind_elements = {}

  

from . import transceiver_descriptors
from . import linecard_descriptors
from . import operational_mode_descriptors
class openconfig_terminal_device_properties(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device-properties - based on the path /openconfig-terminal-device-properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Module to extend OpenConfig terminal device's operational modes'
data. It supports operational modes for one Optical
Channel, with a single OTSi. The operational mode includes key
attributes such modulation format, symbol rate, nominal central
frequency (NFC) tunability constraints (grid, min/max NCF), FEC
gain, minimum and maximum output power of the transmitter or
minimum OSNR at the receiver as well as the spectrum width of
the OTSi (OTSiMC). It also includes (optional) aspects such as
filter characterization, CD and DGD tolerance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__transceiver_descriptors','__linecard_descriptors','__operational_mode_descriptors',)

  _yang_name = 'openconfig-terminal-device-properties'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-terminal-device-properties'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver_descriptors = YANGDynClass(base=transceiver_descriptors.transceiver_descriptors, is_container='container', yang_name="transceiver-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    self.__linecard_descriptors = YANGDynClass(base=linecard_descriptors.linecard_descriptors, is_container='container', yang_name="linecard-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    self.__operational_mode_descriptors = YANGDynClass(base=operational_mode_descriptors.operational_mode_descriptors, is_container='container', yang_name="operational-mode-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_transceiver_descriptors(self):
    """
    Getter method for transceiver_descriptors, mapped from YANG variable /transceiver_descriptors (container)

    YANG Description: Indicates the terminal-device's list of compatible transceiver
component and its associated modes and mode descriptors compatibility
matrix.
    """
    return self.__transceiver_descriptors
      
  def _set_transceiver_descriptors(self, v, load=False):
    """
    Setter method for transceiver_descriptors, mapped from YANG variable /transceiver_descriptors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver_descriptors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver_descriptors() directly.

    YANG Description: Indicates the terminal-device's list of compatible transceiver
component and its associated modes and mode descriptors compatibility
matrix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transceiver_descriptors.transceiver_descriptors, is_container='container', yang_name="transceiver-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver_descriptors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transceiver_descriptors.transceiver_descriptors, is_container='container', yang_name="transceiver-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)""",
        })

    self.__transceiver_descriptors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver_descriptors(self):
    self.__transceiver_descriptors = YANGDynClass(base=transceiver_descriptors.transceiver_descriptors, is_container='container', yang_name="transceiver-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)


  def _get_linecard_descriptors(self):
    """
    Getter method for linecard_descriptors, mapped from YANG variable /linecard_descriptors (container)

    YANG Description: Indicates the terminal-device's list of compatible linecard
component and its associated modes and mode descriptors compatibility
matrix.
    """
    return self.__linecard_descriptors
      
  def _set_linecard_descriptors(self, v, load=False):
    """
    Setter method for linecard_descriptors, mapped from YANG variable /linecard_descriptors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linecard_descriptors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linecard_descriptors() directly.

    YANG Description: Indicates the terminal-device's list of compatible linecard
component and its associated modes and mode descriptors compatibility
matrix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=linecard_descriptors.linecard_descriptors, is_container='container', yang_name="linecard-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linecard_descriptors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=linecard_descriptors.linecard_descriptors, is_container='container', yang_name="linecard-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)""",
        })

    self.__linecard_descriptors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linecard_descriptors(self):
    self.__linecard_descriptors = YANGDynClass(base=linecard_descriptors.linecard_descriptors, is_container='container', yang_name="linecard-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)


  def _get_operational_mode_descriptors(self):
    """
    Getter method for operational_mode_descriptors, mapped from YANG variable /operational_mode_descriptors (container)

    YANG Description: Indicates the transceiver's list of supported operational
modes and its associated transmission features
    """
    return self.__operational_mode_descriptors
      
  def _set_operational_mode_descriptors(self, v, load=False):
    """
    Setter method for operational_mode_descriptors, mapped from YANG variable /operational_mode_descriptors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_mode_descriptors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_mode_descriptors() directly.

    YANG Description: Indicates the transceiver's list of supported operational
modes and its associated transmission features
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=operational_mode_descriptors.operational_mode_descriptors, is_container='container', yang_name="operational-mode-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_mode_descriptors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=operational_mode_descriptors.operational_mode_descriptors, is_container='container', yang_name="operational-mode-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)""",
        })

    self.__operational_mode_descriptors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_mode_descriptors(self):
    self.__operational_mode_descriptors = YANGDynClass(base=operational_mode_descriptors.operational_mode_descriptors, is_container='container', yang_name="operational-mode-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)

  transceiver_descriptors = __builtin__.property(_get_transceiver_descriptors)
  linecard_descriptors = __builtin__.property(_get_linecard_descriptors)
  operational_mode_descriptors = __builtin__.property(_get_operational_mode_descriptors)


  _pyangbind_elements = OrderedDict([('transceiver_descriptors', transceiver_descriptors), ('linecard_descriptors', linecard_descriptors), ('operational_mode_descriptors', operational_mode_descriptors), ])


class openconfig_terminal_device_property_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device-property-types - based on the path /openconfig-terminal-device-property-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Supplementary module to expose identity types for the
openconfig-terminal-device-properties model. This model includes
definitions of the set of modulation format, FEC codes and adjustment
granularity types use in the reffered model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_summary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-summary - based on the path /openconfig-aft-summary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides summary of aft entry counts per protocol type for each network
instance.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-types - based on the path /openconfig-aft-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Types related to the OpenConfig Abstract Forwarding
Table (AFT) model
  """
  _pyangbind_elements = {}

  

class openconfig_aft_pf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-pf - based on the path /openconfig-aft-pf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding table(s) for policy forwarding entries. These are
defined to be forwarding tables that allow matches on
fields other than the destination address that is used in
other forwarding tables.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft - based on the path /openconfig-aft. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A model describing the forwarding entries installed on a network
element. It should be noted that this model is not expected to
align 1:1 with the underlying structure used directly by a
forwarding element (e.g., linecard), but rather provide an
abstraction that can be consumed by an NMS to observe, and in some
cases manipulate, the internal forwarding database in a simplified
manner. Since the underlying model of the forwarding table is not
expected to align with this model, the structure described herein
is referred to as an Abstract Forwarding Table (AFT), rather than
the FIB.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ipv4 - based on the path /openconfig-aft-ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for IPv4.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ipv6 - based on the path /openconfig-aft-ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for IPv6.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-mpls - based on the path /openconfig-aft-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding table for MPLS label forwarding.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_pf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-pf - based on the path /openconfig-aft-pf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding table(s) for policy forwarding entries. These are
defined to be forwarding tables that allow matches on
fields other than the destination address that is used in
other forwarding tables.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ethernet - based on the path /openconfig-aft-ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for Ethernet.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_state_synced(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-state-synced - based on the path /openconfig-aft-state-synced. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the state
synced signals corresponding to various abstract forwarding tables.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ipv6 - based on the path /openconfig-aft-ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for IPv6.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ethernet - based on the path /openconfig-aft-ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for Ethernet.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ipv4 - based on the path /openconfig-aft-ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for IPv4.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-mpls - based on the path /openconfig-aft-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding table for MPLS label forwarding.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_state_synced(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-state-synced - based on the path /openconfig-aft-state-synced. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the state
synced signals corresponding to various abstract forwarding tables.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-network-instance - based on the path /openconfig-aft-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides augmentations that are utilized
when building the OpenConfig network instance model to
add per-NI AFTs.
  """
  _pyangbind_elements = {}

  

class openconfig_icmpv6_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-icmpv6-types - based on the path /openconfig-icmpv6-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: OpenConfig module defining the types and coresponding subcodes for
ICMPv6.
  """
  _pyangbind_elements = {}

  

class openconfig_packet_match(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-packet-match - based on the path /openconfig-packet-match. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to packet header fields
used in matching operations, for example in ACLs.  When a
field is omitted from a match expression, the effect is a
wildcard ('any') for that field.
  """
  _pyangbind_elements = {}

  

class openconfig_packet_match_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-packet-match-types - based on the path /openconfig-packet-match-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines common types for use in models requiring
data definitions related to packet matches.
  """
  _pyangbind_elements = {}

  

class openconfig_icmpv4_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-icmpv4-types - based on the path /openconfig-icmpv4-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: OpenConfig module defining the types and coresponding codes for
ICMPv4.
  """
  _pyangbind_elements = {}

  

from . import acl
class openconfig_acl(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-acl - based on the path /openconfig-acl. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state
data for network access control lists (i.e., filters, rules,
etc.).  ACLs are organized into ACL sets, with each set
containing one or more ACL entries.  ACL sets are identified
by a unique name, while each entry within a set is assigned
a sequence-id that determines the order in which the ACL
rules are applied to a packet.  Note that ACLs are evaluated
in ascending order based on the sequence-id (low to high).

Individual ACL rules specify match criteria based on fields in
the packet, along with an action that defines how matching
packets should be handled. Entries have a type that indicates
the type of match criteria, e.g., MAC layer, IPv4, IPv6, etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__acl',)

  _yang_name = 'openconfig-acl'
  _yang_namespace = 'http://openconfig.net/yang/acl'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__acl = YANGDynClass(base=acl.acl, is_container='container', yang_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/acl', defining_module='openconfig-acl', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_acl(self):
    """
    Getter method for acl, mapped from YANG variable /acl (container)

    YANG Description: Top level enclosing container for ACL model config
and operational state data
    """
    return self.__acl
      
  def _set_acl(self, v, load=False):
    """
    Setter method for acl, mapped from YANG variable /acl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl() directly.

    YANG Description: Top level enclosing container for ACL model config
and operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=acl.acl, is_container='container', yang_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/acl', defining_module='openconfig-acl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=acl.acl, is_container='container', yang_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/acl', defining_module='openconfig-acl', yang_type='container', is_config=True)""",
        })

    self.__acl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl(self):
    self.__acl = YANGDynClass(base=acl.acl, is_container='container', yang_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/acl', defining_module='openconfig-acl', yang_type='container', is_config=True)

  acl = __builtin__.property(_get_acl, _set_acl)


  _pyangbind_elements = OrderedDict([('acl', acl), ])


class openconfig_pf_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-interfaces - based on the path /openconfig-pf-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains groupings related to the association
between interfaces and policy forwarding rules.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_forwarding_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-forwarding-policies - based on the path /openconfig-pf-forwarding-policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to the definition of policy-forwarding policies.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_srte(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-srte - based on the path /openconfig-pf-srte. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines extensions to the OpenConfig policy forwarding
module to support static segment routing traffic engineering policy
definitions. Extensions are provided to match:

 - Ingress binding SIDs, such that traffic can be mapped based on
   an ingress label.
 - A colour community and endpoint combination, such that the
   routes can be resolved according to the policy forwarding
   entries that are to be installed.

In addition, policy forwarding actions associated with next-hops are
added to the model. The next-hop set to be forwarded to is augmented
to cover a set of lists of segments. The most common application of
such segment lists is to express stacks of MPLS labels which are used
as SR segments. In addition, they may be used to expressed segments
in the form of IPv6 addresses.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_forwarding_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-forwarding-policies - based on the path /openconfig-pf-forwarding-policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to the definition of policy-forwarding policies.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_path_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-path-groups - based on the path /openconfig-pf-path-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to path-selection-groups which are used to group
forwarding entities together to be used as policy forwarding
targets.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_path_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-path-groups - based on the path /openconfig-pf-path-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to path-selection-groups which are used to group
forwarding entities together to be used as policy forwarding
targets.
  """
  _pyangbind_elements = {}

  

class openconfig_policy_forwarding(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-policy-forwarding - based on the path /openconfig-policy-forwarding. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
relating to policy-based forwarding. Policy-based forwarding is
utilised when a system chooses how to forward packets (including
applying data-plane operations such as encapsulation or
decapsulation) based on policies other than destination L2 or L3
header. Typically, systems may implement:

- IP policy-based routing, where routing may be done based on the
  source plus destination of an IP packet; information within the
  L4 header; or some combination of both.
- Encapsulation or decapsulation based on certain policy
  information - for example, matching particular IP destinations
  and decapsulating GRE headers.
- Class-based selection of egress routes - such as class-based
  selection of an egress MPLS path.

The policies that are defined in this model are applied to a
particular ingress context of a network element (e.g., interface)
and are defined to apply following other interface policy such as
QoS classification and access control lists.

This module defines:

- policy-forwarding
|
|--- policies
|    |-- policy
|        |-- [match criteria]    How packets are defined to
|        |                       match policy.
|        |-- [forwarding-action] How packets matching should
|                                 be forwarded.
|--- interfaces
|    |-- interfaces
|        | -- apply-forwarding-policy  Forwarding policy to
|                                      used on the interface.
|--- path-selection-groups
    |-- path-selection-group     A group of forwarding resources
                                 that are grouped for purposes
                                 of next-hop selection.

A forwarding-policy specifies the match criteria that it intends
to use to determine the packets that it reroutes - this may
consist of a number of criteria, such as DSCP. The match criteria
is specified as rules.  If no rules are specified, then the policy
will match all packets.

The action of the policy results in a forwarding action being applied
to matching packets. For example, decapsulating the packet from a GRE
header. In order to enact the policy based on particular interfaces -
the forwarding-policy is applied to an interface via referencing it
within an 'apply-forwarding-policy' statement associated with an
interface.

A policy-forwarding rule with no action should be treated as an error.

In some cases (e.g., Class-Based Tunnel Selection) the forwarding
action does not resolve to a single egress action, and rather
normal forwarding rules are to be applied but considering a subset
of forwarding resources. In these cases, a path-selection-group
can be created, referencing the subset of forwarding paths that
should be used for the egress selection. In the case that a subset
of MPLS LSPs are eligible for, say, DSCP 46 marked packets, a
path-selection-group is created, referencing the subset of LSPs.
The forwarding action of the corresponding policy is set to
PATH_GROUP and references the configured group of LSPs.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_forwarding_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-forwarding-policies - based on the path /openconfig-pf-forwarding-policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to the definition of policy-forwarding policies.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_path_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-path-groups - based on the path /openconfig-pf-path-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to path-selection-groups which are used to group
forwarding entities together to be used as policy forwarding
targets.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-interfaces - based on the path /openconfig-pf-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains groupings related to the association
between interfaces and policy forwarding rules.
  """
  _pyangbind_elements = {}

  

class openconfig_policy_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-policy-types - based on the path /openconfig-policy-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in routing
policy.  It can be imported by modules that contain protocol-
specific policy conditions and actions.
  """
  _pyangbind_elements = {}

  

from . import routing_policy
class openconfig_routing_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-routing-policy - based on the path /openconfig-routing-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for routing policy
configuration. It is a limited subset of all of the policy
configuration parameters available in the variety of vendor
implementations, but supports widely used constructs for managing
how routes are imported, exported, and modified across different
routing protocols.  This module is intended to be used in
conjunction with routing protocol configuration models (e.g.,
BGP) defined in other modules.

Route policy expression:

Policies are expressed as a set of top-level policy definitions,
each of which consists of a sequence of policy statements. Policy
statements consist of simple condition-action tuples. Conditions
may include mutiple match or comparison operations, and similarly
actions may be multitude of changes to route attributes or a
final disposition of accepting or rejecting the route.

Route policy evaluation:

Policy definitions are referenced in routing protocol
configurations using import and export configuration statements.
The arguments are members of an ordered list of named policy
definitions which comprise a policy chain, and optionally, an
explicit default policy action (i.e., reject or accept).

Evaluation of each policy definition proceeds by evaluating its
corresponding individual policy statements in order.  When a
condition statement in a policy statement is satisfied, the
corresponding action statement is executed.  A policy statement with no
conditions defined is evaluated as statisfied, meaning all routes are
matched.  A routing-policy statement with no condition AND no action, or
a policy-definition without any statements should be treated as errors.

If the action statement has a final disposition configured as
policy result, either accept-route or reject-route, evaluation of the
current policy definition stops, and no further policy statements are
evaluated. In case there is a policy chain, no further policy definitions
in the chain are evaluated.

If the action statement has the NEXT_STATEMENT policy result, all the
defined actions are executed and policy evaluation proceeds to the next
statement.  The NEXT_STATEMENT is the default policy result action.

If the condition is not satisfied, then evaluation proceeds to
the next policy statement.  If none of the policy statement
conditions are satisfied, then evaluation of the current policy
definition stops, and the next policy definition in the chain is
evaluated.  When the end of the policy chain is reached, the
default route disposition action is performed (i.e., reject-route
unless an an alternate default action is specified for the
chain).

Policy 'subroutines' (or nested policies) are supported by
allowing policy statement conditions to reference another policy
definition which applies conditions and actions from the
referenced policy before returning to the calling policy
statement and resuming evaluation.  If the called policy
results in an accept-route (either explicit or by default), then
the subroutine returns an effective true value to the calling
policy.  Similarly, a reject-route action returns false.  If the
subroutine returns true, the calling policy continues to evaluate
the remaining conditions (using a modified route if the
subroutine performed any changes to the route).

If a routing protocol is defined and the related
apply-policy/default-(import|export)-policy leaf is not set, the
default value for the default-(import|export)-policy leaf must be
applied.  See RFC6020 7.6.1 which applies to this model.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing_policy',)

  _yang_name = 'openconfig-routing-policy'
  _yang_namespace = 'http://openconfig.net/yang/routing-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_policy = YANGDynClass(base=routing_policy.routing_policy, is_container='container', yang_name="routing-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/routing-policy', defining_module='openconfig-routing-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_routing_policy(self):
    """
    Getter method for routing_policy, mapped from YANG variable /routing_policy (container)

    YANG Description: Top-level container for all routing policy configuration
    """
    return self.__routing_policy
      
  def _set_routing_policy(self, v, load=False):
    """
    Setter method for routing_policy, mapped from YANG variable /routing_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_policy() directly.

    YANG Description: Top-level container for all routing policy configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=routing_policy.routing_policy, is_container='container', yang_name="routing-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/routing-policy', defining_module='openconfig-routing-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=routing_policy.routing_policy, is_container='container', yang_name="routing-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/routing-policy', defining_module='openconfig-routing-policy', yang_type='container', is_config=True)""",
        })

    self.__routing_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_policy(self):
    self.__routing_policy = YANGDynClass(base=routing_policy.routing_policy, is_container='container', yang_name="routing-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/routing-policy', defining_module='openconfig-routing-policy', yang_type='container', is_config=True)

  routing_policy = __builtin__.property(_get_routing_policy, _set_routing_policy)


  _pyangbind_elements = OrderedDict([('routing_policy', routing_policy), ])


class openconfig_ospfv2_lsdb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-lsdb - based on the path /openconfig-ospfv2-lsdb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for the Open Shortest Path First (OSPF)
version 2 link-state database (LSDB)
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-policy - based on the path /openconfig-ospf-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines extensions to the OpenConfig policy
model to add extensions for OSPF. This module is intended
to be generic for both OSPFv2 and OSPFv3.
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-types - based on the path /openconfig-ospf-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Type definitions for OSPF
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area - based on the path /openconfig-ospf-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area-interface - based on the path /openconfig-ospf-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area-interface - based on the path /openconfig-ospf-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-common - based on the path /openconfig-ospf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-common - based on the path /openconfig-ospf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-common - based on the path /openconfig-ospfv2-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2 - based on the path /openconfig-ospfv2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for Open Shortest Path First (OSPF)
version 2
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-global - based on the path /openconfig-ospfv2-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are global to a particular OSPF instance
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area - based on the path /openconfig-ospfv2-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area-interface - based on the path /openconfig-ospfv2-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_lsdb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-lsdb - based on the path /openconfig-ospfv2-lsdb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for the Open Shortest Path First (OSPF)
version 2 link-state database (LSDB)
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-common - based on the path /openconfig-ospfv2-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf - based on the path /openconfig-ospf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-global - based on the path /openconfig-ospf-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are global to a particular OSPF instance
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area - based on the path /openconfig-ospf-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area-interface - based on the path /openconfig-ospf-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-common - based on the path /openconfig-ospf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-global - based on the path /openconfig-ospfv2-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are global to a particular OSPF instance
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-common - based on the path /openconfig-ospfv2-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-global - based on the path /openconfig-ospf-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are global to a particular OSPF instance
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-common - based on the path /openconfig-ospf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area - based on the path /openconfig-ospfv2-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area-interface - based on the path /openconfig-ospfv2-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_lsdb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-lsdb - based on the path /openconfig-ospfv2-lsdb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for the Open Shortest Path First (OSPF)
version 2 link-state database (LSDB)
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv3_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv3-area-interface - based on the path /openconfig-ospfv3-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv3 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area-interface - based on the path /openconfig-ospfv2-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-common - based on the path /openconfig-ospfv2-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_if_8021x(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-8021x - based on the path /openconfig-if-8021x. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing 8021X. Augments the OpenConfig models for
wired interfaces and wireless SSIDs for configuration and state.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ip_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ip-ext - based on the path /openconfig-if-ip-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds extensions to the base IP configuration and
operational state model to support additional use cases.
  """
  _pyangbind_elements = {}

  

class openconfig_if_tunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-tunnel - based on the path /openconfig-if-tunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model adds extensions to the OpenConfig interfaces
model to configure tunnel interfaces on a network
device.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ethernet - based on the path /openconfig-if-ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing Ethernet interfaces -- augments the OpenConfig
model for interface configuration and state.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ip(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ip - based on the path /openconfig-if-ip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model defines data for managing configuration and
operational state on IP (IPv4 and IPv6) interfaces.

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7277 with an alternate structure
(particularly for operational state data) and with
additional configuration items.

Portions of this code were derived from IETF RFC 7277.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_if_sdn_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-sdn-ext - based on the path /openconfig-if-sdn-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides extensions to the OpenConfig interfaces
module for network elements that support external 'SDN' control
of their interfaces.
  """
  _pyangbind_elements = {}

  

class openconfig_if_aggregate(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-aggregate - based on the path /openconfig-if-aggregate. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing aggregated (aka bundle, LAG) interfaces.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ethernet_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ethernet-ext - based on the path /openconfig-if-ethernet-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds extensions to the base ethernet configuration
and operational state model to support additional use cases.
  """
  _pyangbind_elements = {}

  

class openconfig_if_poe(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-poe - based on the path /openconfig-if-poe. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state data for
Power over Ethernet (PoE) based on the IEEE 802.3af
standard.
  """
  _pyangbind_elements = {}

  

from . import interfaces
class openconfig_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /openconfig-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing network interfaces and subinterfaces.  This
module also defines convenience types / groupings for other
models to create references to interfaces:

 base-interface-ref (type) -  reference to a base interface
 interface-ref (grouping) -  container for reference to a
   interface + subinterface
 interface-ref-state (grouping) - container for read-only
   (opstate) reference to interface + subinterface

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7223 with an alternate structure
(particularly for operational state data) and with
additional configuration items.

Portions of this code were derived from IETF RFC 7223.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces',)

  _yang_name = 'openconfig-interfaces'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /interfaces (container)

    YANG Description: Top level container for interfaces, including configuration
and state data.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Top level container for interfaces, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)


  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ])


class openconfig_if_rates(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-rates - based on the path /openconfig-if-rates. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state for interface rates.
  """
  _pyangbind_elements = {}

  

class openconfig_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-extensions - based on the path /openconfig-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides extensions to the YANG language to allow
OpenConfig specific functionality and meta-data to be defined.
  """
  _pyangbind_elements = {}

  

class openconfig_gribi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gribi - based on the path /openconfig-gribi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a set of exdtensions that provide gRIBI (the gRPC
RIB Interface) specific extensions to the OpenConfig data models.
Specifically, the parameters for the configuration of the service, and
configuration and state are added.

The gRIBI protobufs and documentation are published at
https://github.com/openconfig/gribi.
  """
  _pyangbind_elements = {}

  

class openconfig_isis_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-types - based on the path /openconfig-isis-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in ISIS YANG
model.
  """
  _pyangbind_elements = {}

  

class openconfig_isis_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-routing - based on the path /openconfig-isis-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes YANG model for ISIS Routing
  """
  _pyangbind_elements = {}

  

class openconfig_isis_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-policy - based on the path /openconfig-isis-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains data definitions for ISIS routing policy.
It augments the base routing-policy module with BGP-specific
options for conditions and actions.
  """
  _pyangbind_elements = {}

  

class openconfig_isis_lsp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-lsp - based on the path /openconfig-isis-lsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module describes a YANG model for the IS-IS Link State
Database (LSDB).

Portions of this code were derived from IETF RFCs relating to the
IS-IS protocol.
Please reproduce this note if possible.
IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_isis_lsdb_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-lsdb-types - based on the path /openconfig-isis-lsdb-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general LSDB type definitions for use in
ISIS YANG model. 
  """
  _pyangbind_elements = {}

  

class openconfig_isis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis - based on the path /openconfig-isis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for ISIS protocol configuration.
It is a limited subset of all of the configuration parameters
available in the variety of vendor implementations, hence it is
expected that it would be augmented with vendor - specific configuration
data as needed. Additional modules or submodules to handle other
aspects of ISIS configuration, including policy, routing, types,
LSDB and additional address families are also expected. This model
supports the following ISIS configuration level hierarchy:

ISIS
+-> { global ISIS configuration}
   +-> levels +-> { level config}
       +-> { system-level-counters }
       +-> { level link-state-database}
   +-> interface +-> { interface config }
       +-> { circuit-counters }
       +-> { levels config }
       +-> { level adjacencies }
  """
  _pyangbind_elements = {}

  

class openconfig_isis_lsp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-lsp - based on the path /openconfig-isis-lsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module describes a YANG model for the IS-IS Link State
Database (LSDB).

Portions of this code were derived from IETF RFCs relating to the
IS-IS protocol.
Please reproduce this note if possible.
IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_isis_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-routing - based on the path /openconfig-isis-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes YANG model for ISIS Routing
  """
  _pyangbind_elements = {}

  

from . import oam
class openconfig_oam(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam - based on the path /openconfig-oam. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG data model for configuring and managing
EthernetOAM functions
  """
  __slots__ = ('_path_helper', '_extmethods', '__oam',)

  _yang_name = 'openconfig-oam'
  _yang_namespace = 'http://openconfig.net/yang/oam'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__oam = YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_oam(self):
    """
    Getter method for oam, mapped from YANG variable /oam (container)

    YANG Description: Operational state and configuration parameters relating to
Ethernet OAM
    """
    return self.__oam
      
  def _set_oam(self, v, load=False):
    """
    Setter method for oam, mapped from YANG variable /oam (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oam is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oam() directly.

    YANG Description: Operational state and configuration parameters relating to
Ethernet OAM
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=oam.oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oam must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)""",
        })

    self.__oam = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oam(self):
    self.__oam = YANGDynClass(base=oam.oam, is_container='container', yang_name="oam", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oam', defining_module='openconfig-oam', yang_type='container', is_config=True)

  oam = __builtin__.property(_get_oam, _set_oam)


  _pyangbind_elements = OrderedDict([('oam', oam), ])


class openconfig_cfm_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-cfm-types - based on the path /openconfig-cfm-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in CFM
  """
  _pyangbind_elements = {}

  

class openconfig_oam_cfm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-oam-cfm - based on the path /openconfig-oam-cfm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG data model for configuring and managing CFM
(Connectivity Fault Management) in a network device. The module includes
maintenance domains, associations, maintenance endpoints,
performance management policies and remote defect handling features
  """
  _pyangbind_elements = {}

  

from . import provision_aps
from . import joined_aps
class openconfig_ap_manager(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-manager - based on the path /openconfig-ap-manager. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the top level configuration and state data for a
system which manages Access Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__provision_aps','__joined_aps',)

  _yang_name = 'openconfig-ap-manager'
  _yang_namespace = 'http://openconfig.net/yang/ap-manager'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__provision_aps = YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    self.__joined_aps = YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_provision_aps(self):
    """
    Getter method for provision_aps, mapped from YANG variable /provision_aps (container)

    YANG Description: Top most container for assigning hostnames to APs.
    """
    return self.__provision_aps
      
  def _set_provision_aps(self, v, load=False):
    """
    Setter method for provision_aps, mapped from YANG variable /provision_aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provision_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provision_aps() directly.

    YANG Description: Top most container for assigning hostnames to APs.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """provision_aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__provision_aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_provision_aps(self):
    self.__provision_aps = YANGDynClass(base=provision_aps.provision_aps, is_container='container', yang_name="provision-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)


  def _get_joined_aps(self):
    """
    Getter method for joined_aps, mapped from YANG variable /joined_aps (container)

    YANG Description: Top most container for joined-aps.
    """
    return self.__joined_aps
      
  def _set_joined_aps(self, v, load=False):
    """
    Setter method for joined_aps, mapped from YANG variable /joined_aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_joined_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_joined_aps() directly.

    YANG Description: Top most container for joined-aps.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """joined_aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)""",
        })

    self.__joined_aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_joined_aps(self):
    self.__joined_aps = YANGDynClass(base=joined_aps.joined_aps, is_container='container', yang_name="joined-aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ap-manager', defining_module='openconfig-ap-manager', yang_type='container', is_config=True)

  provision_aps = __builtin__.property(_get_provision_aps, _set_provision_aps)
  joined_aps = __builtin__.property(_get_joined_aps, _set_joined_aps)


  _pyangbind_elements = OrderedDict([('provision_aps', provision_aps), ('joined_aps', joined_aps), ])


from . import access_points
class openconfig_access_points(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-access-points - based on the path /openconfig-access-points. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the top level WiFi Configurations for a list of
Access Points.
  """
  __slots__ = ('_path_helper', '_extmethods', '__access_points',)

  _yang_name = 'openconfig-access-points'
  _yang_namespace = 'http://openconfig.net/yang/wifi/access-points'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__access_points = YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_access_points(self):
    """
    Getter method for access_points, mapped from YANG variable /access_points (container)

    YANG Description: Top most container for configuration and state data for Access
Points.
    """
    return self.__access_points
      
  def _set_access_points(self, v, load=False):
    """
    Setter method for access_points, mapped from YANG variable /access_points (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_access_points is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_access_points() directly.

    YANG Description: Top most container for configuration and state data for Access
Points.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """access_points must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)""",
        })

    self.__access_points = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_access_points(self):
    self.__access_points = YANGDynClass(base=access_points.access_points, is_container='container', yang_name="access-points", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi/access-points', defining_module='openconfig-access-points', yang_type='container', is_config=True)

  access_points = __builtin__.property(_get_access_points, _set_access_points)


  _pyangbind_elements = OrderedDict([('access_points', access_points), ])


from . import ssids
class openconfig_wifi_mac(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-mac - based on the path /openconfig-wifi-mac. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing MAC layer configuration of Radio interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ssids',)

  _yang_name = 'openconfig-wifi-mac'
  _yang_namespace = 'http://openconfig.net/yang/wifi-mac'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ssids = YANGDynClass(base=ssids.ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ssids(self):
    """
    Getter method for ssids, mapped from YANG variable /ssids (container)

    YANG Description: Top level container for SSIDs, including configuration
and state data.
    """
    return self.__ssids
      
  def _set_ssids(self, v, load=False):
    """
    Setter method for ssids, mapped from YANG variable /ssids (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssids() directly.

    YANG Description: Top level container for SSIDs, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ssids.ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ssids must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ssids.ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)""",
        })

    self.__ssids = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ssids(self):
    self.__ssids = YANGDynClass(base=ssids.ssids, is_container='container', yang_name="ssids", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-mac', defining_module='openconfig-wifi-mac', yang_type='container', is_config=True)

  ssids = __builtin__.property(_get_ssids, _set_ssids)


  _pyangbind_elements = OrderedDict([('ssids', ssids), ])


class openconfig_ap_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ap-interfaces - based on the path /openconfig-ap-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines the configuration and state data for
non-radio interfaces on WiFi Access Points.
  """
  _pyangbind_elements = {}

  

from . import radios
class openconfig_wifi_phy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-phy - based on the path /openconfig-wifi-phy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing PHY layer configuration of Radio interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__radios',)

  _yang_name = 'openconfig-wifi-phy'
  _yang_namespace = 'http://openconfig.net/yang/wifi-phy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__radios = YANGDynClass(base=radios.radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-phy', defining_module='openconfig-wifi-phy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_radios(self):
    """
    Getter method for radios, mapped from YANG variable /radios (container)

    YANG Description: Top level container for radios, including configuration
and state data.
    """
    return self.__radios
      
  def _set_radios(self, v, load=False):
    """
    Setter method for radios, mapped from YANG variable /radios (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_radios is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_radios() directly.

    YANG Description: Top level container for radios, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=radios.radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-phy', defining_module='openconfig-wifi-phy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """radios must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=radios.radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-phy', defining_module='openconfig-wifi-phy', yang_type='container', is_config=True)""",
        })

    self.__radios = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_radios(self):
    self.__radios = YANGDynClass(base=radios.radios, is_container='container', yang_name="radios", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wifi-phy', defining_module='openconfig-wifi-phy', yang_type='container', is_config=True)

  radios = __builtin__.property(_get_radios, _set_radios)


  _pyangbind_elements = OrderedDict([('radios', radios), ])


class openconfig_wifi_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wifi-types - based on the path /openconfig-wifi-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a set of WiFi-specific type definitions
that are used in the openconfig-wifi modules. It can be
imported by any module to make use of these types.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-ext - based on the path /openconfig-rib-bgp-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines additional data nodes for the OpenConfig BGP RIB model.
These items reflect extensions that are desirable features but
are not currently supported in a majority of BGP
implementations.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_tables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-tables - based on the path /openconfig-rib-bgp-tables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
BGP routing tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-attributes - based on the path /openconfig-rib-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_shared_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-shared-attributes - based on the path /openconfig-rib-bgp-shared-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
attribute sets shared across routes.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_table_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-table-attributes - based on the path /openconfig-rib-bgp-table-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for data
related to a RIB entry, or RIB table.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp - based on the path /openconfig-rib-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines a data model for representing BGP routing table (RIB)
contents.  The model supports 5 logical RIBs per address family:

loc-rib: This is the main BGP routing table for the local routing
instance, containing best-path selections for each prefix. The
loc-rib table may contain multiple routes for a given prefix,
with an attribute to indicate which was selected as the best
path.  Note that multiple paths may be used or advertised even if
only one path is marked as best, e.g., when using BGP
add-paths.  An implementation may choose to mark multiple
paths in the RIB as best path by setting the flag to true for
multiple entries.

adj-rib-in-pre: This is a per-neighbor table containing the NLRI
updates received from the neighbor before any local input policy
rules or filters have been applied.  This can be considered the
'raw' updates from a given neighbor.

adj-rib-in-post: This is a per-neighbor table containing the
routes received from the neighbor that are eligible for
best-path selection after local input policy rules have been
applied.

adj-rib-out-pre: This is a per-neighbor table containing routes
eligible for sending (advertising) to the neighbor before output
policy rules have been applied.

adj-rib-out-post: This is a per-neighbor table containing routes
eligible for sending (advertising) to the neighbor after output
policy rules have been applied.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_tables(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-tables - based on the path /openconfig-rib-bgp-tables. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
BGP routing tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_shared_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-shared-attributes - based on the path /openconfig-rib-bgp-shared-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
attribute sets shared across routes.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-attributes - based on the path /openconfig-rib-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_table_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-table-attributes - based on the path /openconfig-rib-bgp-table-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for data
related to a RIB entry, or RIB table.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-attributes - based on the path /openconfig-rib-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_shared_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-shared-attributes - based on the path /openconfig-rib-bgp-shared-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains structural data definitions for
attribute sets shared across routes.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-attributes - based on the path /openconfig-rib-bgp-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for BGP
attributes for use in BGP RIB tables.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_table_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-table-attributes - based on the path /openconfig-rib-bgp-table-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains common data definitions for data
related to a RIB entry, or RIB table.
  """
  _pyangbind_elements = {}

  

class openconfig_rib_bgp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rib-bgp-types - based on the path /openconfig-rib-bgp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines identity and type defintions associated with
the OpenConfig BGP RIB modules
  """
  _pyangbind_elements = {}

  

class openconfig_rsvp_sr_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-rsvp-sr-ext - based on the path /openconfig-rsvp-sr-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds extensions to the OpenConfig MPLS models to
provide extensions which allow the coexistence of RSVP-TE and
Segment Routing (SR) within the same network. It augments the
existing OpenConfig segment routing (SR) and RSVP-TE models
where required.
  """
  _pyangbind_elements = {}

  

class openconfig_segment_routing_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-segment-routing-types - based on the path /openconfig-segment-routing-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Types associated with a network instance
  """
  _pyangbind_elements = {}

  

class openconfig_srte_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-srte-policy - based on the path /openconfig-srte-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a collection of segment routing traffic
engineering policy operational states.

Each policy, identified by a combination of color and endpoint,
has one or more candidate paths learned from one or more sources.
The best valid/usable path is marked as active and programmed in
forwarding plane.

A candidate path, identified by protocol-origin, originator and
discriminator, can have one and more segment-list defining the
path traffic should take. Each segment-list is associated with a
weight for weighted load balancing.

Traffic counters related to SR policies are also defined in this
module.
  """
  _pyangbind_elements = {}

  

class openconfig_segment_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-segment-routing - based on the path /openconfig-segment-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration and operational state parameters relating to the
segment routing. This module defines a number of elements which are
instantiated in multiple places throughout the OpenConfig collection
of models.

Particularly:
 - SRGB+LB dataplane instances - directly instantied by SR.
 - SRGB+LB dataplane reservations - instantiated within MPLS and future SR
                                 dataplanes.
 - SR SID advertisements - instantiated within the relevant IGP.
 - SR-specific counters - instantied within the relevant dataplane.
  """
  _pyangbind_elements = {}

  

from . import probes
class openconfig_probes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-probes - based on the path /openconfig-probes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for the probes.
A probe consists on a group of tests, each test being a
source-destination pair to poll. The destination can be either
IP Address (and eventually port) or URL, depending on the
nature of the test. The test can send ICMP, UDP, TCP, or HTTP
requests.
Each test groups a list of test items, the test results
being an overall view or average of the items list.
However, the test preserves only a limited set of history
items, whose length can be controlled using the history-size.
  """
  __slots__ = ('_path_helper', '_extmethods', '__probes',)

  _yang_name = 'openconfig-probes'
  _yang_namespace = 'http://openconfig.net/yang/probes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__probes = YANGDynClass(base=probes.probes, is_container='container', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/probes', defining_module='openconfig-probes', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_probes(self):
    """
    Getter method for probes, mapped from YANG variable /probes (container)

    YANG Description: The container containing the list of probes.
    """
    return self.__probes
      
  def _set_probes(self, v, load=False):
    """
    Setter method for probes, mapped from YANG variable /probes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_probes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_probes() directly.

    YANG Description: The container containing the list of probes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=probes.probes, is_container='container', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/probes', defining_module='openconfig-probes', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """probes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=probes.probes, is_container='container', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/probes', defining_module='openconfig-probes', yang_type='container', is_config=True)""",
        })

    self.__probes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_probes(self):
    self.__probes = YANGDynClass(base=probes.probes, is_container='container', yang_name="probes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/probes', defining_module='openconfig-probes', yang_type='container', is_config=True)

  probes = __builtin__.property(_get_probes, _set_probes)


  _pyangbind_elements = OrderedDict([('probes', probes), ])


class openconfig_probes_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-probes-types - based on the path /openconfig-probes-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the probes.
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_sr(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-sr - based on the path /openconfig-mpls-sr. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for MPLS with segment routing-based LSPs,
including global parameters, and LSP-specific configuration for
both constrained-path and IGP-congruent LSPs
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_ldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-ldp - based on the path /openconfig-mpls-ldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration of Label Distribution Protocol global and LSP-
specific parameters for IGP-congruent LSPs.

This model reuses data items defined in the IETF YANG model for
LDP described by draft-ietf-mpls-ldp-yang-04, YANG Data Model for
MPLS LDP, following an alternate structure.

Portions of this code were derived from draft-ietf-mpls-ldp-yang-04.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_rsvp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-rsvp - based on the path /openconfig-mpls-rsvp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration for RSVP-TE signaling, including global protocol
parameters and LSP-specific configuration for constrained-path
LSPs
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-types - based on the path /openconfig-mpls-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: General types for MPLS / TE data model
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_te(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-te - based on the path /openconfig-mpls-te. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration related to constrained-path LSPs and traffic
engineering.  These definitions are not specific to a particular
signaling protocol or mechanism (see related submodules for
signaling protocol-specific configuration).
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_igp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-igp - based on the path /openconfig-mpls-igp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration generic configuration parameters for IGP-congruent
LSPs
  """
  _pyangbind_elements = {}

  

class openconfig_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls - based on the path /openconfig-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides data definitions for configuration of
Multiprotocol Label Switching (MPLS) and associated protocols for
signaling and traffic engineering.

RFC 3031: Multiprotocol Label Switching Architecture

The MPLS / TE data model consists of several modules and
submodules as shown below.  The top-level MPLS module describes
the overall framework.  Three types of LSPs are supported:

i) traffic-engineered (or constrained-path)

ii) IGP-congruent (LSPs that follow the IGP path)

iii) static LSPs which are not signaled

The structure of each of these LSP configurations is defined in
corresponding submodules.  Companion modules define the relevant
configuration and operational data specific to key signaling
protocols used in operational practice.


                         +-------+
       +---------------->| MPLS  |<--------------+
       |                 +-------+               |
       |                     ^                   |
       |                     |                   |
  +----+-----+      +--------+-------+     +-----+-----+
  | TE LSPs  |      | IGP-based LSPs |     |static LSPs|
  |          |      |                |     |           |
  +----------+      +----------------+     +-----------+
      ^  ^                    ^  ^
      |  +----------------+   |  +--------+
      |                   |   |           |
      |   +------+      +-+---+-+      +--+--+
      +---+ RSVP |      |SEGMENT|      | LDP |
          +------+      |ROUTING|      +-----+
                        +-------+

  """
  _pyangbind_elements = {}

  

class openconfig_mpls_te(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-te - based on the path /openconfig-mpls-te. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration related to constrained-path LSPs and traffic
engineering.  These definitions are not specific to a particular
signaling protocol or mechanism (see related submodules for
signaling protocol-specific configuration).
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_igp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-igp - based on the path /openconfig-mpls-igp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration generic configuration parameters for IGP-congruent
LSPs
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_static(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-static - based on the path /openconfig-mpls-static. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines static LSP configuration
  """
  _pyangbind_elements = {}

  

class openconfig_mpls_static(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-mpls-static - based on the path /openconfig-mpls-static. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines static LSP configuration
  """
  _pyangbind_elements = {}

  

class openconfig_yang_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-yang-types - based on the path /openconfig-yang-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a set of extension types to the
YANG builtin types that are used across multiple
OpenConfig models.

Portions of this code were derived from IETF RFC 6021.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_inet_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-inet-types - based on the path /openconfig-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a set of Internet address related
types for use in OpenConfig modules.

Portions of this code were derived from IETF RFC 6021.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-types - based on the path /openconfig-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a set of general type definitions that
are used across OpenConfig models. It can be imported by modules
that make use of these types.
  """
  _pyangbind_elements = {}

  

class openconfig_gnpsi_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnpsi-types - based on the path /openconfig-gnpsi-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds gRPC server type relating to gNPSI running on
a network device.
  """
  _pyangbind_elements = {}

  

class openconfig_igmp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-igmp - based on the path /openconfig-igmp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for Internet Group Management Protocol (IGMP).
  """
  _pyangbind_elements = {}

  

class openconfig_pim(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pim - based on the path /openconfig-pim. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for Protocol Independent Multicast (PIM) that supports IPv4 address family.
  """
  _pyangbind_elements = {}

  

class openconfig_igmp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-igmp-types - based on the path /openconfig-igmp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the IGMP protocol model.
  """
  _pyangbind_elements = {}

  

class openconfig_pim_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pim-types - based on the path /openconfig-pim-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the PIM protocol model.
  """
  _pyangbind_elements = {}

  

class openconfig_p4rt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-p4rt - based on the path /openconfig-p4rt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a set of extensions that provide P4Runtime (P4RT)
specific extensions to the OpenConfig data models. Specifically, these
parameters for configuration and state provide extensions that control
the P4RT service, or allow it to be used alongside other OpenConfig
data models.

The P4RT protocol specification is linked from https://p4.org/specs/
under the P4Runtime heading.
  """
  _pyangbind_elements = {}

  

from . import bfd
class openconfig_bfd(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bfd - based on the path /openconfig-bfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model of Bi-Directional Forwarding Detection (BFD)
configuration and operational state.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bfd',)

  _yang_name = 'openconfig-bfd'
  _yang_namespace = 'http://openconfig.net/yang/bfd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bfd = YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bfd(self):
    """
    Getter method for bfd, mapped from YANG variable /bfd (container)

    YANG Description: Configuration and operational state parameters for BFD.
    """
    return self.__bfd
      
  def _set_bfd(self, v, load=False):
    """
    Setter method for bfd, mapped from YANG variable /bfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bfd() directly.

    YANG Description: Configuration and operational state parameters for BFD.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=bfd.bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bfd must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='container', is_config=True)""",
        })

    self.__bfd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bfd(self):
    self.__bfd = YANGDynClass(base=bfd.bfd, is_container='container', yang_name="bfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='container', is_config=True)

  bfd = __builtin__.property(_get_bfd, _set_bfd)


  _pyangbind_elements = OrderedDict([('bfd', bfd), ])


class openconfig_ptp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp-types - based on the path /openconfig-ptp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types and identities used in OpenConfig
models related to Precision Time Protocol (PTP).

IEEE code is subject to the following copyright and license:
Copyright (c) 2020 by The Institute of Electrical and Electronics
Engineers, Inc. All rights reserved.
  """
  _pyangbind_elements = {}

  

from . import ptp
class openconfig_ptp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /openconfig-ptp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines a data model for the configuration
and state of IEEE Std 1588 clocks. IEEE Std 1588 specifies the
Precision Time Protocol (PTP).

The nodes in this YANG module are designed for compatibility
with ietf-ptp.yang, the YANG data model for IEEE Std 1588-2008,
as specified in IETF RFC 8575.

NOTE regarding default value:
PTP's concept of 'initialization value' is analogous to YANG's
concept of a 'default value'. According to 8.1.3.4 of
IEEE Std 1588-2019, the initialization value for configuration
is specified in IEEE Std 1588, but that value can be overridden
by a PTP Profile specification, or by the product that
implements PTP. This makes it challenging to repeat the
specification of initialization value using a YANG 'default'
statement, because there is no straightforward mechanism for
a PTP Profile's (or product's) YANG module to import this
module and override its YANG default. Since a YANG management
client can read the default value from the operational
datastore, there is no need to re-specify the default in YANG.
The implementer of PTP refers to the relevant PTP
specifications for the default (not YANG modules).
Therefore, this YANG module avoids use of the YANG 'default'
statement.

NOTE regarding IEEE Std 1588 classification:
8.1.2 of IEEE Std 1588-2019 specifies a classification of
each data set member, which corresponds to a leaf in YANG.
The relationship between 1588 classification and
YANG 'config' (i.e., whether the leaf is read-write) is:
- 1588 static: The leaf is 'config false' (read-only).
- 1588 configurable: The leaf is 'config true', which is
 the default value for a YANG leaf.
- 1588 dynamic: A judgement is made on a member-by-member
 basis. If the member corresponds to the first item of
 8.1.2.1.2 of IEEE Std 1588-2019 (i.e., value from protocol
 only, such as log of protocol behavior), the YANG leaf
 is 'config false'. Otherwise, the member's value can be
 provided by an entity outside PTP (e.g., NETCONF or
 RESTCONF client), and therefore the YANG leaf is
 'config true'.

NOTE regarding terminology (two YANG modules):
To accommodate the need by some organizations to use the
original terminology specified by IEEE Std 1588, and the
need by some other organizations to use the alternative
terminology specified in 4.4 of IEEE Std 1588g-2022,
two YANG modules are provided by IEEE Std 1588e (MIB and
YANG Data Models). For a detailed explanation, see 15.4.2.11
of IEEE Std 1588e.
This module uses the original terminology specified by
IEEE Std 1588 (master/slave).

IEEE code is subject to the following copyright and license:
Copyright (c) 2020 by The Institute of Electrical and Electronics
Engineers, Inc. All rights reserved.
  """
  __slots__ = ('_path_helper', '_extmethods', '__ptp',)

  _yang_name = 'openconfig-ptp'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ptp = YANGDynClass(base=ptp.ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ptp(self):
    """
    Getter method for ptp, mapped from YANG variable /ptp (container)

    YANG Description: Contains all YANG nodes for the PTP data sets. This hierarchy can be
augmented with YANG nodes for a specific vendor or PTP Profile.
    """
    return self.__ptp
      
  def _set_ptp(self, v, load=False):
    """
    Setter method for ptp, mapped from YANG variable /ptp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptp() directly.

    YANG Description: Contains all YANG nodes for the PTP data sets. This hierarchy can be
augmented with YANG nodes for a specific vendor or PTP Profile.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ptp.ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ptp.ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)""",
        })

    self.__ptp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptp(self):
    self.__ptp = YANGDynClass(base=ptp.ptp, is_container='container', yang_name="ptp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='container', is_config=True)

  ptp = __builtin__.property(_get_ptp, _set_ptp)


  _pyangbind_elements = OrderedDict([('ptp', ptp), ])


class openconfig_grpc_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-grpc-types - based on the path /openconfig-grpc-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds gRPC server type relating to gRPC services running on
a network device.
The GRPC_SERVICE identity is used to create an extensible list of services
that can be instantiated, with a base set defined in this module. New
services can extend the identity to be included in the list.
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_l3(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l3 - based on the path /openconfig-network-instance-l3. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains groupings which specifically relate to
Layer 3 network instance configuration and operational state
parameters.
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-policy - based on the path /openconfig-network-instance-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines routing policy statements (conditions and
actions) for the network instance model.  These statements are
generally added to the routing policy model.
  """
  _pyangbind_elements = {}

  

from . import network_instances
class openconfig_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /openconfig-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig description of a network-instance. This may be
a Layer 3 forwarding construct such as a virtual routing and
forwarding (VRF) instance, or a Layer 2 instance such as a
virtual switch instance (VSI). Mixed Layer 2 and Layer 3
instances are also supported.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instances',)

  _yang_name = 'openconfig-network-instance'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instances = YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instances(self):
    """
    Getter method for network_instances, mapped from YANG variable /network_instances (container)

    YANG Description: The L2, L3, or L2+L3 forwarding instances that are
configured on the local system
    """
    return self.__network_instances
      
  def _set_network_instances(self, v, load=False):
    """
    Setter method for network_instances, mapped from YANG variable /network_instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instances() directly.

    YANG Description: The L2, L3, or L2+L3 forwarding instances that are
configured on the local system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instances(self):
    self.__network_instances = YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  network_instances = __builtin__.property(_get_network_instances, _set_network_instances)


  _pyangbind_elements = OrderedDict([('network_instances', network_instances), ])


from . import network_instances
class openconfig_network_instance_l2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /openconfig-network-instance-l2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains groupings which specifically relate to
Layer 2 network instance configuration and operational state
parameters.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_instances',)

  _yang_name = 'openconfig-network-instance-l2'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_instances = YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_network_instances(self):
    """
    Getter method for network_instances, mapped from YANG variable /network_instances (container)

    YANG Description: The L2, L3, or L2+L3 forwarding instances that are
configured on the local system
    """
    return self.__network_instances
      
  def _set_network_instances(self, v, load=False):
    """
    Setter method for network_instances, mapped from YANG variable /network_instances (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_instances() directly.

    YANG Description: The L2, L3, or L2+L3 forwarding instances that are
configured on the local system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_instances must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)""",
        })

    self.__network_instances = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_instances(self):
    self.__network_instances = YANGDynClass(base=network_instances.network_instances, is_container='container', yang_name="network-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='container', is_config=True)

  network_instances = __builtin__.property(_get_network_instances, _set_network_instances)


  _pyangbind_elements = OrderedDict([('network_instances', network_instances), ])


class openconfig_programming_errors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-programming-errors - based on the path /openconfig-programming-errors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides detailed information about the hardware programming
state of various types of routes within a particular network instance.
It can be used to track where there are routing hardware programming errors
on a device.
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_static(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-static - based on the path /openconfig-network-instance-static. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Static configurations associated with a network instance
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_l2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /openconfig-network-instance-l2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains groupings which specifically relate to
Layer 2 network instance configuration and operational state
parameters.
  """
  _pyangbind_elements = {}

  

class openconfig_evpn(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-evpn - based on the path /openconfig-evpn. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in EVPN.
The model contains the configuration and state attributes
imported by the OpenConfig network instance module that is
the primary holder of these properties.

The module describes the configuration and state parameters
to support the instantiation of the MAC-VRF concept defined
in the RFC 7432: BGP MPLS-Based Ethernet VPN.
The EVPN concept allows the  Media Access Control (MAC) addresses
forwarding through the control plane on a PE.

Within the OpenConfig model, a single network instance represents
an individual MAC VRF. Whilst it is possible that there may be
cases where a single MAC VRF may support multiple broadcast
domains, this is not currently supported and requires an extension
of the model.
  """
  _pyangbind_elements = {}

  

class openconfig_evpn_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-evpn-types - based on the path /openconfig-evpn-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in EVPN
policy. It can be imported by modules that make use of EVPN
attributes
  """
  _pyangbind_elements = {}

  

class openconfig_network_instance_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-types - based on the path /openconfig-network-instance-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Types associated with a network instance
  """
  _pyangbind_elements = {}

  

from . import defined_sets
class openconfig_defined_sets(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-defined-sets - based on the path /openconfig-defined-sets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state
data for defined sets (sets of IPv4 prefixes, sets of
IPv6 prefixes, sets of ports, etc). These sets are used,
for example, in network access control lists (i.e., filters,
rules, etc.) in the matching fields.
  """
  __slots__ = ('_path_helper', '_extmethods', '__defined_sets',)

  _yang_name = 'openconfig-defined-sets'
  _yang_namespace = 'http://openconfig.net/yang/defined-sets'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__defined_sets = YANGDynClass(base=defined_sets.defined_sets, is_container='container', yang_name="defined-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/defined-sets', defining_module='openconfig-defined-sets', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_defined_sets(self):
    """
    Getter method for defined_sets, mapped from YANG variable /defined_sets (container)

    YANG Description: Top level enclosing container for defined-set model
config and operational state data.
    """
    return self.__defined_sets
      
  def _set_defined_sets(self, v, load=False):
    """
    Setter method for defined_sets, mapped from YANG variable /defined_sets (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_defined_sets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_defined_sets() directly.

    YANG Description: Top level enclosing container for defined-set model
config and operational state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=defined_sets.defined_sets, is_container='container', yang_name="defined-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/defined-sets', defining_module='openconfig-defined-sets', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """defined_sets must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=defined_sets.defined_sets, is_container='container', yang_name="defined-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/defined-sets', defining_module='openconfig-defined-sets', yang_type='container', is_config=True)""",
        })

    self.__defined_sets = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_defined_sets(self):
    self.__defined_sets = YANGDynClass(base=defined_sets.defined_sets, is_container='container', yang_name="defined-sets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/defined-sets', defining_module='openconfig-defined-sets', yang_type='container', is_config=True)

  defined_sets = __builtin__.property(_get_defined_sets, _set_defined_sets)


  _pyangbind_elements = OrderedDict([('defined_sets', defined_sets), ])


from . import lldp
class openconfig_lldp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lldp - based on the path /openconfig-lldp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for the LLDP protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lldp',)

  _yang_name = 'openconfig-lldp'
  _yang_namespace = 'http://openconfig.net/yang/lldp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lldp = YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_lldp(self):
    """
    Getter method for lldp, mapped from YANG variable /lldp (container)

    YANG Description: Top-level container for LLDP configuration and state data
    """
    return self.__lldp
      
  def _set_lldp(self, v, load=False):
    """
    Setter method for lldp, mapped from YANG variable /lldp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lldp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lldp() directly.

    YANG Description: Top-level container for LLDP configuration and state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lldp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)""",
        })

    self.__lldp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lldp(self):
    self.__lldp = YANGDynClass(base=lldp.lldp, is_container='container', yang_name="lldp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lldp', defining_module='openconfig-lldp', yang_type='container', is_config=True)

  lldp = __builtin__.property(_get_lldp, _set_lldp)


  _pyangbind_elements = OrderedDict([('lldp', lldp), ])


class openconfig_lldp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lldp-types - based on the path /openconfig-lldp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the LLDP protocol model.
  """
  _pyangbind_elements = {}

  

class openconfig_qos_elements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /openconfig-qos-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated with QoS elements.  The primary elements of
the model include:

 classifiers: match packets with a specific characteristic

 forwarding groups: logical class of packets that receive
 common forwarding treatment

 queues:  collection of packets to be scheduled, including
 a queue management scheme

 schedulers: sequence of one more elements that schedule
 packets for transmission, including policer and shaper
 functions
  """
  _pyangbind_elements = {}

  

class openconfig_qos_mem_mgmt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-mem-mgmt - based on the path /openconfig-qos-mem-mgmt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated related to queue management features of QoS
particularly:

- buffer-allocation-profiles: these profiles are applied on
 a per-interface basis, and determine how memory is to be managed
 across the queues that are instantiated on the system.

- queue-management-profiles: these profiles are applied on a per-interface
 per-queue basis, and determine how packets are marked/dropped within
 the queue instantiation.
  """
  _pyangbind_elements = {}

  

class openconfig_qos_elements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /openconfig-qos-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated with QoS elements.  The primary elements of
the model include:

 classifiers: match packets with a specific characteristic

 forwarding groups: logical class of packets that receive
 common forwarding treatment

 queues:  collection of packets to be scheduled, including
 a queue management scheme

 schedulers: sequence of one more elements that schedule
 packets for transmission, including policer and shaper
 functions
  """
  _pyangbind_elements = {}

  

class openconfig_qos_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-interfaces - based on the path /openconfig-qos-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines data related to quality-of-service
configuration and operational state associated with
interfaces.
  """
  _pyangbind_elements = {}

  

class openconfig_qos_elements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /openconfig-qos-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated with QoS elements.  The primary elements of
the model include:

 classifiers: match packets with a specific characteristic

 forwarding groups: logical class of packets that receive
 common forwarding treatment

 queues:  collection of packets to be scheduled, including
 a queue management scheme

 schedulers: sequence of one more elements that schedule
 packets for transmission, including policer and shaper
 functions
  """
  _pyangbind_elements = {}

  

class openconfig_qos_mem_mgmt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-mem-mgmt - based on the path /openconfig-qos-mem-mgmt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated related to queue management features of QoS
particularly:

- buffer-allocation-profiles: these profiles are applied on
 a per-interface basis, and determine how memory is to be managed
 across the queues that are instantiated on the system.

- queue-management-profiles: these profiles are applied on a per-interface
 per-queue basis, and determine how packets are marked/dropped within
 the queue instantiation.
  """
  _pyangbind_elements = {}

  

from . import qos
class openconfig_qos(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos - based on the path /openconfig-qos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to network quality-of-service.
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos',)

  _yang_name = 'openconfig-qos'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)

    YANG Description: Top-level container for QoS data
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: Top-level container for QoS data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = OrderedDict([('qos', qos), ])


from . import qos
class openconfig_qos_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-interfaces - based on the path /openconfig-qos-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines data related to quality-of-service
configuration and operational state associated with
interfaces.
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos',)

  _yang_name = 'openconfig-qos-interfaces'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)

    YANG Description: Top-level container for QoS data
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: Top-level container for QoS data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = OrderedDict([('qos', qos), ])


from . import qos
class openconfig_qos_elements(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-elements - based on the path /openconfig-qos-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated with QoS elements.  The primary elements of
the model include:

 classifiers: match packets with a specific characteristic

 forwarding groups: logical class of packets that receive
 common forwarding treatment

 queues:  collection of packets to be scheduled, including
 a queue management scheme

 schedulers: sequence of one more elements that schedule
 packets for transmission, including policer and shaper
 functions
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos',)

  _yang_name = 'openconfig-qos-elements'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)

    YANG Description: Top-level container for QoS data
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: Top-level container for QoS data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = OrderedDict([('qos', qos), ])


from . import qos
class openconfig_qos_mem_mgmt(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-mem-mgmt - based on the path /openconfig-qos-mem-mgmt. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule defines configuration and operational state
data associated related to queue management features of QoS
particularly:

- buffer-allocation-profiles: these profiles are applied on
 a per-interface basis, and determine how memory is to be managed
 across the queues that are instantiated on the system.

- queue-management-profiles: these profiles are applied on a per-interface
 per-queue basis, and determine how packets are marked/dropped within
 the queue instantiation.
  """
  __slots__ = ('_path_helper', '_extmethods', '__qos',)

  _yang_name = 'openconfig-qos-mem-mgmt'
  _yang_namespace = 'http://openconfig.net/yang/qos'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_qos(self):
    """
    Getter method for qos, mapped from YANG variable /qos (container)

    YANG Description: Top-level container for QoS data
    """
    return self.__qos
      
  def _set_qos(self, v, load=False):
    """
    Setter method for qos, mapped from YANG variable /qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: Top-level container for QoS data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """qos must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)""",
        })

    self.__qos = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_qos(self):
    self.__qos = YANGDynClass(base=qos.qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/qos', defining_module='openconfig-qos', yang_type='container', is_config=True)

  qos = __builtin__.property(_get_qos, _set_qos)


  _pyangbind_elements = OrderedDict([('qos', qos), ])


class openconfig_qos_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-qos-types - based on the path /openconfig-qos-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types and identities used in OpenConfig
models related to quality-of-service (QoS)
  """
  _pyangbind_elements = {}

  

class openconfig_catalog_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-catalog-types - based on the path /openconfig-catalog-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types and identities used by the OpenConfig
YANG module catalog model.
  """
  _pyangbind_elements = {}

  

from . import organizations
class openconfig_module_catalog(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-module-catalog - based on the path /openconfig-module-catalog. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a schema for cataloging and descrbing
YANG models published across various organizations.  The catalog
contains several categories of data:

* organizations -- entities that publish and/or maintain
 individual YANG modules or groups of modules

* modules -- information regarding individual YANG modules,
 including their versions, dependencies, submodules, and how
 to access them

* release bundles -- groups of modules that are compatible and
 consistent with each other (as determined by the publisher of
 of the bundle).  The release bundle does not necessarily
 correspond to a functional area, e.g., it could the entire
 set of modules published by an organization

* feature bundles -- sets of schema paths across a
 release bundle that provide a specific set of functionality

* implementations -- information about available module and/or
 bundle implementations and their status
  """
  __slots__ = ('_path_helper', '_extmethods', '__organizations',)

  _yang_name = 'openconfig-module-catalog'
  _yang_namespace = 'http://openconfig.net/yang/module-catalog'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__organizations = YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/module-catalog', defining_module='openconfig-module-catalog', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_organizations(self):
    """
    Getter method for organizations, mapped from YANG variable /organizations (container)

    YANG Description: List of organizations owning modules
    """
    return self.__organizations
      
  def _set_organizations(self, v, load=False):
    """
    Setter method for organizations, mapped from YANG variable /organizations (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_organizations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_organizations() directly.

    YANG Description: List of organizations owning modules
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=organizations.organizations, is_container='container', yang_name="organizations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/module-catalog', defining_module='openconfig-module-catalog', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """organizations must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/module-catalog', defining_module='openconfig-module-catalog', yang_type='container', is_config=True)""",
        })

    self.__organizations = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_organizations(self):
    self.__organizations = YANGDynClass(base=organizations.organizations, is_container='container', yang_name="organizations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/module-catalog', defining_module='openconfig-module-catalog', yang_type='container', is_config=True)

  organizations = __builtin__.property(_get_organizations, _set_organizations)


  _pyangbind_elements = OrderedDict([('organizations', organizations), ])


class openconfig_platform_healthz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-healthz - based on the path /openconfig-platform-healthz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model defines health-related variables for components
within the openconfig-platform model (which defines the
the /components hierarchy). It is designed to be used in
conjunction with the gNOI Healthz service (see
https://github.com/openconfig/gnoi/blob/main/healthz/README.md).

The health variables included in this model are streamed via
telemetry interfaces, where gNOI.Healthz is used to retrieve
further diagnostic and debugging informaton from a network
device.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /openconfig-platform-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This modules contains common groupings that are used in multiple
components within the platform module.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_fan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-fan - based on the path /openconfig-platform-fan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to FAN components in the
OpenConfig platform model.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_psu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-psu - based on the path /openconfig-platform-psu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a schema for power supply components in
the OpenConfig platform model.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-types - based on the path /openconfig-platform-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data types (e.g., YANG identities)
to support the OpenConfig component inventory model.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-ext - based on the path /openconfig-platform-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines optional extensions to the OpenConfig
platform model.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-storage - based on the path /openconfig-platform-storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to STORAGE components in the
OpenConfig platform model.

 Portions of this code were derived from the following copyright holders.
 References to each copyright holder are mentioned where related content
 is used.

 NVM Express Base Specification Revision 2.0a
 https://nvmexpress.org/wp-content/uploads/NVMe-NVM-Express-2.0a-2021.07.26-Ratified.pdf
 (c) Copyright 2007 to 2021 NVM Express, Inc. ALL RIGHTS RESERVED.
 This NVM Express Base Specification, revision 2.0a is proprietary to the
 NVM Express, Inc. (also referred to as Company) and/or its successors
 and assigns.

 S.M.A.R.T. Attribute: Reallocated Sectors Count | Knowledge Base
 http://kb.acronis.com.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_fabric(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-fabric - based on the path /openconfig-platform-fabric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to FABRIC components in
the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_software(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-software - based on the path /openconfig-platform-software. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to software components in
 the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-port - based on the path /openconfig-platform-port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to PORT components in the
openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_transceiver(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-transceiver - based on the path /openconfig-platform-transceiver. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for transceivers (i.e., pluggable optics).  The module should be
used in conjunction with the platform model where other
physical entity data are represented.

In the platform model, a component of type=TRANSCEIVER is
expected to be a subcomponent of a PORT component.  This
module defines a concrete schema for the associated data for
components with type=TRANSCEIVER.

A transceiver will always contain physical-channel(s), however
when a line side optical-channel is present (i.e. ZR+ optics)
the physical-channel will reference its optical-channel.
In this case, the optical-channels components must be
subcomponents of the transceiver. The relationship between the
physical-channel and the optical-channel allows for multiple
optical-channels to be associated with a transceiver in addition
to ensuring certain leaves (i.e. output-power) are not duplicated
in multiple components.

If a transceiver contains a digital signal processor (DSP), such
as with ZR+ optics, the modeling will utilize hierarchical
components as follows:
PORT --> TRANSCEIVER --> OPTICAL_CHANNEL(s)
The signal will then traverse through a series of
terminal-device/logical-channels as required. The first
logical-channel connected to the OPTICAL_CHANNEL will utilize the
assignment/optical-channel leaf to create the relationship. At the
conclusion of the series of logical-channels, the logical-channel
will be associated to its host / client side based on:
* If the TRANSCEIVER is directly within a router or switch, then
 it will use the logical-channel ingress leaf to specify the
 interface it is associated with.
* If the TRANSCEIVER is within a dedicated terminal (Layer 1)
 device, then it will use the logical-channel ingress leaf to
 specify a physical-channel within a TRANSCEIVER component
 (i.e. gray optic) that it is associated with.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_linecard(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-linecard - based on the path /openconfig-platform-linecard. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to LINECARD components in
the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_controller_card(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-controller-card - based on the path /openconfig-platform-controller-card. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to CONTROLLER_CARD components in
the openconfig-platform model
  """
  _pyangbind_elements = {}

  

class openconfig_platform_integrated_circuit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-integrated-circuit - based on the path /openconfig-platform-integrated-circuit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines extensions to the OpenConfig platform model
that apply to integrated circuit (INTEGRATED_CIRCUIT) components.
These components are generically forwarding NPUs or ASICs within
the system for which configuration or state is applicable.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_pipeline_counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-pipeline-counters - based on the path /openconfig-platform-pipeline-counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provide fine grain, per-Integrated Circuit (IC), telemetry data streams
that will identify the health, any packet drops, and any errors on the IC.
With this additional telemetry, the health of the IC, packet drops and
errors, can be explicitly monitored not only on a specific router, but also
on a specific IC on a specific router. The IC is divided into 5 platform
independent sub-blocks.
 1. IC Interface Subsystem
 2. Queueing Subsystem
 3. Lookup Subsystem
 4. Host Interface
 5. Fabric Interface.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
|                                                                   |
| +---------------------------------------------------------------+ |
| | Integrated +---------------------------------------+          | |
| | Circuit    |     Host Interface                    |          | |
| |            +---------------------------------------+          | |
| |               +------------+                                  | |
| | +-----------+ |  Lookup    |                  +-------------+ | |
| | | IC        | |  Subsystem |                  |  Fabric     | | |
| | | Interface | |            |                  | Interface   | | |
| | | Subsystem | +------------+                  |             | | |
| | +-----------+                +-------------+  +-------------+ | |
| |                              | Queueing    |                  | |
| |                              | Subsystem   |                  | |
| |                              +-------------+                  | |
| |                                                               | |
| +---------------------------------------------------------------+ |
|                                                                   |
+-------------------------------------------------------------------+
Each IC implementation inside forwarding engines may have a different set of
counters. Some counters have different names but the same
functionality and can be grouped together. Most counters are different
between IC families and will have to be aggregated as generic counters. The
aggregation could mean either a specific IC counter needs to be mapped to
one of the values specified in this model, or it may require multiple IC
counters aggregated to produce one of the values in this model.
The following classes of counters will generalize the types of
statistics that are provided from each of the above 5 blocks.
 A. Packet Counters
 B. Drop Counters
 C. Error Counters
The advantage of grouping all the packet counters for all 5 blocks,
all drop counters from all 5 blocks, and all error counters from all
5 blocks, is to have the abililty to receive all drop counters from
all 5 blocks, for example, with one request.
  """
  _pyangbind_elements = {}

  

class openconfig_platform_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-cpu - based on the path /openconfig-platform-cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to FAN components in the
OpenConfig platform model.
  """
  _pyangbind_elements = {}

  

from . import components
class openconfig_platform(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /openconfig-platform. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a data model for representing a system
component inventory, which can include hardware or software
elements arranged in an arbitrary structure. The primary
relationship supported by the model is containment, e.g.,
components containing subcomponents.

It is expected that this model reflects every field replacable
unit on the device at a minimum (i.e., additional information
may be supplied about non-replacable components).

Every element in the inventory is termed a 'component' with each
component expected to have a unique name and type, and optionally
a unique system-assigned identifier and FRU number.  The
uniqueness is guaranteed by the system within the device.

Components may have properties defined by the system that are
modeled as a list of key-value pairs. These may or may not be
user-configurable.  The model provides a flag for the system
to optionally indicate which properties are user configurable.

Each component also has a list of 'subcomponents' which are
references to other components. Appearance in a list of
subcomponents indicates a containment relationship as described
above.  For example, a linecard component may have a list of
references to port components that reside on the linecard.

This schema is generic to allow devices to express their own
platform-specific structure.  It may be augmented by additional
component type-specific schemas that provide a common structure
for well-known component types.  In these cases, the system is
expected to populate the common component schema, and may
optionally also represent the component and its properties in the
generic structure.

The properties for each component may include dynamic values,
e.g., in the 'state' part of the schema.  For example, a CPU
component may report its utilization, temperature, or other
physical properties.  The intent is to capture all platform-
specific physical data in one location, including inventory
(presence or absence of a component) and state (physical
attributes or status).
  """
  __slots__ = ('_path_helper', '_extmethods', '__components',)

  _yang_name = 'openconfig-platform'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__components = YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_components(self):
    """
    Getter method for components, mapped from YANG variable /components (container)

    YANG Description: Enclosing container for the components in the system.
    """
    return self.__components
      
  def _set_components(self, v, load=False):
    """
    Setter method for components, mapped from YANG variable /components (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_components is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_components() directly.

    YANG Description: Enclosing container for the components in the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """components must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__components = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_components(self):
    self.__components = YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  components = __builtin__.property(_get_components, _set_components)


  _pyangbind_elements = OrderedDict([('components', components), ])


from . import components
class openconfig_platform_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /openconfig-platform-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This modules contains common groupings that are used in multiple
components within the platform module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__components',)

  _yang_name = 'openconfig-platform-common'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__components = YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_components(self):
    """
    Getter method for components, mapped from YANG variable /components (container)

    YANG Description: Enclosing container for the components in the system.
    """
    return self.__components
      
  def _set_components(self, v, load=False):
    """
    Setter method for components, mapped from YANG variable /components (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_components is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_components() directly.

    YANG Description: Enclosing container for the components in the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """components must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__components = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_components(self):
    self.__components = YANGDynClass(base=components.components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  components = __builtin__.property(_get_components, _set_components)


  _pyangbind_elements = OrderedDict([('components', components), ])


class openconfig_ate_intf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ate-intf - based on the path /openconfig-ate-intf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines augments to the OpenConfig tree specifically for
automated test equipment (ATE) devices. These parameters are not widely
supported by non-ATE devices.
  """
  _pyangbind_elements = {}

  

from . import flows
class openconfig_ate_flow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ate-flow - based on the path /openconfig-ate-flow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines telemetry that relates to flows that are tracked
by a network device, or automated test equipment. A flow is an arbitrary
stream of packets whose definition is outside of the context of this
module.
  """
  __slots__ = ('_path_helper', '_extmethods', '__flows',)

  _yang_name = 'openconfig-ate-flow'
  _yang_namespace = 'http://openconfig.net/yang/ate-flow'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__flows = YANGDynClass(base=flows.flows, is_container='container', yang_name="flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ate-flow', defining_module='openconfig-ate-flow', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_flows(self):
    """
    Getter method for flows, mapped from YANG variable /flows (container)

    YANG Description: Flow statistics collected by the network device. A flow is defined to
be an arbitrary stream of packets whose definition is outside of the
context of the module.
    """
    return self.__flows
      
  def _set_flows(self, v, load=False):
    """
    Setter method for flows, mapped from YANG variable /flows (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flows is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flows() directly.

    YANG Description: Flow statistics collected by the network device. A flow is defined to
be an arbitrary stream of packets whose definition is outside of the
context of the module.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=flows.flows, is_container='container', yang_name="flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ate-flow', defining_module='openconfig-ate-flow', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flows must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=flows.flows, is_container='container', yang_name="flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ate-flow', defining_module='openconfig-ate-flow', yang_type='container', is_config=True)""",
        })

    self.__flows = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flows(self):
    self.__flows = YANGDynClass(base=flows.flows, is_container='container', yang_name="flows", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ate-flow', defining_module='openconfig-ate-flow', yang_type='container', is_config=True)

  flows = __builtin__.property(_get_flows, _set_flows)


  _pyangbind_elements = OrderedDict([('flows', flows), ])


class openconfig_flexalgo(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-flexalgo - based on the path /openconfig-flexalgo. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This YANG module defines the configurational and operational
parameters related to IGP Flex-Algorithms
  """
  _pyangbind_elements = {}

  

class openconfig_sampling_sflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-sampling-sflow - based on the path /openconfig-sampling-sflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to data plane traffic sampling based on sFlow.

RFC 3176 - InMon Corporation's sFlow: A Method for
Monitoring Traffic in Switched and Routed Networks
  """
  _pyangbind_elements = {}

  

from . import sampling
class openconfig_sampling(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-sampling - based on the path /openconfig-sampling. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines top-level configuration and operational
state data related to traffic sampling.

For modularity purposes, the top-level sampling container provides
a natural attachment point for implementations such as sFlow, IPFix,
NETFLOW
  """
  __slots__ = ('_path_helper', '_extmethods', '__sampling',)

  _yang_name = 'openconfig-sampling'
  _yang_namespace = 'http://openconfig.net/yang/sampling'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__sampling = YANGDynClass(base=sampling.sampling, is_container='container', yang_name="sampling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/sampling', defining_module='openconfig-sampling', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_sampling(self):
    """
    Getter method for sampling, mapped from YANG variable /sampling (container)

    YANG Description: Top-level container for sampling-related configuration and
operational state data
    """
    return self.__sampling
      
  def _set_sampling(self, v, load=False):
    """
    Setter method for sampling, mapped from YANG variable /sampling (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sampling is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sampling() directly.

    YANG Description: Top-level container for sampling-related configuration and
operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=sampling.sampling, is_container='container', yang_name="sampling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/sampling', defining_module='openconfig-sampling', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sampling must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=sampling.sampling, is_container='container', yang_name="sampling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/sampling', defining_module='openconfig-sampling', yang_type='container', is_config=True)""",
        })

    self.__sampling = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sampling(self):
    self.__sampling = YANGDynClass(base=sampling.sampling, is_container='container', yang_name="sampling", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/sampling', defining_module='openconfig-sampling', yang_type='container', is_config=True)

  sampling = __builtin__.property(_get_sampling, _set_sampling)


  _pyangbind_elements = OrderedDict([('sampling', sampling), ])


from . import terminal_device
class openconfig_terminal_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device - based on the path /openconfig-terminal-device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a terminal optics device model for
managing the terminal systems (client and line side) in a
DWDM transport network.

Elements of the model:

physical port: corresponds to a physical, pluggable client
port on the terminal device. Examples includes 10G, 40G, 100G
(e.g., 10x10G, 4x25G or 1x100G) and 400G/1T in the future.
Physical client ports will have associated operational state or
PMs.

physical channel: a physical lane or channel in the
physical client port.  Each physical client port has 1 or more
channels. An example is 100GBASE-LR4 client physical port having
4x25G channels. Channels have their own optical PMs and can be
monitored independently within a client physical port (e.g.,
channel power).  Physical client channels are defined in the
model as part of a physical client port, and are modeled
primarily for reading their PMs.

logical channel: a logical grouping of logical grooming elements
that may be assigned to subsequent grooming stages for
multiplexing / de-multiplexing, or to an optical channel for
line side transmission.  The logical channels can represent, for
example, an ODU/OTU logical packing of the client
data onto the line side.  Tributaries are similarly logical
groupings of demand that can be represented in this structure and
assigned to an optical channel.  Note that different types of
logical channels may be present, each with their corresponding
PMs.

optical channel:  corresponds to an optical carrier and is
assigned a wavelength/frequency.  Optical channels have PMs
such as power, BER, and operational mode.

Directionality:

To maintain simplicity in the model, the configuration is
described from client-to-line direction.  The assumption is that
equivalent reverse configuration is implicit, resulting in
the same line-to-client configuration.

Physical layout:

The model does not assume a particular physical layout of client
and line ports on the terminal device (e.g., such as number of
ports per linecard, separate linecards for client and line ports,
etc.).
  """
  __slots__ = ('_path_helper', '_extmethods', '__terminal_device',)

  _yang_name = 'openconfig-terminal-device'
  _yang_namespace = 'http://openconfig.net/yang/terminal-device'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__terminal_device = YANGDynClass(base=terminal_device.terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_terminal_device(self):
    """
    Getter method for terminal_device, mapped from YANG variable /terminal_device (container)

    YANG Description: Top-level container for the terminal device
    """
    return self.__terminal_device
      
  def _set_terminal_device(self, v, load=False):
    """
    Setter method for terminal_device, mapped from YANG variable /terminal_device (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminal_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminal_device() directly.

    YANG Description: Top-level container for the terminal device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=terminal_device.terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """terminal_device must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=terminal_device.terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)""",
        })

    self.__terminal_device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_terminal_device(self):
    self.__terminal_device = YANGDynClass(base=terminal_device.terminal_device, is_container='container', yang_name="terminal-device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/terminal-device', defining_module='openconfig-terminal-device', yang_type='container', is_config=True)

  terminal_device = __builtin__.property(_get_terminal_device, _set_terminal_device)


  _pyangbind_elements = OrderedDict([('terminal_device', terminal_device), ])


from . import connections
class openconfig_transport_line_connectivity(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-connectivity - based on the path /openconfig-transport-line-connectivity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes the device-level connectivity
(e.g., internal port-to-port) for optical transport line
system elements such as wavelength routers (ROADMs) and
amplifiers. All connections are uni-directional. Note that
this model explicitly does not intend to model or provide
a path to any higher layer topology modeling and is only
for modeling internal links
  """
  __slots__ = ('_path_helper', '_extmethods', '__connections',)

  _yang_name = 'openconfig-transport-line-connectivity'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-transport-line-connectivity'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__connections = YANGDynClass(base=connections.connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_connections(self):
    """
    Getter method for connections, mapped from YANG variable /connections (container)

    YANG Description: Enclosing container for line system connections list
    """
    return self.__connections
      
  def _set_connections(self, v, load=False):
    """
    Setter method for connections, mapped from YANG variable /connections (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connections is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connections() directly.

    YANG Description: Enclosing container for line system connections list
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=connections.connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connections must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=connections.connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)""",
        })

    self.__connections = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connections(self):
    self.__connections = YANGDynClass(base=connections.connections, is_container='container', yang_name="connections", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-transport-line-connectivity', defining_module='openconfig-transport-line-connectivity', yang_type='container', is_config=True)

  connections = __builtin__.property(_get_connections, _set_connections)


  _pyangbind_elements = OrderedDict([('connections', connections), ])


from . import optical_attenuator
class openconfig_optical_attenuator(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-attenuator - based on the path /openconfig-optical-attenuator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for variable optical attenuators, deployed as part of a transport
line system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optical_attenuator',)

  _yang_name = 'openconfig-optical-attenuator'
  _yang_namespace = 'http://openconfig.net/yang/optical-attenuator'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_attenuator = YANGDynClass(base=optical_attenuator.optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_optical_attenuator(self):
    """
    Getter method for optical_attenuator, mapped from YANG variable /optical_attenuator (container)

    YANG Description: Enclosing container for attenuators
    """
    return self.__optical_attenuator
      
  def _set_optical_attenuator(self, v, load=False):
    """
    Setter method for optical_attenuator, mapped from YANG variable /optical_attenuator (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_attenuator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_attenuator() directly.

    YANG Description: Enclosing container for attenuators
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=optical_attenuator.optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_attenuator must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=optical_attenuator.optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)""",
        })

    self.__optical_attenuator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_attenuator(self):
    self.__optical_attenuator = YANGDynClass(base=optical_attenuator.optical_attenuator, is_container='container', yang_name="optical-attenuator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-attenuator', defining_module='openconfig-optical-attenuator', yang_type='container', is_config=True)

  optical_attenuator = __builtin__.property(_get_optical_attenuator, _set_optical_attenuator)


  _pyangbind_elements = OrderedDict([('optical_attenuator', optical_attenuator), ])


from . import wavelength_router
class openconfig_wavelength_router(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-wavelength-router - based on the path /openconfig-wavelength-router. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for an optical transport line system node, or ROADM (incl. CDC
ROADMs, WSS, Dynamic Gain Equalizer/DGE).

Nodes are modeled as a configurable switching element with
ingress and egress ports, as well as a number of add/drop ports
that can be set up to direct portions of the optical spectrum
to the appropriate degrees.

In relation to configuring target spectrum powers, there
are two, non-overlapping, configuration possibilities that are
supported.
1. Non-noise loaded wavelength router:
  - The target spectrum powers are configured on each media
    channel.
2. Noise-loaded wavelength router:
  - The target spectrum power values will be configured as a
    target spectrum power profile over the full spectrum instead
    of individual media channels.
  """
  __slots__ = ('_path_helper', '_extmethods', '__wavelength_router',)

  _yang_name = 'openconfig-wavelength-router'
  _yang_namespace = 'http://openconfig.net/yang/wavelength-router'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__wavelength_router = YANGDynClass(base=wavelength_router.wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_wavelength_router(self):
    """
    Getter method for wavelength_router, mapped from YANG variable /wavelength_router (container)

    YANG Description: Top-level container for wavelength router device
    """
    return self.__wavelength_router
      
  def _set_wavelength_router(self, v, load=False):
    """
    Setter method for wavelength_router, mapped from YANG variable /wavelength_router (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wavelength_router is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wavelength_router() directly.

    YANG Description: Top-level container for wavelength router device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=wavelength_router.wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wavelength_router must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=wavelength_router.wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)""",
        })

    self.__wavelength_router = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wavelength_router(self):
    self.__wavelength_router = YANGDynClass(base=wavelength_router.wavelength_router, is_container='container', yang_name="wavelength-router", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/wavelength-router', defining_module='openconfig-wavelength-router', yang_type='container', is_config=True)

  wavelength_router = __builtin__.property(_get_wavelength_router, _set_wavelength_router)


  _pyangbind_elements = OrderedDict([('wavelength_router', wavelength_router), ])


class openconfig_transport_line_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-common - based on the path /openconfig-transport-line-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines common data elements for OpenConfig data
models for optical transport line system elements, such as
amplifiers and ROADMs (wavelength routers).
  """
  _pyangbind_elements = {}

  

class openconfig_transport_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-types - based on the path /openconfig-transport-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general type definitions and identities
for optical transport models.
  """
  _pyangbind_elements = {}

  

from . import channel_monitors
class openconfig_channel_monitor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-channel-monitor - based on the path /openconfig-channel-monitor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes operational state data for an optical
channel monitor (OCM) for optical transport line system
elements such as wavelength routers (ROADMs) and amplifiers.
  """
  __slots__ = ('_path_helper', '_extmethods', '__channel_monitors',)

  _yang_name = 'openconfig-channel-monitor'
  _yang_namespace = 'http://openconfig.net/yang/channel-monitor'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__channel_monitors = YANGDynClass(base=channel_monitors.channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_channel_monitors(self):
    """
    Getter method for channel_monitors, mapped from YANG variable /channel_monitors (container)

    YANG Description: Top-level container for optical channel monitors
    """
    return self.__channel_monitors
      
  def _set_channel_monitors(self, v, load=False):
    """
    Setter method for channel_monitors, mapped from YANG variable /channel_monitors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channel_monitors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channel_monitors() directly.

    YANG Description: Top-level container for optical channel monitors
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=channel_monitors.channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channel_monitors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=channel_monitors.channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)""",
        })

    self.__channel_monitors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channel_monitors(self):
    self.__channel_monitors = YANGDynClass(base=channel_monitors.channel_monitors, is_container='container', yang_name="channel-monitors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/channel-monitor', defining_module='openconfig-channel-monitor', yang_type='container', is_config=True)

  channel_monitors = __builtin__.property(_get_channel_monitors, _set_channel_monitors)


  _pyangbind_elements = OrderedDict([('channel_monitors', channel_monitors), ])


from . import optical_amplifier
class openconfig_optical_amplifier(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-optical-amplifier - based on the path /openconfig-optical-amplifier. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for optical amplifiers, deployed as part of a transport
line system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__optical_amplifier',)

  _yang_name = 'openconfig-optical-amplifier'
  _yang_namespace = 'http://openconfig.net/yang/optical-amplfier'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__optical_amplifier = YANGDynClass(base=optical_amplifier.optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_optical_amplifier(self):
    """
    Getter method for optical_amplifier, mapped from YANG variable /optical_amplifier (container)

    YANG Description: Enclosing container for amplifiers and supervisory channels
    """
    return self.__optical_amplifier
      
  def _set_optical_amplifier(self, v, load=False):
    """
    Setter method for optical_amplifier, mapped from YANG variable /optical_amplifier (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_optical_amplifier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_optical_amplifier() directly.

    YANG Description: Enclosing container for amplifiers and supervisory channels
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=optical_amplifier.optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """optical_amplifier must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=optical_amplifier.optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)""",
        })

    self.__optical_amplifier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_optical_amplifier(self):
    self.__optical_amplifier = YANGDynClass(base=optical_amplifier.optical_amplifier, is_container='container', yang_name="optical-amplifier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-amplfier', defining_module='openconfig-optical-amplifier', yang_type='container', is_config=True)

  optical_amplifier = __builtin__.property(_get_optical_amplifier, _set_optical_amplifier)


  _pyangbind_elements = OrderedDict([('optical_amplifier', optical_amplifier), ])


from . import aps
class openconfig_transport_line_protection(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /openconfig-transport-line-protection. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model describes configuration and operational state data
for optical line protection elements, deployed as part of a
transport line system. An Automatic Protection Switch (APS)
is typically installed in the same device as the amplifiers
and wave-router, however an APS can also be a standalone
device. In both scenarios, it serves the same purpose of
providing protection using two dark fiber pairs to ensure the
amplifiers can still receive a signal if one of the two fiber
pairs is broken. The APS port details and directionality are
shown below. The three major attributes, together with their
modifiers, define the behavior of the APS and can be prioritized
in the descending order as shown in the following table
  """
  __slots__ = ('_path_helper', '_extmethods', '__aps',)

  _yang_name = 'openconfig-transport-line-protection'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__aps = YANGDynClass(base=aps.aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_aps(self):
    """
    Getter method for aps, mapped from YANG variable /aps (container)

    YANG Description: Top level grouping for automatic protection switch data
    """
    return self.__aps
      
  def _set_aps(self, v, load=False):
    """
    Setter method for aps, mapped from YANG variable /aps (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aps is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aps() directly.

    YANG Description: Top level grouping for automatic protection switch data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=aps.aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aps must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=aps.aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)""",
        })

    self.__aps = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aps(self):
    self.__aps = YANGDynClass(base=aps.aps, is_container='container', yang_name="aps", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='container', is_config=True)

  aps = __builtin__.property(_get_aps, _set_aps)


  _pyangbind_elements = OrderedDict([('aps', aps), ])


class openconfig_openflow_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-openflow-types - based on the path /openconfig-openflow-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the Openflow configuration
and operational state model.
  """
  _pyangbind_elements = {}

  

class openconfig_openflow(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-openflow - based on the path /openconfig-openflow. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data for
Openflow.
  """
  _pyangbind_elements = {}

  

from . import lacp
class openconfig_lacp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-lacp - based on the path /openconfig-lacp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes configuration and operational state
data for Link Aggregation Control Protocol (LACP) for
managing aggregate interfaces.   It works in conjunction with
the OpenConfig interfaces and aggregate interfaces models.
  """
  __slots__ = ('_path_helper', '_extmethods', '__lacp',)

  _yang_name = 'openconfig-lacp'
  _yang_namespace = 'http://openconfig.net/yang/lacp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__lacp = YANGDynClass(base=lacp.lacp, is_container='container', yang_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_lacp(self):
    """
    Getter method for lacp, mapped from YANG variable /lacp (container)

    YANG Description: Configuration and operational state data for LACP protocol
operation on the aggregate interface
    """
    return self.__lacp
      
  def _set_lacp(self, v, load=False):
    """
    Setter method for lacp, mapped from YANG variable /lacp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lacp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lacp() directly.

    YANG Description: Configuration and operational state data for LACP protocol
operation on the aggregate interface
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=lacp.lacp, is_container='container', yang_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lacp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=lacp.lacp, is_container='container', yang_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=True)""",
        })

    self.__lacp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lacp(self):
    self.__lacp = YANGDynClass(base=lacp.lacp, is_container='container', yang_name="lacp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/lacp', defining_module='openconfig-lacp', yang_type='container', is_config=True)

  lacp = __builtin__.property(_get_lacp, _set_lacp)


  _pyangbind_elements = OrderedDict([('lacp', lacp), ])


class openconfig_spanning_tree_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-spanning-tree-types - based on the path /openconfig-spanning-tree-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the
spanning-tree protocol model.
  """
  _pyangbind_elements = {}

  

from . import stp
class openconfig_spanning_tree(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-spanning-tree - based on the path /openconfig-spanning-tree. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for the spanning tree protocol.
  """
  __slots__ = ('_path_helper', '_extmethods', '__stp',)

  _yang_name = 'openconfig-spanning-tree'
  _yang_namespace = 'http://openconfig.net/yang/spanning-tree'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__stp = YANGDynClass(base=stp.stp, is_container='container', yang_name="stp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/spanning-tree', defining_module='openconfig-spanning-tree', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_stp(self):
    """
    Getter method for stp, mapped from YANG variable /stp (container)

    YANG Description: Top-level container for spanning tree configuration and
state data
    """
    return self.__stp
      
  def _set_stp(self, v, load=False):
    """
    Setter method for stp, mapped from YANG variable /stp (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_stp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_stp() directly.

    YANG Description: Top-level container for spanning tree configuration and
state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=stp.stp, is_container='container', yang_name="stp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/spanning-tree', defining_module='openconfig-spanning-tree', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """stp must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=stp.stp, is_container='container', yang_name="stp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/spanning-tree', defining_module='openconfig-spanning-tree', yang_type='container', is_config=True)""",
        })

    self.__stp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_stp(self):
    self.__stp = YANGDynClass(base=stp.stp, is_container='container', yang_name="stp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/spanning-tree', defining_module='openconfig-spanning-tree', yang_type='container', is_config=True)

  stp = __builtin__.property(_get_stp, _set_stp)


  _pyangbind_elements = OrderedDict([('stp', stp), ])


class openconfig_pcep(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pcep - based on the path /openconfig-pcep. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
relating to Path Computation Element Protocol (PCEP) for communications
between a network element (router) acting as PCC and a PCE server,
according to RFC4655 definitions:

-PCC:  Path Computation Client; any client application requesting a
 path computation to be performed by a Path Computation Element.

-PCE:  Path Computation Element; an entity (component, application, or
 network node) that is capable of computing a network path or route
 based on a network graph and applying computational constraints.

Also according to RFC4655, a PCE can be either stateful or
stateless. In the former case, there is a strict synchronization
between the PCE and not only the network states (in term of
topology and resource information), but also the set of computed
paths and reserved resources in use in the network. Conversely,
stateless PCEs do not have to remember any computed path and each
set of request(s) is processed independently of each other. For
example, stateless PCEs may compute paths based on current TED
information, which could be out of sync with actual network state
given other recent PCE-computed paths changes.

On the other hand, RFC8051 defines for Stateful PCE two modes of
operation:

  -Passive Stateful PCE:  a PCE that uses LSP state information
   learned from PCCs to optimize path computations.  It does not
   actively update LSP state. A PCC maintains synchronization with
   the PCE.

  -Active Stateful PCE:  a PCE that may issue recommendations to
   the network. For example, an Active Stateful PCE may use the
   Delegation mechanism to update.

 LSP parameters in those PCCs that delegate control over their LSPs to
 the PCE.
  """
  _pyangbind_elements = {}

  

from . import ha_groups
class openconfig_fw_high_availability(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-fw-high-availability - based on the path /openconfig-fw-high-availability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model used to configure & monitor firewall High Availability(HA).
The model is comprised primarily of the following sections -
- Various global config parameters
(such as ha-group-id, ha-mode etc.)
- Control link configuration parameters
(control link is used to exchange HA control msgs)
- Data link configuration parameters
(data link is used to exchange information for seamless failover)
- HA timers

This model also imports/uses the link-monitoring module, to
determine  health of firewall cluster based on the status of the
interfaces being  monitored. Please see that module description
for additional details
  """
  __slots__ = ('_path_helper', '_extmethods', '__ha_groups',)

  _yang_name = 'openconfig-fw-high-availability'
  _yang_namespace = 'http://openconfig.net/yang/oc-fw-ha'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ha_groups = YANGDynClass(base=ha_groups.ha_groups, is_container='container', yang_name="ha-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ha_groups(self):
    """
    Getter method for ha_groups, mapped from YANG variable /ha_groups (container)

    YANG Description: Top level container for HA groups
    """
    return self.__ha_groups
      
  def _set_ha_groups(self, v, load=False):
    """
    Setter method for ha_groups, mapped from YANG variable /ha_groups (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_groups() directly.

    YANG Description: Top level container for HA groups
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ha_groups.ha_groups, is_container='container', yang_name="ha-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_groups must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ha_groups.ha_groups, is_container='container', yang_name="ha-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='container', is_config=True)""",
        })

    self.__ha_groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_groups(self):
    self.__ha_groups = YANGDynClass(base=ha_groups.ha_groups, is_container='container', yang_name="ha-groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='container', is_config=True)

  ha_groups = __builtin__.property(_get_ha_groups, _set_ha_groups)


  _pyangbind_elements = OrderedDict([('ha_groups', ha_groups), ])


class openconfig_fw_link_monitoring(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-fw-link-monitoring - based on the path /openconfig-fw-link-monitoring. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model defines interface groups and corresponding monitoring
policies for firewall HA groups.  It also provides modeling for a
global health monitoring policy for the HA group.
  """
  _pyangbind_elements = {}

  

class openconfig_codegen_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-codegen-extensions - based on the path /openconfig-codegen-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides OpenConfig-specific code generation extensions to the
YANG language.
  """
  _pyangbind_elements = {}

  

class openconfig_metadata(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-metadata - based on the path /openconfig-metadata. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines metadata types that are defined by
the OpenConfig group.
  """
  _pyangbind_elements = {}

  

class openconfig_vlan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-vlan - based on the path /openconfig-vlan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state variables for VLANs,
in addition to VLAN parameters associated with interfaces
  """
  _pyangbind_elements = {}

  

class openconfig_vlan_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-vlan-types - based on the path /openconfig-vlan-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state variables for VLANs,
in addition to VLAN parameters associated with interfaces
  """
  _pyangbind_elements = {}

  

class openconfig_system_utilization(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-utilization - based on the path /openconfig-system-utilization. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state for
system wide resource utilization thresholds.
  """
  _pyangbind_elements = {}

  

class openconfig_system_controlplane(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-controlplane - based on the path /openconfig-system-controlplane. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state relating to
policies for traffic destined to the system's control-plane.
Particularly, it allows for mechanisms to:
 - apply an ACL that forwards or drops traffic towards the control-plane.
 - classify traffic that is destined to the control-plane according to
   a QoS classifier.
 - schedule traffic that has been forwarded towards the control-plane,
   to allow for policies such as rate limits to be applied.
The configured policies apply generically to all control-planes that
exist within the system, and should be mapped to the internal interfaces
via which packets are forwarded to control-plane modules.
When a packet is received at an input interface - it is classified into a
forwarding group which drains to a specific queue. If this input mapping
is sufficient, the CPU-facing interface uses the specified scheduler
to determine how to drain queues. If more granular remapping is required
(e.g., to classify control-plane traffic more granularly), a user specifies
an alternate classifier that is used to reclassify traffic into
a new set of forwarding-groups (and hence queues) that can subsequently
be scheduled by the specified scheduler.
The specified control-plane ACL is applied to traffic received by the
control-plane of the system.
  """
  _pyangbind_elements = {}

  

class openconfig_hashing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-hashing - based on the path /openconfig-hashing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing hashing policies that would be referenced by the
interfaces model.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-types - based on the path /openconfig-aaa-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines shared types for data related to AAA
(authentication, authorization, accounting).
  """
  _pyangbind_elements = {}

  

class openconfig_system_terminal(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-terminal - based on the path /openconfig-system-terminal. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to remote terminal services such as ssh and telnet.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa - based on the path /openconfig-aaa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to authorization, authentication, and accounting (AAA)
management.

Portions of this model reuse data definitions or structure from
RFC 7317 - A YANG Data Model for System Management
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_tacacs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-tacacs - based on the path /openconfig-aaa-tacacs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the TACACS+ protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_radius(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-radius - based on the path /openconfig-aaa-radius. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the RADIUS protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_license(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-license - based on the path /openconfig-license. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational
state data for licenses.
  """
  _pyangbind_elements = {}

  

class openconfig_alarm_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-alarm-types - based on the path /openconfig-alarm-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines operational state data related to alarms
that the device is reporting.

This model reuses some data items defined in the draft IETF
YANG Alarm Module:
https://tools.ietf.org/html/draft-vallin-netmod-alarm-module-02

Portions of this code were derived from the draft IETF YANG Alarm
Module. Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_system_grpc(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-grpc - based on the path /openconfig-system-grpc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state relating to gRPC
services running on a network device. The GRPC_SERVICE identity is used
to create an extensible list of services that can be instantiated, with
a base set defined in this module. New services can extend the identity
to be included in the list.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_tacacs(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-tacacs - based on the path /openconfig-aaa-tacacs. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the TACACS+ protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_alarms(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-alarms - based on the path /openconfig-alarms. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines operational state data related to alarms
that the device is reporting.

This model reuses some data items defined in the draft IETF
YANG Alarm Module:
https://tools.ietf.org/html/draft-vallin-netmod-alarm-module-02

Portions of this code were derived from the draft IETF YANG Alarm
Module. Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_procmon(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-procmon - based on the path /openconfig-procmon. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides data definitions for process health
monitoring of one or more processes running on the system.
  """
  _pyangbind_elements = {}

  

from . import system
class openconfig_system(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system - based on the path /openconfig-system. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing system-wide services and functions on
network devices.

Portions of this code were derived from IETF RFC 7317.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  __slots__ = ('_path_helper', '_extmethods', '__system',)

  _yang_name = 'openconfig-system'
  _yang_namespace = 'http://openconfig.net/yang/system'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__system = YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_system(self):
    """
    Getter method for system, mapped from YANG variable /system (container)

    YANG Description: Enclosing container for system-related configuration and
operational state data
    """
    return self.__system
      
  def _set_system(self, v, load=False):
    """
    Setter method for system, mapped from YANG variable /system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system() directly.

    YANG Description: Enclosing container for system-related configuration and
operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)""",
        })

    self.__system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system(self):
    self.__system = YANGDynClass(base=system.system, is_container='container', yang_name="system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/system', defining_module='openconfig-system', yang_type='container', is_config=True)

  system = __builtin__.property(_get_system, _set_system)


  _pyangbind_elements = OrderedDict([('system', system), ])


class openconfig_messages(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-messages - based on the path /openconfig-messages. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to Syslog messages that a device may generate.

These messages are historically obtained through the Syslog
transport, however this module allows for obtaining them through
an alternative transport, such as a Subscribe operation over an
RPC.

This module does not usurp traditional syslog servers, which may
still be configured through the
/yang/system/openconfig-system.yang model, rather it provies the
Operator with an alternative method of consuming messages.
  """
  _pyangbind_elements = {}

  

class openconfig_system_logging(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-logging - based on the path /openconfig-system-logging. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
for common logging facilities on network systems.
  """
  _pyangbind_elements = {}

  

class openconfig_aaa_radius(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aaa-radius - based on the path /openconfig-aaa-radius. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
related to the RADIUS protocol for authentication,
authorization, and accounting.
  """
  _pyangbind_elements = {}

  

class openconfig_system_bootz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system-bootz - based on the path /openconfig-system-bootz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state relating to bootz
service running on a network device.
  """
  _pyangbind_elements = {}

  

from . import ethernet_segments
class openconfig_ethernet_segments(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /openconfig-ethernet-segments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains definitions of ethernet segements.
The ethernet segments are used in EVPN services are
defined for the whole device
  """
  __slots__ = ('_path_helper', '_extmethods', '__ethernet_segments',)

  _yang_name = 'openconfig-ethernet-segments'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ethernet_segments = YANGDynClass(base=ethernet_segments.ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_ethernet_segments(self):
    """
    Getter method for ethernet_segments, mapped from YANG variable /ethernet_segments (container)

    YANG Description: Top-level container for ethernet segments. An Ethernet Segment
is referenced by a name and an ESI
    """
    return self.__ethernet_segments
      
  def _set_ethernet_segments(self, v, load=False):
    """
    Setter method for ethernet_segments, mapped from YANG variable /ethernet_segments (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ethernet_segments is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ethernet_segments() directly.

    YANG Description: Top-level container for ethernet segments. An Ethernet Segment
is referenced by a name and an ESI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=ethernet_segments.ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ethernet_segments must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=ethernet_segments.ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)""",
        })

    self.__ethernet_segments = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ethernet_segments(self):
    self.__ethernet_segments = YANGDynClass(base=ethernet_segments.ethernet_segments, is_container='container', yang_name="ethernet-segments", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='container', is_config=True)

  ethernet_segments = __builtin__.property(_get_ethernet_segments, _set_ethernet_segments)


  _pyangbind_elements = OrderedDict([('ethernet_segments', ethernet_segments), ])


class openconfig_gnsi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi - based on the path /openconfig-gnsi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a set of extensions that provide gNSI (the gRPC
Network Security Interface) specific extensions to the OpenConfig data models.
Specifically, the parameters for the configuration of the service, and
configuration and state are added.

The gNSI protobufs and documentation are published at
https://github.com/openconfig/gnsi.
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_pathz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-pathz - based on the path /openconfig-gnsi-pathz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a data model for the metadata of
OpenConfig-path-based authorization policies installed on a networking
device.
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_acctz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-acctz - based on the path /openconfig-gnsi-acctz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides counters of gNSI accountZ requests and responses and
the quantity of data transferred.
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_credentialz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-credentialz - based on the path /openconfig-gnsi-credentialz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a data model for the metadata of SSH and console
credentials installed on a networking device.

The following leaves MUST be treated as invalid when the gNSI server is
enabled and credentialz is supported by the implementation:
 /system/aaa/authentication/users/user/config/ssh-key
 /system/aaa/authentication/users/user/state/ssh-key
 /system/aaa/authentication/users/user/config/password
 /system/aaa/authentication/users/user/state/password
 /system/aaa/authentication/users/user/config/password-hashed
 /system/aaa/authentication/users/user/state/password-hashed
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_certz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-certz - based on the path /openconfig-gnsi-certz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a data model for the metadata of gRPC credentials
installed on a networking device.
  """
  _pyangbind_elements = {}

  

class openconfig_gnsi_authz(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gnsi-authz - based on the path /openconfig-gnsi-authz. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides a data model for the metadata of the gRPC
authorization policies installed on a networking device.
  """
  _pyangbind_elements = {}

  

from . import keychains
class openconfig_keychain(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-keychain - based on the path /openconfig-keychain. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for keychain configuration
and management. These keys can be changed frequently to
increase security in long-lived connections. A keychain can be used
for authenticaion in a number of scenarios, including in routing protocols
(e.g. BGP, IS-IS, OSPF).  A keychain provides a solution for storing
a number of different keys, each key string value is associated with a
specific key id, name, the lifetime that the key is valid and an
encryption algorithm.

This model defines a central location for defining named keychains,
which may be then referenced by other models such as routing protocol
management.
  """
  __slots__ = ('_path_helper', '_extmethods', '__keychains',)

  _yang_name = 'openconfig-keychain'
  _yang_namespace = 'http://openconfig.net/yang/oc-keychain'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__keychains = YANGDynClass(base=keychains.keychains, is_container='container', yang_name="keychains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-keychain', defining_module='openconfig-keychain', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_keychains(self):
    """
    Getter method for keychains, mapped from YANG variable /keychains (container)

    YANG Description: This container defines keychains.
    """
    return self.__keychains
      
  def _set_keychains(self, v, load=False):
    """
    Setter method for keychains, mapped from YANG variable /keychains (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_keychains is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_keychains() directly.

    YANG Description: This container defines keychains.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=keychains.keychains, is_container='container', yang_name="keychains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-keychain', defining_module='openconfig-keychain', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """keychains must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=keychains.keychains, is_container='container', yang_name="keychains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-keychain', defining_module='openconfig-keychain', yang_type='container', is_config=True)""",
        })

    self.__keychains = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_keychains(self):
    self.__keychains = YANGDynClass(base=keychains.keychains, is_container='container', yang_name="keychains", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/oc-keychain', defining_module='openconfig-keychain', yang_type='container', is_config=True)

  keychains = __builtin__.property(_get_keychains, _set_keychains)


  _pyangbind_elements = OrderedDict([('keychains', keychains), ])


class openconfig_keychain_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-keychain-types - based on the path /openconfig-keychain-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in
keychain-based authentication.
  """
  _pyangbind_elements = {}

  

class openconfig_local_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-local-routing - based on the path /openconfig-local-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes configuration and operational state data
for routes that are locally generated, i.e., not created by
dynamic routing protocols.  These include static routes, locally
created aggregate routes for reducing the number of constituent
routes that must be advertised, summary routes for IGPs, etc.

This model expresses locally generated routes as generically as
possible, avoiding configuration of protocol-specific attributes
at the time of route creation.  This is primarily to avoid
assumptions about how underlying router implementations handle
route attributes in various routing table data structures they
maintain.  Hence, the definition of locally generated routes
essentially creates 'bare' routes that do not have any protocol-
specific attributes.

When protocol-specific attributes must be attached to a route
(e.g., communities on a locally defined route meant to be
advertised via BGP), the attributes should be attached via a
protocol-specific policy after importing the route into the
protocol for distribution (again via routing policy).
  """
  _pyangbind_elements = {}

  

from . import telemetry_system
class openconfig_telemetry(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-telemetry - based on the path /openconfig-telemetry. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data model which creates the configuration for the telemetry
systems and functions on the device.
  """
  __slots__ = ('_path_helper', '_extmethods', '__telemetry_system',)

  _yang_name = 'openconfig-telemetry'
  _yang_namespace = 'http://openconfig.net/yang/telemetry'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__telemetry_system = YANGDynClass(base=telemetry_system.telemetry_system, is_container='container', yang_name="telemetry-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/telemetry', defining_module='openconfig-telemetry', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_telemetry_system(self):
    """
    Getter method for telemetry_system, mapped from YANG variable /telemetry_system (container)

    YANG Description: Top level configuration and state for the
device's telemetry system.
    """
    return self.__telemetry_system
      
  def _set_telemetry_system(self, v, load=False):
    """
    Setter method for telemetry_system, mapped from YANG variable /telemetry_system (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_telemetry_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_telemetry_system() directly.

    YANG Description: Top level configuration and state for the
device's telemetry system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=telemetry_system.telemetry_system, is_container='container', yang_name="telemetry-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/telemetry', defining_module='openconfig-telemetry', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """telemetry_system must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=telemetry_system.telemetry_system, is_container='container', yang_name="telemetry-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/telemetry', defining_module='openconfig-telemetry', yang_type='container', is_config=True)""",
        })

    self.__telemetry_system = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_telemetry_system(self):
    self.__telemetry_system = YANGDynClass(base=telemetry_system.telemetry_system, is_container='container', yang_name="telemetry-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/telemetry', defining_module='openconfig-telemetry', yang_type='container', is_config=True)

  telemetry_system = __builtin__.property(_get_telemetry_system, _set_telemetry_system)


  _pyangbind_elements = OrderedDict([('telemetry_system', telemetry_system), ])


class openconfig_telemetry_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-telemetry-types - based on the path /openconfig-telemetry-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines type and identities used by the OpenConfig
telemetry model.
  """
  _pyangbind_elements = {}

  

from . import relay_agent
class openconfig_relay_agent(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-relay-agent - based on the path /openconfig-relay-agent. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a model for configuration and operational
state related to relay agents typically used for DHCP and BOOTP
packets.  The supports both DHCP and DHCPv6 and device-wide and
per-interface settings.
  """
  __slots__ = ('_path_helper', '_extmethods', '__relay_agent',)

  _yang_name = 'openconfig-relay-agent'
  _yang_namespace = 'http://openconfig.net/yang/relay-agent'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__relay_agent = YANGDynClass(base=relay_agent.relay_agent, is_container='container', yang_name="relay-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/relay-agent', defining_module='openconfig-relay-agent', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_relay_agent(self):
    """
    Getter method for relay_agent, mapped from YANG variable /relay_agent (container)

    YANG Description: Top level container for relay-agent configuration and
operational state data
    """
    return self.__relay_agent
      
  def _set_relay_agent(self, v, load=False):
    """
    Setter method for relay_agent, mapped from YANG variable /relay_agent (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relay_agent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relay_agent() directly.

    YANG Description: Top level container for relay-agent configuration and
operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=relay_agent.relay_agent, is_container='container', yang_name="relay-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/relay-agent', defining_module='openconfig-relay-agent', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relay_agent must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=relay_agent.relay_agent, is_container='container', yang_name="relay-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/relay-agent', defining_module='openconfig-relay-agent', yang_type='container', is_config=True)""",
        })

    self.__relay_agent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relay_agent(self):
    self.__relay_agent = YANGDynClass(base=relay_agent.relay_agent, is_container='container', yang_name="relay-agent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/relay-agent', defining_module='openconfig-relay-agent', yang_type='container', is_config=True)

  relay_agent = __builtin__.property(_get_relay_agent, _set_relay_agent)


  _pyangbind_elements = OrderedDict([('relay_agent', relay_agent), ])


from . import macsec
class openconfig_macsec(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-macsec - based on the path /openconfig-macsec. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state data for
MACsec IEEE Std 802.1AE-2018.
  """
  __slots__ = ('_path_helper', '_extmethods', '__macsec',)

  _yang_name = 'openconfig-macsec'
  _yang_namespace = 'http://openconfig.net/yang/macsec'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__macsec = YANGDynClass(base=macsec.macsec, is_container='container', yang_name="macsec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/macsec', defining_module='openconfig-macsec', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_macsec(self):
    """
    Getter method for macsec, mapped from YANG variable /macsec (container)

    YANG Description: The MACsec
    """
    return self.__macsec
      
  def _set_macsec(self, v, load=False):
    """
    Setter method for macsec, mapped from YANG variable /macsec (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_macsec is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_macsec() directly.

    YANG Description: The MACsec
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=macsec.macsec, is_container='container', yang_name="macsec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/macsec', defining_module='openconfig-macsec', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """macsec must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=macsec.macsec, is_container='container', yang_name="macsec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/macsec', defining_module='openconfig-macsec', yang_type='container', is_config=True)""",
        })

    self.__macsec = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_macsec(self):
    self.__macsec = YANGDynClass(base=macsec.macsec, is_container='container', yang_name="macsec", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/macsec', defining_module='openconfig-macsec', yang_type='container', is_config=True)

  macsec = __builtin__.property(_get_macsec, _set_macsec)


  _pyangbind_elements = OrderedDict([('macsec', macsec), ])


class openconfig_macsec_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-macsec-types - based on the path /openconfig-macsec-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines types related to the MACsec configuration
and operational state model.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-global - based on the path /openconfig-bgp-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
global context of the OpenConfig BGP module
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp - based on the path /openconfig-bgp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for BGP protocol
configuration.It is a limited subset of all of the configuration
parameters available in the variety of vendor implementations,
hence it is expected that it would be augmented with vendor-
specific configuration data as needed. Additional modules or
submodules to handle other aspects of BGP configuration,
including policy, VRFs, VPNs, and additional address families
are also expected.

This model supports the following BGP configuration level
hierarchy:

 BGP
   |
   +-> [ global BGP configuration ]
     +-> AFI / SAFI global
   +-> peer group
     +-> [ peer group config ]
     +-> AFI / SAFI [ per-AFI overrides ]
   +-> neighbor
     +-> [ neighbor config ]
     +-> [ optional pointer to peer-group ]
     +-> AFI / SAFI [ per-AFI overrides ]

Most BGP features can be configured at multiple levels in the BGP
configuration level hierarchy. The common inheritance model allows
the more specific configuration (e.g. neighbor) to inherit from or
override the less specific configuration (e.g. global).
Leaf present at one level overrides leafs present at higher levels,
whereas leaf not present inherits its value from the leaf present
at the next higher level in the hierarchy.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-neighbor - based on the path /openconfig-bgp-neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
neighbor context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-global - based on the path /openconfig-bgp-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
global context of the OpenConfig BGP module
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-policy - based on the path /openconfig-bgp-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains data definitions for BGP routing policy.
It augments the base routing-policy module with BGP-specific
options for conditions and actions.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_neighbor(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-neighbor - based on the path /openconfig-bgp-neighbor. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
neighbor context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_multiprotocol(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-multiprotocol - based on the path /openconfig-bgp-common-multiprotocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are related to support
for multiple protocols in BGP. The groupings are common across
multiple contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_peer_group(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-peer-group - based on the path /openconfig-bgp-peer-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are specific to the
peer-group context of the OpenConfig BGP module.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common_structure(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common-structure - based on the path /openconfig-bgp-common-structure. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains groupings that are common across multiple BGP
contexts and provide structure around other primitive groupings.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_errors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-errors - based on the path /openconfig-bgp-errors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines BGP NOTIFICATION message error codes
and subcodes
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-common - based on the path /openconfig-bgp-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module contains common groupings that are common across
multiple contexts within the BGP module. That is to say that they
may be application to a subset of global, peer-group or neighbor
contexts.
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-types - based on the path /openconfig-bgp-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in BGP
policy. It can be imported by modules that make use of BGP
attributes
  """
  _pyangbind_elements = {}

  

class openconfig_bgp_errors(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bgp-errors - based on the path /openconfig-bgp-errors. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines BGP NOTIFICATION message error codes
and subcodes
  """
  _pyangbind_elements = {}

  

from . import transceiver_descriptors
from . import linecard_descriptors
from . import operational_mode_descriptors
class openconfig_terminal_device_properties(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device-properties - based on the path /openconfig-terminal-device-properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Module to extend OpenConfig terminal device's operational modes'
data. It supports operational modes for one Optical
Channel, with a single OTSi. The operational mode includes key
attributes such modulation format, symbol rate, nominal central
frequency (NFC) tunability constraints (grid, min/max NCF), FEC
gain, minimum and maximum output power of the transmitter or
minimum OSNR at the receiver as well as the spectrum width of
the OTSi (OTSiMC). It also includes (optional) aspects such as
filter characterization, CD and DGD tolerance.
  """
  __slots__ = ('_path_helper', '_extmethods', '__transceiver_descriptors','__linecard_descriptors','__operational_mode_descriptors',)

  _yang_name = 'openconfig-terminal-device-properties'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-terminal-device-properties'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__transceiver_descriptors = YANGDynClass(base=transceiver_descriptors.transceiver_descriptors, is_container='container', yang_name="transceiver-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    self.__linecard_descriptors = YANGDynClass(base=linecard_descriptors.linecard_descriptors, is_container='container', yang_name="linecard-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    self.__operational_mode_descriptors = YANGDynClass(base=operational_mode_descriptors.operational_mode_descriptors, is_container='container', yang_name="operational-mode-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_transceiver_descriptors(self):
    """
    Getter method for transceiver_descriptors, mapped from YANG variable /transceiver_descriptors (container)

    YANG Description: Indicates the terminal-device's list of compatible transceiver
component and its associated modes and mode descriptors compatibility
matrix.
    """
    return self.__transceiver_descriptors
      
  def _set_transceiver_descriptors(self, v, load=False):
    """
    Setter method for transceiver_descriptors, mapped from YANG variable /transceiver_descriptors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_transceiver_descriptors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_transceiver_descriptors() directly.

    YANG Description: Indicates the terminal-device's list of compatible transceiver
component and its associated modes and mode descriptors compatibility
matrix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=transceiver_descriptors.transceiver_descriptors, is_container='container', yang_name="transceiver-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """transceiver_descriptors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=transceiver_descriptors.transceiver_descriptors, is_container='container', yang_name="transceiver-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)""",
        })

    self.__transceiver_descriptors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_transceiver_descriptors(self):
    self.__transceiver_descriptors = YANGDynClass(base=transceiver_descriptors.transceiver_descriptors, is_container='container', yang_name="transceiver-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)


  def _get_linecard_descriptors(self):
    """
    Getter method for linecard_descriptors, mapped from YANG variable /linecard_descriptors (container)

    YANG Description: Indicates the terminal-device's list of compatible linecard
component and its associated modes and mode descriptors compatibility
matrix.
    """
    return self.__linecard_descriptors
      
  def _set_linecard_descriptors(self, v, load=False):
    """
    Setter method for linecard_descriptors, mapped from YANG variable /linecard_descriptors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_linecard_descriptors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_linecard_descriptors() directly.

    YANG Description: Indicates the terminal-device's list of compatible linecard
component and its associated modes and mode descriptors compatibility
matrix.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=linecard_descriptors.linecard_descriptors, is_container='container', yang_name="linecard-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """linecard_descriptors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=linecard_descriptors.linecard_descriptors, is_container='container', yang_name="linecard-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)""",
        })

    self.__linecard_descriptors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_linecard_descriptors(self):
    self.__linecard_descriptors = YANGDynClass(base=linecard_descriptors.linecard_descriptors, is_container='container', yang_name="linecard-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)


  def _get_operational_mode_descriptors(self):
    """
    Getter method for operational_mode_descriptors, mapped from YANG variable /operational_mode_descriptors (container)

    YANG Description: Indicates the transceiver's list of supported operational
modes and its associated transmission features
    """
    return self.__operational_mode_descriptors
      
  def _set_operational_mode_descriptors(self, v, load=False):
    """
    Setter method for operational_mode_descriptors, mapped from YANG variable /operational_mode_descriptors (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operational_mode_descriptors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operational_mode_descriptors() directly.

    YANG Description: Indicates the transceiver's list of supported operational
modes and its associated transmission features
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=operational_mode_descriptors.operational_mode_descriptors, is_container='container', yang_name="operational-mode-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """operational_mode_descriptors must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=operational_mode_descriptors.operational_mode_descriptors, is_container='container', yang_name="operational-mode-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)""",
        })

    self.__operational_mode_descriptors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_operational_mode_descriptors(self):
    self.__operational_mode_descriptors = YANGDynClass(base=operational_mode_descriptors.operational_mode_descriptors, is_container='container', yang_name="operational-mode-descriptors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='container', is_config=False)

  transceiver_descriptors = __builtin__.property(_get_transceiver_descriptors)
  linecard_descriptors = __builtin__.property(_get_linecard_descriptors)
  operational_mode_descriptors = __builtin__.property(_get_operational_mode_descriptors)


  _pyangbind_elements = OrderedDict([('transceiver_descriptors', transceiver_descriptors), ('linecard_descriptors', linecard_descriptors), ('operational_mode_descriptors', operational_mode_descriptors), ])


class openconfig_terminal_device_property_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device-property-types - based on the path /openconfig-terminal-device-property-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Supplementary module to expose identity types for the
openconfig-terminal-device-properties model. This model includes
definitions of the set of modulation format, FEC codes and adjustment
granularity types use in the reffered model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_summary(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-summary - based on the path /openconfig-aft-summary. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides summary of aft entry counts per protocol type for each network
instance.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-types - based on the path /openconfig-aft-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Types related to the OpenConfig Abstract Forwarding
Table (AFT) model
  """
  _pyangbind_elements = {}

  

class openconfig_aft_pf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-pf - based on the path /openconfig-aft-pf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding table(s) for policy forwarding entries. These are
defined to be forwarding tables that allow matches on
fields other than the destination address that is used in
other forwarding tables.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft - based on the path /openconfig-aft. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A model describing the forwarding entries installed on a network
element. It should be noted that this model is not expected to
align 1:1 with the underlying structure used directly by a
forwarding element (e.g., linecard), but rather provide an
abstraction that can be consumed by an NMS to observe, and in some
cases manipulate, the internal forwarding database in a simplified
manner. Since the underlying model of the forwarding table is not
expected to align with this model, the structure described herein
is referred to as an Abstract Forwarding Table (AFT), rather than
the FIB.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ipv4 - based on the path /openconfig-aft-ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for IPv4.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ipv6 - based on the path /openconfig-aft-ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for IPv6.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-mpls - based on the path /openconfig-aft-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding table for MPLS label forwarding.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_pf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-pf - based on the path /openconfig-aft-pf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding table(s) for policy forwarding entries. These are
defined to be forwarding tables that allow matches on
fields other than the destination address that is used in
other forwarding tables.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ethernet - based on the path /openconfig-aft-ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for Ethernet.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_state_synced(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-state-synced - based on the path /openconfig-aft-state-synced. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the state
synced signals corresponding to various abstract forwarding tables.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ipv6(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ipv6 - based on the path /openconfig-aft-ipv6. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for IPv6.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ethernet - based on the path /openconfig-aft-ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for Ethernet.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_ipv4(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-ipv4 - based on the path /openconfig-aft-ipv4. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding tables for IPv4.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_mpls(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-mpls - based on the path /openconfig-aft-mpls. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the abstract
forwarding table for MPLS label forwarding.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-common - based on the path /openconfig-aft-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings that are re-used
across multiple contexts within the AFT model.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_state_synced(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-state-synced - based on the path /openconfig-aft-state-synced. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Submodule containing definitions of groupings for the state
synced signals corresponding to various abstract forwarding tables.
  """
  _pyangbind_elements = {}

  

class openconfig_aft_network_instance(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-aft-network-instance - based on the path /openconfig-aft-network-instance. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides augmentations that are utilized
when building the OpenConfig network instance model to
add per-NI AFTs.
  """
  _pyangbind_elements = {}

  

class openconfig_icmpv6_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-icmpv6-types - based on the path /openconfig-icmpv6-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: OpenConfig module defining the types and coresponding subcodes for
ICMPv6.
  """
  _pyangbind_elements = {}

  

class openconfig_packet_match(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-packet-match - based on the path /openconfig-packet-match. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines data related to packet header fields
used in matching operations, for example in ACLs.  When a
field is omitted from a match expression, the effect is a
wildcard ('any') for that field.
  """
  _pyangbind_elements = {}

  

class openconfig_packet_match_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-packet-match-types - based on the path /openconfig-packet-match-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines common types for use in models requiring
data definitions related to packet matches.
  """
  _pyangbind_elements = {}

  

class openconfig_icmpv4_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-icmpv4-types - based on the path /openconfig-icmpv4-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: OpenConfig module defining the types and coresponding codes for
ICMPv4.
  """
  _pyangbind_elements = {}

  

from . import acl
class openconfig_acl(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-acl - based on the path /openconfig-acl. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state
data for network access control lists (i.e., filters, rules,
etc.).  ACLs are organized into ACL sets, with each set
containing one or more ACL entries.  ACL sets are identified
by a unique name, while each entry within a set is assigned
a sequence-id that determines the order in which the ACL
rules are applied to a packet.  Note that ACLs are evaluated
in ascending order based on the sequence-id (low to high).

Individual ACL rules specify match criteria based on fields in
the packet, along with an action that defines how matching
packets should be handled. Entries have a type that indicates
the type of match criteria, e.g., MAC layer, IPv4, IPv6, etc.
  """
  __slots__ = ('_path_helper', '_extmethods', '__acl',)

  _yang_name = 'openconfig-acl'
  _yang_namespace = 'http://openconfig.net/yang/acl'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__acl = YANGDynClass(base=acl.acl, is_container='container', yang_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/acl', defining_module='openconfig-acl', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_acl(self):
    """
    Getter method for acl, mapped from YANG variable /acl (container)

    YANG Description: Top level enclosing container for ACL model config
and operational state data
    """
    return self.__acl
      
  def _set_acl(self, v, load=False):
    """
    Setter method for acl, mapped from YANG variable /acl (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acl() directly.

    YANG Description: Top level enclosing container for ACL model config
and operational state data
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=acl.acl, is_container='container', yang_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/acl', defining_module='openconfig-acl', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acl must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=acl.acl, is_container='container', yang_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/acl', defining_module='openconfig-acl', yang_type='container', is_config=True)""",
        })

    self.__acl = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acl(self):
    self.__acl = YANGDynClass(base=acl.acl, is_container='container', yang_name="acl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/acl', defining_module='openconfig-acl', yang_type='container', is_config=True)

  acl = __builtin__.property(_get_acl, _set_acl)


  _pyangbind_elements = OrderedDict([('acl', acl), ])


class openconfig_pf_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-interfaces - based on the path /openconfig-pf-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains groupings related to the association
between interfaces and policy forwarding rules.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_forwarding_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-forwarding-policies - based on the path /openconfig-pf-forwarding-policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to the definition of policy-forwarding policies.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_srte(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-srte - based on the path /openconfig-pf-srte. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines extensions to the OpenConfig policy forwarding
module to support static segment routing traffic engineering policy
definitions. Extensions are provided to match:

 - Ingress binding SIDs, such that traffic can be mapped based on
   an ingress label.
 - A colour community and endpoint combination, such that the
   routes can be resolved according to the policy forwarding
   entries that are to be installed.

In addition, policy forwarding actions associated with next-hops are
added to the model. The next-hop set to be forwarded to is augmented
to cover a set of lists of segments. The most common application of
such segment lists is to express stacks of MPLS labels which are used
as SR segments. In addition, they may be used to expressed segments
in the form of IPv6 addresses.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_forwarding_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-forwarding-policies - based on the path /openconfig-pf-forwarding-policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to the definition of policy-forwarding policies.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_path_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-path-groups - based on the path /openconfig-pf-path-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to path-selection-groups which are used to group
forwarding entities together to be used as policy forwarding
targets.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_path_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-path-groups - based on the path /openconfig-pf-path-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to path-selection-groups which are used to group
forwarding entities together to be used as policy forwarding
targets.
  """
  _pyangbind_elements = {}

  

class openconfig_policy_forwarding(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-policy-forwarding - based on the path /openconfig-policy-forwarding. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and operational state data
relating to policy-based forwarding. Policy-based forwarding is
utilised when a system chooses how to forward packets (including
applying data-plane operations such as encapsulation or
decapsulation) based on policies other than destination L2 or L3
header. Typically, systems may implement:

- IP policy-based routing, where routing may be done based on the
  source plus destination of an IP packet; information within the
  L4 header; or some combination of both.
- Encapsulation or decapsulation based on certain policy
  information - for example, matching particular IP destinations
  and decapsulating GRE headers.
- Class-based selection of egress routes - such as class-based
  selection of an egress MPLS path.

The policies that are defined in this model are applied to a
particular ingress context of a network element (e.g., interface)
and are defined to apply following other interface policy such as
QoS classification and access control lists.

This module defines:

- policy-forwarding
|
|--- policies
|    |-- policy
|        |-- [match criteria]    How packets are defined to
|        |                       match policy.
|        |-- [forwarding-action] How packets matching should
|                                 be forwarded.
|--- interfaces
|    |-- interfaces
|        | -- apply-forwarding-policy  Forwarding policy to
|                                      used on the interface.
|--- path-selection-groups
    |-- path-selection-group     A group of forwarding resources
                                 that are grouped for purposes
                                 of next-hop selection.

A forwarding-policy specifies the match criteria that it intends
to use to determine the packets that it reroutes - this may
consist of a number of criteria, such as DSCP. The match criteria
is specified as rules.  If no rules are specified, then the policy
will match all packets.

The action of the policy results in a forwarding action being applied
to matching packets. For example, decapsulating the packet from a GRE
header. In order to enact the policy based on particular interfaces -
the forwarding-policy is applied to an interface via referencing it
within an 'apply-forwarding-policy' statement associated with an
interface.

A policy-forwarding rule with no action should be treated as an error.

In some cases (e.g., Class-Based Tunnel Selection) the forwarding
action does not resolve to a single egress action, and rather
normal forwarding rules are to be applied but considering a subset
of forwarding resources. In these cases, a path-selection-group
can be created, referencing the subset of forwarding paths that
should be used for the egress selection. In the case that a subset
of MPLS LSPs are eligible for, say, DSCP 46 marked packets, a
path-selection-group is created, referencing the subset of LSPs.
The forwarding action of the corresponding policy is set to
PATH_GROUP and references the configured group of LSPs.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_forwarding_policies(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-forwarding-policies - based on the path /openconfig-pf-forwarding-policies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to the definition of policy-forwarding policies.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_path_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-path-groups - based on the path /openconfig-pf-path-groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains configuration and operational state
relating to path-selection-groups which are used to group
forwarding entities together to be used as policy forwarding
targets.
  """
  _pyangbind_elements = {}

  

class openconfig_pf_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-pf-interfaces - based on the path /openconfig-pf-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule contains groupings related to the association
between interfaces and policy forwarding rules.
  """
  _pyangbind_elements = {}

  

class openconfig_policy_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-policy-types - based on the path /openconfig-policy-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in routing
policy.  It can be imported by modules that contain protocol-
specific policy conditions and actions.
  """
  _pyangbind_elements = {}

  

from . import routing_policy
class openconfig_routing_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-routing-policy - based on the path /openconfig-routing-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for routing policy
configuration. It is a limited subset of all of the policy
configuration parameters available in the variety of vendor
implementations, but supports widely used constructs for managing
how routes are imported, exported, and modified across different
routing protocols.  This module is intended to be used in
conjunction with routing protocol configuration models (e.g.,
BGP) defined in other modules.

Route policy expression:

Policies are expressed as a set of top-level policy definitions,
each of which consists of a sequence of policy statements. Policy
statements consist of simple condition-action tuples. Conditions
may include mutiple match or comparison operations, and similarly
actions may be multitude of changes to route attributes or a
final disposition of accepting or rejecting the route.

Route policy evaluation:

Policy definitions are referenced in routing protocol
configurations using import and export configuration statements.
The arguments are members of an ordered list of named policy
definitions which comprise a policy chain, and optionally, an
explicit default policy action (i.e., reject or accept).

Evaluation of each policy definition proceeds by evaluating its
corresponding individual policy statements in order.  When a
condition statement in a policy statement is satisfied, the
corresponding action statement is executed.  A policy statement with no
conditions defined is evaluated as statisfied, meaning all routes are
matched.  A routing-policy statement with no condition AND no action, or
a policy-definition without any statements should be treated as errors.

If the action statement has a final disposition configured as
policy result, either accept-route or reject-route, evaluation of the
current policy definition stops, and no further policy statements are
evaluated. In case there is a policy chain, no further policy definitions
in the chain are evaluated.

If the action statement has the NEXT_STATEMENT policy result, all the
defined actions are executed and policy evaluation proceeds to the next
statement.  The NEXT_STATEMENT is the default policy result action.

If the condition is not satisfied, then evaluation proceeds to
the next policy statement.  If none of the policy statement
conditions are satisfied, then evaluation of the current policy
definition stops, and the next policy definition in the chain is
evaluated.  When the end of the policy chain is reached, the
default route disposition action is performed (i.e., reject-route
unless an an alternate default action is specified for the
chain).

Policy 'subroutines' (or nested policies) are supported by
allowing policy statement conditions to reference another policy
definition which applies conditions and actions from the
referenced policy before returning to the calling policy
statement and resuming evaluation.  If the called policy
results in an accept-route (either explicit or by default), then
the subroutine returns an effective true value to the calling
policy.  Similarly, a reject-route action returns false.  If the
subroutine returns true, the calling policy continues to evaluate
the remaining conditions (using a modified route if the
subroutine performed any changes to the route).

If a routing protocol is defined and the related
apply-policy/default-(import|export)-policy leaf is not set, the
default value for the default-(import|export)-policy leaf must be
applied.  See RFC6020 7.6.1 which applies to this model.
  """
  __slots__ = ('_path_helper', '_extmethods', '__routing_policy',)

  _yang_name = 'openconfig-routing-policy'
  _yang_namespace = 'http://openconfig.net/yang/routing-policy'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__routing_policy = YANGDynClass(base=routing_policy.routing_policy, is_container='container', yang_name="routing-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/routing-policy', defining_module='openconfig-routing-policy', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_routing_policy(self):
    """
    Getter method for routing_policy, mapped from YANG variable /routing_policy (container)

    YANG Description: Top-level container for all routing policy configuration
    """
    return self.__routing_policy
      
  def _set_routing_policy(self, v, load=False):
    """
    Setter method for routing_policy, mapped from YANG variable /routing_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_routing_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_routing_policy() directly.

    YANG Description: Top-level container for all routing policy configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=routing_policy.routing_policy, is_container='container', yang_name="routing-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/routing-policy', defining_module='openconfig-routing-policy', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """routing_policy must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=routing_policy.routing_policy, is_container='container', yang_name="routing-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/routing-policy', defining_module='openconfig-routing-policy', yang_type='container', is_config=True)""",
        })

    self.__routing_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_routing_policy(self):
    self.__routing_policy = YANGDynClass(base=routing_policy.routing_policy, is_container='container', yang_name="routing-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/routing-policy', defining_module='openconfig-routing-policy', yang_type='container', is_config=True)

  routing_policy = __builtin__.property(_get_routing_policy, _set_routing_policy)


  _pyangbind_elements = OrderedDict([('routing_policy', routing_policy), ])


class openconfig_ospfv2_lsdb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-lsdb - based on the path /openconfig-ospfv2-lsdb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for the Open Shortest Path First (OSPF)
version 2 link-state database (LSDB)
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-policy - based on the path /openconfig-ospf-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines extensions to the OpenConfig policy
model to add extensions for OSPF. This module is intended
to be generic for both OSPFv2 and OSPFv3.
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-types - based on the path /openconfig-ospf-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Type definitions for OSPF
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area - based on the path /openconfig-ospf-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area-interface - based on the path /openconfig-ospf-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area-interface - based on the path /openconfig-ospf-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-common - based on the path /openconfig-ospf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-common - based on the path /openconfig-ospf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-common - based on the path /openconfig-ospfv2-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2 - based on the path /openconfig-ospfv2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for Open Shortest Path First (OSPF)
version 2
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-global - based on the path /openconfig-ospfv2-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are global to a particular OSPF instance
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area - based on the path /openconfig-ospfv2-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area-interface - based on the path /openconfig-ospfv2-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_lsdb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-lsdb - based on the path /openconfig-ospfv2-lsdb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for the Open Shortest Path First (OSPF)
version 2 link-state database (LSDB)
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-common - based on the path /openconfig-ospfv2-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospf(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf - based on the path /openconfig-ospf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-global - based on the path /openconfig-ospf-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are global to a particular OSPF instance
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area - based on the path /openconfig-ospf-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-area-interface - based on the path /openconfig-ospf-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-common - based on the path /openconfig-ospf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-global - based on the path /openconfig-ospfv2-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are global to a particular OSPF instance
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-common - based on the path /openconfig-ospfv2-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_global(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-global - based on the path /openconfig-ospf-global. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are global to a particular OSPF instance
  """
  _pyangbind_elements = {}

  

class openconfig_ospf_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospf-common - based on the path /openconfig-ospf-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides common OSPF configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area - based on the path /openconfig-ospfv2-area. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area-interface - based on the path /openconfig-ospfv2-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_lsdb(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-lsdb - based on the path /openconfig-ospfv2-lsdb. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An OpenConfig model for the Open Shortest Path First (OSPF)
version 2 link-state database (LSDB)
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv3_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv3-area-interface - based on the path /openconfig-ospfv3-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv3 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_area_interface(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-area-interface - based on the path /openconfig-ospfv2-area-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are specific to the area context
  """
  _pyangbind_elements = {}

  

class openconfig_ospfv2_common(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ospfv2-common - based on the path /openconfig-ospfv2-common. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This submodule provides OSPFv2 configuration and operational
state parameters that are shared across multiple contexts
  """
  _pyangbind_elements = {}

  

class openconfig_if_8021x(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-8021x - based on the path /openconfig-if-8021x. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing 8021X. Augments the OpenConfig models for
wired interfaces and wireless SSIDs for configuration and state.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ip_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ip-ext - based on the path /openconfig-if-ip-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds extensions to the base IP configuration and
operational state model to support additional use cases.
  """
  _pyangbind_elements = {}

  

class openconfig_if_tunnel(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-tunnel - based on the path /openconfig-if-tunnel. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model adds extensions to the OpenConfig interfaces
model to configure tunnel interfaces on a network
device.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ethernet(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ethernet - based on the path /openconfig-if-ethernet. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing Ethernet interfaces -- augments the OpenConfig
model for interface configuration and state.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ip(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ip - based on the path /openconfig-if-ip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This model defines data for managing configuration and
operational state on IP (IPv4 and IPv6) interfaces.

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7277 with an alternate structure
(particularly for operational state data) and with
additional configuration items.

Portions of this code were derived from IETF RFC 7277.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_if_sdn_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-sdn-ext - based on the path /openconfig-if-sdn-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides extensions to the OpenConfig interfaces
module for network elements that support external 'SDN' control
of their interfaces.
  """
  _pyangbind_elements = {}

  

class openconfig_if_aggregate(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-aggregate - based on the path /openconfig-if-aggregate. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing aggregated (aka bundle, LAG) interfaces.
  """
  _pyangbind_elements = {}

  

class openconfig_if_ethernet_ext(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-ethernet-ext - based on the path /openconfig-if-ethernet-ext. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds extensions to the base ethernet configuration
and operational state model to support additional use cases.
  """
  _pyangbind_elements = {}

  

class openconfig_if_poe(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-poe - based on the path /openconfig-if-poe. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines configuration and state data for
Power over Ethernet (PoE) based on the IEEE 802.3af
standard.
  """
  _pyangbind_elements = {}

  

from . import interfaces
class openconfig_interfaces(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /openconfig-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Model for managing network interfaces and subinterfaces.  This
module also defines convenience types / groupings for other
models to create references to interfaces:

 base-interface-ref (type) -  reference to a base interface
 interface-ref (grouping) -  container for reference to a
   interface + subinterface
 interface-ref-state (grouping) - container for read-only
   (opstate) reference to interface + subinterface

This model reuses data items defined in the IETF YANG model for
interfaces described by RFC 7223 with an alternate structure
(particularly for operational state data) and with
additional configuration items.

Portions of this code were derived from IETF RFC 7223.
Please reproduce this note if possible.

IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  __slots__ = ('_path_helper', '_extmethods', '__interfaces',)

  _yang_name = 'openconfig-interfaces'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_interfaces(self):
    """
    Getter method for interfaces, mapped from YANG variable /interfaces (container)

    YANG Description: Top level container for interfaces, including configuration
and state data.
    """
    return self.__interfaces
      
  def _set_interfaces(self, v, load=False):
    """
    Setter method for interfaces, mapped from YANG variable /interfaces (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interfaces() directly.

    YANG Description: Top level container for interfaces, including configuration
and state data.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interfaces must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)""",
        })

    self.__interfaces = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interfaces(self):
    self.__interfaces = YANGDynClass(base=interfaces.interfaces, is_container='container', yang_name="interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/interfaces', defining_module='openconfig-interfaces', yang_type='container', is_config=True)

  interfaces = __builtin__.property(_get_interfaces, _set_interfaces)


  _pyangbind_elements = OrderedDict([('interfaces', interfaces), ])


class openconfig_if_rates(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-if-rates - based on the path /openconfig-if-rates. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module adds configuration and operational state for interface rates.
  """
  _pyangbind_elements = {}

  

class openconfig_extensions(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-extensions - based on the path /openconfig-extensions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module provides extensions to the YANG language to allow
OpenConfig specific functionality and meta-data to be defined.
  """
  _pyangbind_elements = {}

  

class openconfig_gribi(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-gribi - based on the path /openconfig-gribi. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a set of exdtensions that provide gRIBI (the gRPC
RIB Interface) specific extensions to the OpenConfig data models.
Specifically, the parameters for the configuration of the service, and
configuration and state are added.

The gRIBI protobufs and documentation are published at
https://github.com/openconfig/gribi.
  """
  _pyangbind_elements = {}

  

class openconfig_isis_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-types - based on the path /openconfig-isis-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general data definitions for use in ISIS YANG
model.
  """
  _pyangbind_elements = {}

  

class openconfig_isis_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-routing - based on the path /openconfig-isis-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes YANG model for ISIS Routing
  """
  _pyangbind_elements = {}

  

class openconfig_isis_policy(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-policy - based on the path /openconfig-isis-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains data definitions for ISIS routing policy.
It augments the base routing-policy module with BGP-specific
options for conditions and actions.
  """
  _pyangbind_elements = {}

  

class openconfig_isis_lsp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-lsp - based on the path /openconfig-isis-lsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module describes a YANG model for the IS-IS Link State
Database (LSDB).

Portions of this code were derived from IETF RFCs relating to the
IS-IS protocol.
Please reproduce this note if possible.
IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_isis_lsdb_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-lsdb-types - based on the path /openconfig-isis-lsdb-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains general LSDB type definitions for use in
ISIS YANG model. 
  """
  _pyangbind_elements = {}

  

class openconfig_isis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis - based on the path /openconfig-isis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes a YANG model for ISIS protocol configuration.
It is a limited subset of all of the configuration parameters
available in the variety of vendor implementations, hence it is
expected that it would be augmented with vendor - specific configuration
data as needed. Additional modules or submodules to handle other
aspects of ISIS configuration, including policy, routing, types,
LSDB and additional address families are also expected. This model
supports the following ISIS configuration level hierarchy:

ISIS
+-> { global ISIS configuration}
   +-> levels +-> { level config}
       +-> { system-level-counters }
       +-> { level link-state-database}
   +-> interface +-> { interface config }
       +-> { circuit-counters }
       +-> { levels config }
       +-> { level adjacencies }
  """
  _pyangbind_elements = {}

  

class openconfig_isis_lsp(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-lsp - based on the path /openconfig-isis-lsp. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This sub-module describes a YANG model for the IS-IS Link State
Database (LSDB).

Portions of this code were derived from IETF RFCs relating to the
IS-IS protocol.
Please reproduce this note if possible.
IETF code is subject to the following copyright and license:
Copyright (c) IETF Trust and the persons identified as authors of
the code.
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, is permitted pursuant to, and subject to the license
terms contained in, the Simplified BSD License set forth in
Section 4.c of the IETF Trust's Legal Provisions Relating
to IETF Documents (http://trustee.ietf.org/license-info).
  """
  _pyangbind_elements = {}

  

class openconfig_isis_routing(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-isis-routing - based on the path /openconfig-isis-routing. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module describes YANG model for ISIS Routing
  """
  _pyangbind_elements = {}

  

