# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device-properties - based on the path /operational-mode-descriptors/operational-modes/mode-descriptors/mode-descriptor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Mode-descriptor state attributes top container.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode_descriptor_id','__min_tx_osnr','__min_rx_osnr','__min_input_power','__max_input_power','__max_chromatic_dispersion','__max_differential_group_delay','__max_polarization_dependent_loss','__pre_fec_ber_threshold',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-terminal-device-properties'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode_descriptor_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='uint16', is_config=False)
    self.__min_tx_osnr = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-tx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__min_rx_osnr = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-rx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__min_input_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__max_input_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__max_chromatic_dispersion = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__max_differential_group_delay = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-differential-group-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__max_polarization_dependent_loss = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__pre_fec_ber_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="pre-fec-ber-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['operational-mode-descriptors', 'operational-modes', 'mode-descriptors', 'mode-descriptor', 'state']

  def _get_mode_descriptor_id(self):
    """
    Getter method for mode_descriptor_id, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/mode_descriptor_id (uint16)

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    return self.__mode_descriptor_id
      
  def _set_mode_descriptor_id(self, v, load=False):
    """
    Setter method for mode_descriptor_id, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/mode_descriptor_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_descriptor_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_descriptor_id() directly.

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_descriptor_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='uint16', is_config=False)""",
        })

    self.__mode_descriptor_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_descriptor_id(self):
    self.__mode_descriptor_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='uint16', is_config=False)


  def _get_min_tx_osnr(self):
    """
    Getter method for min_tx_osnr, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_tx_osnr (decimal64)

    YANG Description: Minimum in-band transmitter OSNR measured at 0.1nm@193.6Thz,
considering the maximum transceiver inserted noise. 
    """
    return self.__min_tx_osnr
      
  def _set_min_tx_osnr(self, v, load=False):
    """
    Setter method for min_tx_osnr, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_tx_osnr (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_tx_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_tx_osnr() directly.

    YANG Description: Minimum in-band transmitter OSNR measured at 0.1nm@193.6Thz,
considering the maximum transceiver inserted noise. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-tx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_tx_osnr must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-tx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__min_tx_osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_tx_osnr(self):
    self.__min_tx_osnr = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-tx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_min_rx_osnr(self):
    """
    Getter method for min_rx_osnr, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_rx_osnr (decimal64)

    YANG Description: Minimum back-to-back OSNR measured over 0.1nm@193.6Thz or
12.5GHz noise resolution bandwidth at the min-input-power.
If received OSNR at min-input-power is lower than this value,
an increased level of bit-errors post-FEC needs to be
expected.
    """
    return self.__min_rx_osnr
      
  def _set_min_rx_osnr(self, v, load=False):
    """
    Setter method for min_rx_osnr, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_rx_osnr (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_rx_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_rx_osnr() directly.

    YANG Description: Minimum back-to-back OSNR measured over 0.1nm@193.6Thz or
12.5GHz noise resolution bandwidth at the min-input-power.
If received OSNR at min-input-power is lower than this value,
an increased level of bit-errors post-FEC needs to be
expected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-rx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_rx_osnr must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-rx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__min_rx_osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_rx_osnr(self):
    self.__min_rx_osnr = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-rx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_min_input_power(self):
    """
    Getter method for min_input_power, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_input_power (decimal64)

    YANG Description: Minimum value required input power in dBm of an optical channel
at the receiver (Rx) according to the given min-rx-osnr value. If
the input-power is lower it is expected to introduce an OSNR
penalty.
    """
    return self.__min_input_power
      
  def _set_min_input_power(self, v, load=False):
    """
    Setter method for min_input_power, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_input_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_input_power() directly.

    YANG Description: Minimum value required input power in dBm of an optical channel
at the receiver (Rx) according to the given min-rx-osnr value. If
the input-power is lower it is expected to introduce an OSNR
penalty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_input_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__min_input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_input_power(self):
    self.__min_input_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_max_input_power(self):
    """
    Getter method for max_input_power, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_input_power (decimal64)

    YANG Description: Maximum tolerated input power in dBm at the receiver (Rx)
of the coherence transceiver, which if exceeded can cause an
overload.
    """
    return self.__max_input_power
      
  def _set_max_input_power(self, v, load=False):
    """
    Setter method for max_input_power, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_input_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_input_power() directly.

    YANG Description: Maximum tolerated input power in dBm at the receiver (Rx)
of the coherence transceiver, which if exceeded can cause an
overload.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_input_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__max_input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_input_power(self):
    self.__max_input_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_max_chromatic_dispersion(self):
    """
    Getter method for max_chromatic_dispersion, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_chromatic_dispersion (decimal64)

    YANG Description: Maximum chromatic-dispersion, accumulated value, supported by the
optical channel associated to the associated transmission mode
(operational model), expressed in picoseconds / nanometer (ps/nm).
    """
    return self.__max_chromatic_dispersion
      
  def _set_max_chromatic_dispersion(self, v, load=False):
    """
    Setter method for max_chromatic_dispersion, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_chromatic_dispersion (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_chromatic_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_chromatic_dispersion() directly.

    YANG Description: Maximum chromatic-dispersion, accumulated value, supported by the
optical channel associated to the associated transmission mode
(operational model), expressed in picoseconds / nanometer (ps/nm).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_chromatic_dispersion must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__max_chromatic_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_chromatic_dispersion(self):
    self.__max_chromatic_dispersion = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_max_differential_group_delay(self):
    """
    Getter method for max_differential_group_delay, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_differential_group_delay (decimal64)

    YANG Description: Maximum differential-group-delay, absolute value, supported by the
optical channel associated to the associated tranmission mode
(operational model), expressed in picoseconds (ps).
    """
    return self.__max_differential_group_delay
      
  def _set_max_differential_group_delay(self, v, load=False):
    """
    Setter method for max_differential_group_delay, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_differential_group_delay (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_differential_group_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_differential_group_delay() directly.

    YANG Description: Maximum differential-group-delay, absolute value, supported by the
optical channel associated to the associated tranmission mode
(operational model), expressed in picoseconds (ps).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-differential-group-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_differential_group_delay must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-differential-group-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__max_differential_group_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_differential_group_delay(self):
    self.__max_differential_group_delay = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-differential-group-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_max_polarization_dependent_loss(self):
    """
    Getter method for max_polarization_dependent_loss, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_polarization_dependent_loss (decimal64)

    YANG Description: Maximum polarization-dependent-loss accumulated value, supported by the
optical channel associated to the associated transmission mode
(operational model), expressed in decibels (dB)
    """
    return self.__max_polarization_dependent_loss
      
  def _set_max_polarization_dependent_loss(self, v, load=False):
    """
    Setter method for max_polarization_dependent_loss, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_polarization_dependent_loss (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_polarization_dependent_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_polarization_dependent_loss() directly.

    YANG Description: Maximum polarization-dependent-loss accumulated value, supported by the
optical channel associated to the associated transmission mode
(operational model), expressed in decibels (dB)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_polarization_dependent_loss must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__max_polarization_dependent_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_polarization_dependent_loss(self):
    self.__max_polarization_dependent_loss = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_pre_fec_ber_threshold(self):
    """
    Getter method for pre_fec_ber_threshold, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/pre_fec_ber_threshold (decimal64)

    YANG Description: Threshold on the PRE-FEC-BER, for which FEC code is able to
correct errors.
    """
    return self.__pre_fec_ber_threshold
      
  def _set_pre_fec_ber_threshold(self, v, load=False):
    """
    Setter method for pre_fec_ber_threshold, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/pre_fec_ber_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber_threshold() directly.

    YANG Description: Threshold on the PRE-FEC-BER, for which FEC code is able to
correct errors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="pre-fec-ber-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="pre-fec-ber-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__pre_fec_ber_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber_threshold(self):
    self.__pre_fec_ber_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="pre-fec-ber-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)

  mode_descriptor_id = __builtin__.property(_get_mode_descriptor_id)
  min_tx_osnr = __builtin__.property(_get_min_tx_osnr)
  min_rx_osnr = __builtin__.property(_get_min_rx_osnr)
  min_input_power = __builtin__.property(_get_min_input_power)
  max_input_power = __builtin__.property(_get_max_input_power)
  max_chromatic_dispersion = __builtin__.property(_get_max_chromatic_dispersion)
  max_differential_group_delay = __builtin__.property(_get_max_differential_group_delay)
  max_polarization_dependent_loss = __builtin__.property(_get_max_polarization_dependent_loss)
  pre_fec_ber_threshold = __builtin__.property(_get_pre_fec_ber_threshold)


  _pyangbind_elements = OrderedDict([('mode_descriptor_id', mode_descriptor_id), ('min_tx_osnr', min_tx_osnr), ('min_rx_osnr', min_rx_osnr), ('min_input_power', min_input_power), ('max_input_power', max_input_power), ('max_chromatic_dispersion', max_chromatic_dispersion), ('max_differential_group_delay', max_differential_group_delay), ('max_polarization_dependent_loss', max_polarization_dependent_loss), ('pre_fec_ber_threshold', pre_fec_ber_threshold), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device-properties - based on the path /operational-mode-descriptors/operational-modes/mode-descriptors/mode-descriptor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Mode-descriptor state attributes top container.
  """
  __slots__ = ('_path_helper', '_extmethods', '__mode_descriptor_id','__min_tx_osnr','__min_rx_osnr','__min_input_power','__max_input_power','__max_chromatic_dispersion','__max_differential_group_delay','__max_polarization_dependent_loss','__pre_fec_ber_threshold',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-terminal-device-properties'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__mode_descriptor_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='uint16', is_config=False)
    self.__min_tx_osnr = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-tx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__min_rx_osnr = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-rx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__min_input_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__max_input_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__max_chromatic_dispersion = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__max_differential_group_delay = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-differential-group-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__max_polarization_dependent_loss = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    self.__pre_fec_ber_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="pre-fec-ber-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['operational-mode-descriptors', 'operational-modes', 'mode-descriptors', 'mode-descriptor', 'state']

  def _get_mode_descriptor_id(self):
    """
    Getter method for mode_descriptor_id, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/mode_descriptor_id (uint16)

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    return self.__mode_descriptor_id
      
  def _set_mode_descriptor_id(self, v, load=False):
    """
    Setter method for mode_descriptor_id, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/mode_descriptor_id (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode_descriptor_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode_descriptor_id() directly.

    YANG Description: Two-octet encoding of the vendor-defined operational
mode
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='uint16', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode_descriptor_id must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='uint16', is_config=False)""",
        })

    self.__mode_descriptor_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode_descriptor_id(self):
    self.__mode_descriptor_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mode-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='uint16', is_config=False)


  def _get_min_tx_osnr(self):
    """
    Getter method for min_tx_osnr, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_tx_osnr (decimal64)

    YANG Description: Minimum in-band transmitter OSNR measured at 0.1nm@193.6Thz,
considering the maximum transceiver inserted noise. 
    """
    return self.__min_tx_osnr
      
  def _set_min_tx_osnr(self, v, load=False):
    """
    Setter method for min_tx_osnr, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_tx_osnr (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_tx_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_tx_osnr() directly.

    YANG Description: Minimum in-band transmitter OSNR measured at 0.1nm@193.6Thz,
considering the maximum transceiver inserted noise. 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-tx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_tx_osnr must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-tx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__min_tx_osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_tx_osnr(self):
    self.__min_tx_osnr = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-tx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_min_rx_osnr(self):
    """
    Getter method for min_rx_osnr, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_rx_osnr (decimal64)

    YANG Description: Minimum back-to-back OSNR measured over 0.1nm@193.6Thz or
12.5GHz noise resolution bandwidth at the min-input-power.
If received OSNR at min-input-power is lower than this value,
an increased level of bit-errors post-FEC needs to be
expected.
    """
    return self.__min_rx_osnr
      
  def _set_min_rx_osnr(self, v, load=False):
    """
    Setter method for min_rx_osnr, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_rx_osnr (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_rx_osnr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_rx_osnr() directly.

    YANG Description: Minimum back-to-back OSNR measured over 0.1nm@193.6Thz or
12.5GHz noise resolution bandwidth at the min-input-power.
If received OSNR at min-input-power is lower than this value,
an increased level of bit-errors post-FEC needs to be
expected.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-rx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_rx_osnr must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-rx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__min_rx_osnr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_rx_osnr(self):
    self.__min_rx_osnr = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-rx-osnr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_min_input_power(self):
    """
    Getter method for min_input_power, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_input_power (decimal64)

    YANG Description: Minimum value required input power in dBm of an optical channel
at the receiver (Rx) according to the given min-rx-osnr value. If
the input-power is lower it is expected to introduce an OSNR
penalty.
    """
    return self.__min_input_power
      
  def _set_min_input_power(self, v, load=False):
    """
    Setter method for min_input_power, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/min_input_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_input_power() directly.

    YANG Description: Minimum value required input power in dBm of an optical channel
at the receiver (Rx) according to the given min-rx-osnr value. If
the input-power is lower it is expected to introduce an OSNR
penalty.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_input_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__min_input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_input_power(self):
    self.__min_input_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="min-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_max_input_power(self):
    """
    Getter method for max_input_power, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_input_power (decimal64)

    YANG Description: Maximum tolerated input power in dBm at the receiver (Rx)
of the coherence transceiver, which if exceeded can cause an
overload.
    """
    return self.__max_input_power
      
  def _set_max_input_power(self, v, load=False):
    """
    Setter method for max_input_power, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_input_power (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_input_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_input_power() directly.

    YANG Description: Maximum tolerated input power in dBm at the receiver (Rx)
of the coherence transceiver, which if exceeded can cause an
overload.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_input_power must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__max_input_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_input_power(self):
    self.__max_input_power = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-input-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_max_chromatic_dispersion(self):
    """
    Getter method for max_chromatic_dispersion, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_chromatic_dispersion (decimal64)

    YANG Description: Maximum chromatic-dispersion, accumulated value, supported by the
optical channel associated to the associated transmission mode
(operational model), expressed in picoseconds / nanometer (ps/nm).
    """
    return self.__max_chromatic_dispersion
      
  def _set_max_chromatic_dispersion(self, v, load=False):
    """
    Setter method for max_chromatic_dispersion, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_chromatic_dispersion (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_chromatic_dispersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_chromatic_dispersion() directly.

    YANG Description: Maximum chromatic-dispersion, accumulated value, supported by the
optical channel associated to the associated transmission mode
(operational model), expressed in picoseconds / nanometer (ps/nm).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_chromatic_dispersion must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__max_chromatic_dispersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_chromatic_dispersion(self):
    self.__max_chromatic_dispersion = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-chromatic-dispersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_max_differential_group_delay(self):
    """
    Getter method for max_differential_group_delay, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_differential_group_delay (decimal64)

    YANG Description: Maximum differential-group-delay, absolute value, supported by the
optical channel associated to the associated tranmission mode
(operational model), expressed in picoseconds (ps).
    """
    return self.__max_differential_group_delay
      
  def _set_max_differential_group_delay(self, v, load=False):
    """
    Setter method for max_differential_group_delay, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_differential_group_delay (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_differential_group_delay is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_differential_group_delay() directly.

    YANG Description: Maximum differential-group-delay, absolute value, supported by the
optical channel associated to the associated tranmission mode
(operational model), expressed in picoseconds (ps).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-differential-group-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_differential_group_delay must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-differential-group-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__max_differential_group_delay = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_differential_group_delay(self):
    self.__max_differential_group_delay = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-differential-group-delay", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_max_polarization_dependent_loss(self):
    """
    Getter method for max_polarization_dependent_loss, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_polarization_dependent_loss (decimal64)

    YANG Description: Maximum polarization-dependent-loss accumulated value, supported by the
optical channel associated to the associated transmission mode
(operational model), expressed in decibels (dB)
    """
    return self.__max_polarization_dependent_loss
      
  def _set_max_polarization_dependent_loss(self, v, load=False):
    """
    Setter method for max_polarization_dependent_loss, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/max_polarization_dependent_loss (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_polarization_dependent_loss is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_polarization_dependent_loss() directly.

    YANG Description: Maximum polarization-dependent-loss accumulated value, supported by the
optical channel associated to the associated transmission mode
(operational model), expressed in decibels (dB)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_polarization_dependent_loss must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__max_polarization_dependent_loss = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_polarization_dependent_loss(self):
    self.__max_polarization_dependent_loss = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="max-polarization-dependent-loss", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)


  def _get_pre_fec_ber_threshold(self):
    """
    Getter method for pre_fec_ber_threshold, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/pre_fec_ber_threshold (decimal64)

    YANG Description: Threshold on the PRE-FEC-BER, for which FEC code is able to
correct errors.
    """
    return self.__pre_fec_ber_threshold
      
  def _set_pre_fec_ber_threshold(self, v, load=False):
    """
    Setter method for pre_fec_ber_threshold, mapped from YANG variable /operational_mode_descriptors/operational_modes/mode_descriptors/mode_descriptor/state/pre_fec_ber_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pre_fec_ber_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pre_fec_ber_threshold() directly.

    YANG Description: Threshold on the PRE-FEC-BER, for which FEC code is able to
correct errors.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="pre-fec-ber-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """pre_fec_ber_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="pre-fec-ber-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)""",
        })

    self.__pre_fec_ber_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_pre_fec_ber_threshold(self):
    self.__pre_fec_ber_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=18), is_leaf=True, yang_name="pre-fec-ber-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='decimal64', is_config=False)

  mode_descriptor_id = __builtin__.property(_get_mode_descriptor_id)
  min_tx_osnr = __builtin__.property(_get_min_tx_osnr)
  min_rx_osnr = __builtin__.property(_get_min_rx_osnr)
  min_input_power = __builtin__.property(_get_min_input_power)
  max_input_power = __builtin__.property(_get_max_input_power)
  max_chromatic_dispersion = __builtin__.property(_get_max_chromatic_dispersion)
  max_differential_group_delay = __builtin__.property(_get_max_differential_group_delay)
  max_polarization_dependent_loss = __builtin__.property(_get_max_polarization_dependent_loss)
  pre_fec_ber_threshold = __builtin__.property(_get_pre_fec_ber_threshold)


  _pyangbind_elements = OrderedDict([('mode_descriptor_id', mode_descriptor_id), ('min_tx_osnr', min_tx_osnr), ('min_rx_osnr', min_rx_osnr), ('min_input_power', min_input_power), ('max_input_power', max_input_power), ('max_chromatic_dispersion', max_chromatic_dispersion), ('max_differential_group_delay', max_differential_group_delay), ('max_polarization_dependent_loss', max_polarization_dependent_loss), ('pre_fec_ber_threshold', pre_fec_ber_threshold), ])


