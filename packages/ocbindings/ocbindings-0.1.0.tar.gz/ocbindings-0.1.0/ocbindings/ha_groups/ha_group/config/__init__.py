# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-fw-high-availability - based on the path /ha-groups/ha-group/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Config container for HA parameters
  """
  __slots__ = ('_path_helper', '_extmethods', '__ha_enabled','__ha_mode','__ha_key','__ha_key_hashed','__ha_msg_encryption','__id','__ha_device_id','__preempt','__priority','__preempt_hold_timer','__hello_interval','__global_health_policy',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oc-fw-ha'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ha_enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    self.__ha_mode = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE_PASSIVE': {}},), is_leaf=True, yang_name="ha-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)
    self.__ha_key = YANGDynClass(base=str, is_leaf=True, yang_name="ha-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='string', is_config=True)
    self.__ha_key_hashed = YANGDynClass(base=str, is_leaf=True, yang_name="ha-key-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='oc-aaa-types:crypt-password-type', is_config=True)
    self.__ha_msg_encryption = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-msg-encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    self.__ha_device_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ha-device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    self.__preempt_hold_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preempt-hold-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)
    self.__global_health_policy = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ANY': {}, 'ALL': {}},), is_leaf=True, yang_name="global-health-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ha-groups', 'ha-group', 'config']

  def _get_ha_enabled(self):
    """
    Getter method for ha_enabled, mapped from YANG variable /ha_groups/ha_group/config/ha_enabled (boolean)

    YANG Description: This must be set to 'true' to initiate firewall participation
in a HA cluster. Once set to 'true', this boolean can be
flipped to 'false' to DISABLE HA and put a unit in a
'suspended' state while retaining all other HA settings &
configuration parameters. At the same time the 'ha-state' leaf
under 'ha-parameters-state' must then be updated to
'SUSPENDED'
    """
    return self.__ha_enabled
      
  def _set_ha_enabled(self, v, load=False):
    """
    Setter method for ha_enabled, mapped from YANG variable /ha_groups/ha_group/config/ha_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_enabled() directly.

    YANG Description: This must be set to 'true' to initiate firewall participation
in a HA cluster. Once set to 'true', this boolean can be
flipped to 'false' to DISABLE HA and put a unit in a
'suspended' state while retaining all other HA settings &
configuration parameters. At the same time the 'ha-state' leaf
under 'ha-parameters-state' must then be updated to
'SUSPENDED'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)""",
        })

    self.__ha_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_enabled(self):
    self.__ha_enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)


  def _get_ha_mode(self):
    """
    Getter method for ha_mode, mapped from YANG variable /ha_groups/ha_group/config/ha_mode (enumeration)

    YANG Description: Configurable HA modes
    """
    return self.__ha_mode
      
  def _set_ha_mode(self, v, load=False):
    """
    Setter method for ha_mode, mapped from YANG variable /ha_groups/ha_group/config/ha_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_mode() directly.

    YANG Description: Configurable HA modes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE_PASSIVE': {}},), is_leaf=True, yang_name="ha-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-fw-high-availability:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE_PASSIVE': {}},), is_leaf=True, yang_name="ha-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)""",
        })

    self.__ha_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_mode(self):
    self.__ha_mode = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE_PASSIVE': {}},), is_leaf=True, yang_name="ha-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)


  def _get_ha_key(self):
    """
    Getter method for ha_key, mapped from YANG variable /ha_groups/ha_group/config/ha_key (string)

    YANG Description: HA key used to encrypt & authenticate HA messages betwen
the peers. This is provided in clear-text by the client &
expected to be hashed by the firewall in the configuration
    """
    return self.__ha_key
      
  def _set_ha_key(self, v, load=False):
    """
    Setter method for ha_key, mapped from YANG variable /ha_groups/ha_group/config/ha_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_key() directly.

    YANG Description: HA key used to encrypt & authenticate HA messages betwen
the peers. This is provided in clear-text by the client &
expected to be hashed by the firewall in the configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="ha-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="ha-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='string', is_config=True)""",
        })

    self.__ha_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_key(self):
    self.__ha_key = YANGDynClass(base=str, is_leaf=True, yang_name="ha-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='string', is_config=True)


  def _get_ha_key_hashed(self):
    """
    Getter method for ha_key_hashed, mapped from YANG variable /ha_groups/ha_group/config/ha_key_hashed (oc-aaa-types:crypt-password-type)

    YANG Description: HA key,used to encrypt & authenticate HA messages between
the peers, supplied as a hashed value using the notation
     described in the definition of the crypt-password-type
    """
    return self.__ha_key_hashed
      
  def _set_ha_key_hashed(self, v, load=False):
    """
    Setter method for ha_key_hashed, mapped from YANG variable /ha_groups/ha_group/config/ha_key_hashed (oc-aaa-types:crypt-password-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_key_hashed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_key_hashed() directly.

    YANG Description: HA key,used to encrypt & authenticate HA messages between
the peers, supplied as a hashed value using the notation
     described in the definition of the crypt-password-type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="ha-key-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='oc-aaa-types:crypt-password-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_key_hashed must be of a type compatible with oc-aaa-types:crypt-password-type""",
          'defined-type': "oc-aaa-types:crypt-password-type",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="ha-key-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='oc-aaa-types:crypt-password-type', is_config=True)""",
        })

    self.__ha_key_hashed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_key_hashed(self):
    self.__ha_key_hashed = YANGDynClass(base=str, is_leaf=True, yang_name="ha-key-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='oc-aaa-types:crypt-password-type', is_config=True)


  def _get_ha_msg_encryption(self):
    """
    Getter method for ha_msg_encryption, mapped from YANG variable /ha_groups/ha_group/config/ha_msg_encryption (boolean)

    YANG Description: When set to true all traffic between firewall units in a HA
cluster are encrypted. If operator provided encryption key is
supported, that value must be derived from the
ha-key/ha-key-hashed leaf nodes. If that is not supported, the
vendor is expected to derive it's own keying material
    """
    return self.__ha_msg_encryption
      
  def _set_ha_msg_encryption(self, v, load=False):
    """
    Setter method for ha_msg_encryption, mapped from YANG variable /ha_groups/ha_group/config/ha_msg_encryption (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_msg_encryption is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_msg_encryption() directly.

    YANG Description: When set to true all traffic between firewall units in a HA
cluster are encrypted. If operator provided encryption key is
supported, that value must be derived from the
ha-key/ha-key-hashed leaf nodes. If that is not supported, the
vendor is expected to derive it's own keying material
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-msg-encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_msg_encryption must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-msg-encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)""",
        })

    self.__ha_msg_encryption = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_msg_encryption(self):
    self.__ha_msg_encryption = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-msg-encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ha_groups/ha_group/config/id (uint8)

    YANG Description: The high availbility group id for a unit. This value MUST
match across both units participating in a HA cluster
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ha_groups/ha_group/config/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The high availbility group id for a unit. This value MUST
match across both units participating in a HA cluster
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)


  def _get_ha_device_id(self):
    """
    Getter method for ha_device_id, mapped from YANG variable /ha_groups/ha_group/config/ha_device_id (uint8)

    YANG Description: Specify the device-id to identify the firewall within a HA
group. This value MUST be unique to the local-unit and MUST
NOT clash with the peer within a ha-group
    """
    return self.__ha_device_id
      
  def _set_ha_device_id(self, v, load=False):
    """
    Setter method for ha_device_id, mapped from YANG variable /ha_groups/ha_group/config/ha_device_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_device_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_device_id() directly.

    YANG Description: Specify the device-id to identify the firewall within a HA
group. This value MUST be unique to the local-unit and MUST
NOT clash with the peer within a ha-group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ha-device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_device_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ha-device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)""",
        })

    self.__ha_device_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_device_id(self):
    self.__ha_device_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ha-device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /ha_groups/ha_group/config/preempt (boolean)

    YANG Description: When set to true the firewall forces reelection of the active
role after joining the cluster
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /ha_groups/ha_group/config/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true the firewall forces reelection of the active
role after joining the cluster
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /ha_groups/ha_group/config/priority (uint8)

    YANG Description: Set priority value for the firewall. This value is used
to participate in the election of the active unit in the HA
cluster. Firewall with highest priority is elected as the
ACTIVE unit
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /ha_groups/ha_group/config/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Set priority value for the firewall. This value is used
to participate in the election of the active unit in the HA
cluster. Firewall with highest priority is elected as the
ACTIVE unit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)


  def _get_preempt_hold_timer(self):
    """
    Getter method for preempt_hold_timer, mapped from YANG variable /ha_groups/ha_group/config/preempt_hold_timer (uint32)

    YANG Description: Length of time, from the last received Hello message,
a firewall will wait before taking over the active role in a
HA pair
    """
    return self.__preempt_hold_timer
      
  def _set_preempt_hold_timer(self, v, load=False):
    """
    Setter method for preempt_hold_timer, mapped from YANG variable /ha_groups/ha_group/config/preempt_hold_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_hold_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_hold_timer() directly.

    YANG Description: Length of time, from the last received Hello message,
a firewall will wait before taking over the active role in a
HA pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preempt-hold-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_hold_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preempt-hold-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)""",
        })

    self.__preempt_hold_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_hold_timer(self):
    self.__preempt_hold_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preempt-hold-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)


  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /ha_groups/ha_group/config/hello_interval (uint32)

    YANG Description: Interval between hello messages exchanged by the HA peers
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /ha_groups/ha_group/config/hello_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval between hello messages exchanged by the HA peers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)


  def _get_global_health_policy(self):
    """
    Getter method for global_health_policy, mapped from YANG variable /ha_groups/ha_group/config/global_health_policy (enumeration)

    YANG Description: Global health values associated with the interface monitoring
state machine
    """
    return self.__global_health_policy
      
  def _set_global_health_policy(self, v, load=False):
    """
    Setter method for global_health_policy, mapped from YANG variable /ha_groups/ha_group/config/global_health_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_health_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_health_policy() directly.

    YANG Description: Global health values associated with the interface monitoring
state machine
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ANY': {}, 'ALL': {}},), is_leaf=True, yang_name="global-health-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_health_policy must be of a type compatible with enumeration""",
          'defined-type': "openconfig-fw-high-availability:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ANY': {}, 'ALL': {}},), is_leaf=True, yang_name="global-health-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)""",
        })

    self.__global_health_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_health_policy(self):
    self.__global_health_policy = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ANY': {}, 'ALL': {}},), is_leaf=True, yang_name="global-health-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)

  ha_enabled = __builtin__.property(_get_ha_enabled, _set_ha_enabled)
  ha_mode = __builtin__.property(_get_ha_mode, _set_ha_mode)
  ha_key = __builtin__.property(_get_ha_key, _set_ha_key)
  ha_key_hashed = __builtin__.property(_get_ha_key_hashed, _set_ha_key_hashed)
  ha_msg_encryption = __builtin__.property(_get_ha_msg_encryption, _set_ha_msg_encryption)
  id = __builtin__.property(_get_id, _set_id)
  ha_device_id = __builtin__.property(_get_ha_device_id, _set_ha_device_id)
  preempt = __builtin__.property(_get_preempt, _set_preempt)
  priority = __builtin__.property(_get_priority, _set_priority)
  preempt_hold_timer = __builtin__.property(_get_preempt_hold_timer, _set_preempt_hold_timer)
  hello_interval = __builtin__.property(_get_hello_interval, _set_hello_interval)
  global_health_policy = __builtin__.property(_get_global_health_policy, _set_global_health_policy)


  _pyangbind_elements = OrderedDict([('ha_enabled', ha_enabled), ('ha_mode', ha_mode), ('ha_key', ha_key), ('ha_key_hashed', ha_key_hashed), ('ha_msg_encryption', ha_msg_encryption), ('id', id), ('ha_device_id', ha_device_id), ('preempt', preempt), ('priority', priority), ('preempt_hold_timer', preempt_hold_timer), ('hello_interval', hello_interval), ('global_health_policy', global_health_policy), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-fw-high-availability - based on the path /ha-groups/ha-group/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Config container for HA parameters
  """
  __slots__ = ('_path_helper', '_extmethods', '__ha_enabled','__ha_mode','__ha_key','__ha_key_hashed','__ha_msg_encryption','__id','__ha_device_id','__preempt','__priority','__preempt_hold_timer','__hello_interval','__global_health_policy',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/oc-fw-ha'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__ha_enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    self.__ha_mode = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE_PASSIVE': {}},), is_leaf=True, yang_name="ha-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)
    self.__ha_key = YANGDynClass(base=str, is_leaf=True, yang_name="ha-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='string', is_config=True)
    self.__ha_key_hashed = YANGDynClass(base=str, is_leaf=True, yang_name="ha-key-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='oc-aaa-types:crypt-password-type', is_config=True)
    self.__ha_msg_encryption = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-msg-encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    self.__ha_device_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ha-device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    self.__preempt_hold_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preempt-hold-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)
    self.__global_health_policy = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ANY': {}, 'ALL': {}},), is_leaf=True, yang_name="global-health-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ha-groups', 'ha-group', 'config']

  def _get_ha_enabled(self):
    """
    Getter method for ha_enabled, mapped from YANG variable /ha_groups/ha_group/config/ha_enabled (boolean)

    YANG Description: This must be set to 'true' to initiate firewall participation
in a HA cluster. Once set to 'true', this boolean can be
flipped to 'false' to DISABLE HA and put a unit in a
'suspended' state while retaining all other HA settings &
configuration parameters. At the same time the 'ha-state' leaf
under 'ha-parameters-state' must then be updated to
'SUSPENDED'
    """
    return self.__ha_enabled
      
  def _set_ha_enabled(self, v, load=False):
    """
    Setter method for ha_enabled, mapped from YANG variable /ha_groups/ha_group/config/ha_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_enabled() directly.

    YANG Description: This must be set to 'true' to initiate firewall participation
in a HA cluster. Once set to 'true', this boolean can be
flipped to 'false' to DISABLE HA and put a unit in a
'suspended' state while retaining all other HA settings &
configuration parameters. At the same time the 'ha-state' leaf
under 'ha-parameters-state' must then be updated to
'SUSPENDED'
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)""",
        })

    self.__ha_enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_enabled(self):
    self.__ha_enabled = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)


  def _get_ha_mode(self):
    """
    Getter method for ha_mode, mapped from YANG variable /ha_groups/ha_group/config/ha_mode (enumeration)

    YANG Description: Configurable HA modes
    """
    return self.__ha_mode
      
  def _set_ha_mode(self, v, load=False):
    """
    Setter method for ha_mode, mapped from YANG variable /ha_groups/ha_group/config/ha_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_mode() directly.

    YANG Description: Configurable HA modes
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE_PASSIVE': {}},), is_leaf=True, yang_name="ha-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-fw-high-availability:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE_PASSIVE': {}},), is_leaf=True, yang_name="ha-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)""",
        })

    self.__ha_mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_mode(self):
    self.__ha_mode = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ACTIVE_PASSIVE': {}},), is_leaf=True, yang_name="ha-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)


  def _get_ha_key(self):
    """
    Getter method for ha_key, mapped from YANG variable /ha_groups/ha_group/config/ha_key (string)

    YANG Description: HA key used to encrypt & authenticate HA messages betwen
the peers. This is provided in clear-text by the client &
expected to be hashed by the firewall in the configuration
    """
    return self.__ha_key
      
  def _set_ha_key(self, v, load=False):
    """
    Setter method for ha_key, mapped from YANG variable /ha_groups/ha_group/config/ha_key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_key() directly.

    YANG Description: HA key used to encrypt & authenticate HA messages betwen
the peers. This is provided in clear-text by the client &
expected to be hashed by the firewall in the configuration
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="ha-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_key must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="ha-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='string', is_config=True)""",
        })

    self.__ha_key = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_key(self):
    self.__ha_key = YANGDynClass(base=str, is_leaf=True, yang_name="ha-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='string', is_config=True)


  def _get_ha_key_hashed(self):
    """
    Getter method for ha_key_hashed, mapped from YANG variable /ha_groups/ha_group/config/ha_key_hashed (oc-aaa-types:crypt-password-type)

    YANG Description: HA key,used to encrypt & authenticate HA messages between
the peers, supplied as a hashed value using the notation
     described in the definition of the crypt-password-type
    """
    return self.__ha_key_hashed
      
  def _set_ha_key_hashed(self, v, load=False):
    """
    Setter method for ha_key_hashed, mapped from YANG variable /ha_groups/ha_group/config/ha_key_hashed (oc-aaa-types:crypt-password-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_key_hashed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_key_hashed() directly.

    YANG Description: HA key,used to encrypt & authenticate HA messages between
the peers, supplied as a hashed value using the notation
     described in the definition of the crypt-password-type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="ha-key-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='oc-aaa-types:crypt-password-type', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_key_hashed must be of a type compatible with oc-aaa-types:crypt-password-type""",
          'defined-type': "oc-aaa-types:crypt-password-type",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="ha-key-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='oc-aaa-types:crypt-password-type', is_config=True)""",
        })

    self.__ha_key_hashed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_key_hashed(self):
    self.__ha_key_hashed = YANGDynClass(base=str, is_leaf=True, yang_name="ha-key-hashed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='oc-aaa-types:crypt-password-type', is_config=True)


  def _get_ha_msg_encryption(self):
    """
    Getter method for ha_msg_encryption, mapped from YANG variable /ha_groups/ha_group/config/ha_msg_encryption (boolean)

    YANG Description: When set to true all traffic between firewall units in a HA
cluster are encrypted. If operator provided encryption key is
supported, that value must be derived from the
ha-key/ha-key-hashed leaf nodes. If that is not supported, the
vendor is expected to derive it's own keying material
    """
    return self.__ha_msg_encryption
      
  def _set_ha_msg_encryption(self, v, load=False):
    """
    Setter method for ha_msg_encryption, mapped from YANG variable /ha_groups/ha_group/config/ha_msg_encryption (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_msg_encryption is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_msg_encryption() directly.

    YANG Description: When set to true all traffic between firewall units in a HA
cluster are encrypted. If operator provided encryption key is
supported, that value must be derived from the
ha-key/ha-key-hashed leaf nodes. If that is not supported, the
vendor is expected to derive it's own keying material
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-msg-encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_msg_encryption must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-msg-encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)""",
        })

    self.__ha_msg_encryption = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_msg_encryption(self):
    self.__ha_msg_encryption = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="ha-msg-encryption", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /ha_groups/ha_group/config/id (uint8)

    YANG Description: The high availbility group id for a unit. This value MUST
match across both units participating in a HA cluster
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /ha_groups/ha_group/config/id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The high availbility group id for a unit. This value MUST
match across both units participating in a HA cluster
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)


  def _get_ha_device_id(self):
    """
    Getter method for ha_device_id, mapped from YANG variable /ha_groups/ha_group/config/ha_device_id (uint8)

    YANG Description: Specify the device-id to identify the firewall within a HA
group. This value MUST be unique to the local-unit and MUST
NOT clash with the peer within a ha-group
    """
    return self.__ha_device_id
      
  def _set_ha_device_id(self, v, load=False):
    """
    Setter method for ha_device_id, mapped from YANG variable /ha_groups/ha_group/config/ha_device_id (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ha_device_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ha_device_id() directly.

    YANG Description: Specify the device-id to identify the firewall within a HA
group. This value MUST be unique to the local-unit and MUST
NOT clash with the peer within a ha-group
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ha-device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ha_device_id must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ha-device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)""",
        })

    self.__ha_device_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ha_device_id(self):
    self.__ha_device_id = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="ha-device-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)


  def _get_preempt(self):
    """
    Getter method for preempt, mapped from YANG variable /ha_groups/ha_group/config/preempt (boolean)

    YANG Description: When set to true the firewall forces reelection of the active
role after joining the cluster
    """
    return self.__preempt
      
  def _set_preempt(self, v, load=False):
    """
    Setter method for preempt, mapped from YANG variable /ha_groups/ha_group/config/preempt (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt() directly.

    YANG Description: When set to true the firewall forces reelection of the active
role after joining the cluster
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)""",
        })

    self.__preempt = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt(self):
    self.__preempt = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="preempt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='boolean', is_config=True)


  def _get_priority(self):
    """
    Getter method for priority, mapped from YANG variable /ha_groups/ha_group/config/priority (uint8)

    YANG Description: Set priority value for the firewall. This value is used
to participate in the election of the active unit in the HA
cluster. Firewall with highest priority is elected as the
ACTIVE unit
    """
    return self.__priority
      
  def _set_priority(self, v, load=False):
    """
    Setter method for priority, mapped from YANG variable /ha_groups/ha_group/config/priority (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Set priority value for the firewall. This value is used
to participate in the election of the active unit in the HA
cluster. Firewall with highest priority is elected as the
ACTIVE unit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """priority must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)""",
        })

    self.__priority = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_priority(self):
    self.__priority = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint8', is_config=True)


  def _get_preempt_hold_timer(self):
    """
    Getter method for preempt_hold_timer, mapped from YANG variable /ha_groups/ha_group/config/preempt_hold_timer (uint32)

    YANG Description: Length of time, from the last received Hello message,
a firewall will wait before taking over the active role in a
HA pair
    """
    return self.__preempt_hold_timer
      
  def _set_preempt_hold_timer(self, v, load=False):
    """
    Setter method for preempt_hold_timer, mapped from YANG variable /ha_groups/ha_group/config/preempt_hold_timer (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preempt_hold_timer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preempt_hold_timer() directly.

    YANG Description: Length of time, from the last received Hello message,
a firewall will wait before taking over the active role in a
HA pair
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preempt-hold-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preempt_hold_timer must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preempt-hold-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)""",
        })

    self.__preempt_hold_timer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preempt_hold_timer(self):
    self.__preempt_hold_timer = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="preempt-hold-timer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)


  def _get_hello_interval(self):
    """
    Getter method for hello_interval, mapped from YANG variable /ha_groups/ha_group/config/hello_interval (uint32)

    YANG Description: Interval between hello messages exchanged by the HA peers
    """
    return self.__hello_interval
      
  def _set_hello_interval(self, v, load=False):
    """
    Setter method for hello_interval, mapped from YANG variable /ha_groups/ha_group/config/hello_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hello_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hello_interval() directly.

    YANG Description: Interval between hello messages exchanged by the HA peers
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hello_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)""",
        })

    self.__hello_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hello_interval(self):
    self.__hello_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hello-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='uint32', is_config=True)


  def _get_global_health_policy(self):
    """
    Getter method for global_health_policy, mapped from YANG variable /ha_groups/ha_group/config/global_health_policy (enumeration)

    YANG Description: Global health values associated with the interface monitoring
state machine
    """
    return self.__global_health_policy
      
  def _set_global_health_policy(self, v, load=False):
    """
    Setter method for global_health_policy, mapped from YANG variable /ha_groups/ha_group/config/global_health_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_global_health_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_global_health_policy() directly.

    YANG Description: Global health values associated with the interface monitoring
state machine
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ANY': {}, 'ALL': {}},), is_leaf=True, yang_name="global-health-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """global_health_policy must be of a type compatible with enumeration""",
          'defined-type': "openconfig-fw-high-availability:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ANY': {}, 'ALL': {}},), is_leaf=True, yang_name="global-health-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)""",
        })

    self.__global_health_policy = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_global_health_policy(self):
    self.__global_health_policy = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ANY': {}, 'ALL': {}},), is_leaf=True, yang_name="global-health-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/oc-fw-ha', defining_module='openconfig-fw-high-availability', yang_type='enumeration', is_config=True)

  ha_enabled = __builtin__.property(_get_ha_enabled, _set_ha_enabled)
  ha_mode = __builtin__.property(_get_ha_mode, _set_ha_mode)
  ha_key = __builtin__.property(_get_ha_key, _set_ha_key)
  ha_key_hashed = __builtin__.property(_get_ha_key_hashed, _set_ha_key_hashed)
  ha_msg_encryption = __builtin__.property(_get_ha_msg_encryption, _set_ha_msg_encryption)
  id = __builtin__.property(_get_id, _set_id)
  ha_device_id = __builtin__.property(_get_ha_device_id, _set_ha_device_id)
  preempt = __builtin__.property(_get_preempt, _set_preempt)
  priority = __builtin__.property(_get_priority, _set_priority)
  preempt_hold_timer = __builtin__.property(_get_preempt_hold_timer, _set_preempt_hold_timer)
  hello_interval = __builtin__.property(_get_hello_interval, _set_hello_interval)
  global_health_policy = __builtin__.property(_get_global_health_policy, _set_global_health_policy)


  _pyangbind_elements = OrderedDict([('ha_enabled', ha_enabled), ('ha_mode', ha_mode), ('ha_key', ha_key), ('ha_key_hashed', ha_key_hashed), ('ha_msg_encryption', ha_msg_encryption), ('id', id), ('ha_device_id', ha_device_id), ('preempt', preempt), ('priority', priority), ('preempt_hold_timer', preempt_hold_timer), ('hello_interval', hello_interval), ('global_health_policy', global_health_policy), ])


