# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for an automatic protection
switch module
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revertive','__wait_to_restore_time','__hold_off_time','__primary_switch_threshold','__primary_switch_hysteresis','__secondary_switch_threshold','__relative_switch_threshold','__relative_switch_threshold_offset','__force_to_port',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    self.__wait_to_restore_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    self.__hold_off_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__relative_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__relative_switch_threshold_offset = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__force_to_port = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=str("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /aps/aps_modules/aps_module/config/name (leafref)

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /aps/aps_modules/aps_module/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/config/revertive (boolean)

    YANG Description: Revertive behavior of the module. If True, then
automatically revert after protection switch once the
fault is restored. This leaf is not valid when the
relative-switch-threshold is in effect
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/config/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: Revertive behavior of the module. If True, then
automatically revert after protection switch once the
fault is restored. This leaf is not valid when the
relative-switch-threshold is in effect
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_wait_to_restore_time(self):
    """
    Getter method for wait_to_restore_time, mapped from YANG variable /aps/aps_modules/aps_module/config/wait_to_restore_time (uint32)

    YANG Description: The time that must elapse before an APS path
that has recovered from an signal failure (SF) or signal
degradation (SD) condition can be used again to transport
the normal traffic signal. During this time period, an SF or
SD condition shall override the wait-to-restore time period.
This leaf can only take effect when the revertive leaf
equals true
    """
    return self.__wait_to_restore_time
      
  def _set_wait_to_restore_time(self, v, load=False):
    """
    Setter method for wait_to_restore_time, mapped from YANG variable /aps/aps_modules/aps_module/config/wait_to_restore_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wait_to_restore_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wait_to_restore_time() directly.

    YANG Description: The time that must elapse before an APS path
that has recovered from an signal failure (SF) or signal
degradation (SD) condition can be used again to transport
the normal traffic signal. During this time period, an SF or
SD condition shall override the wait-to-restore time period.
This leaf can only take effect when the revertive leaf
equals true
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wait_to_restore_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)""",
        })

    self.__wait_to_restore_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wait_to_restore_time(self):
    self.__wait_to_restore_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)


  def _get_hold_off_time(self):
    """
    Getter method for hold_off_time, mapped from YANG variable /aps/aps_modules/aps_module/config/hold_off_time (uint32)

    YANG Description: The time delay between the declaration of an SF or SD
condition and the initiation of the protection switching
algorithm
    """
    return self.__hold_off_time
      
  def _set_hold_off_time(self, v, load=False):
    """
    Setter method for hold_off_time, mapped from YANG variable /aps/aps_modules/aps_module/config/hold_off_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_off_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_off_time() directly.

    YANG Description: The time delay between the declaration of an SF or SD
condition and the initiation of the protection switching
algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_off_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)""",
        })

    self.__hold_off_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_off_time(self):
    self.__hold_off_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)


  def _get_primary_switch_threshold(self):
    """
    Getter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_threshold (decimal64)

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
primary switch threshold will be overridden
    """
    return self.__primary_switch_threshold
      
  def _set_primary_switch_threshold(self, v, load=False):
    """
    Setter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_threshold() directly.

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
primary switch threshold will be overridden
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__primary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_threshold(self):
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_primary_switch_hysteresis(self):
    """
    Getter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_hysteresis (decimal64)

    YANG Description: The delta in dB between the primary-switch-threshold
and the signal received on the primary APS_PATH before
initiating a switch from the secondary APS_PATH to the
primary APS_PATH, in order to prevent toggling between ports
when an input signal is very close to the threshold. A zero
value means the switch hysteresis is disabled.
    """
    return self.__primary_switch_hysteresis
      
  def _set_primary_switch_hysteresis(self, v, load=False):
    """
    Setter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_hysteresis (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_hysteresis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_hysteresis() directly.

    YANG Description: The delta in dB between the primary-switch-threshold
and the signal received on the primary APS_PATH before
initiating a switch from the secondary APS_PATH to the
primary APS_PATH, in order to prevent toggling between ports
when an input signal is very close to the threshold. A zero
value means the switch hysteresis is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_hysteresis must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__primary_switch_hysteresis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_hysteresis(self):
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_secondary_switch_threshold(self):
    """
    Getter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_threshold (decimal64)

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
secondary switch threshold will be overridden
    """
    return self.__secondary_switch_threshold
      
  def _set_secondary_switch_threshold(self, v, load=False):
    """
    Setter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_switch_threshold() directly.

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
secondary switch threshold will be overridden
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__secondary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_switch_threshold(self):
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_relative_switch_threshold(self):
    """
    Getter method for relative_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold (decimal64)

    YANG Description: The delta threshold in dB at which the current line port
will switch to the opposite line port. It can be set to
the value of 0dB. When set to 0dB, the threshold is ignored
and the system automatically applies the primary and
secondary switch thresholds. When set to a non-zero value,
it overrides the primary and secondary switch thresholds
    """
    return self.__relative_switch_threshold
      
  def _set_relative_switch_threshold(self, v, load=False):
    """
    Setter method for relative_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relative_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relative_switch_threshold() directly.

    YANG Description: The delta threshold in dB at which the current line port
will switch to the opposite line port. It can be set to
the value of 0dB. When set to 0dB, the threshold is ignored
and the system automatically applies the primary and
secondary switch thresholds. When set to a non-zero value,
it overrides the primary and secondary switch thresholds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relative_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__relative_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relative_switch_threshold(self):
    self.__relative_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_relative_switch_threshold_offset(self):
    """
    Getter method for relative_switch_threshold_offset, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold_offset (decimal64)

    YANG Description: The offset of the relative switch threshold that compensates
the normal difference of receiving power between the primary
and secondary line ports. A negative offset corresponds to
the situation where the secondary line port receives a higher
power than the primary line port in normal condition， and a
positive offset means the opposite. The offset will only work
when the relative switch threshold is set to a non-zero
value
    """
    return self.__relative_switch_threshold_offset
      
  def _set_relative_switch_threshold_offset(self, v, load=False):
    """
    Setter method for relative_switch_threshold_offset, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold_offset (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relative_switch_threshold_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relative_switch_threshold_offset() directly.

    YANG Description: The offset of the relative switch threshold that compensates
the normal difference of receiving power between the primary
and secondary line ports. A negative offset corresponds to
the situation where the secondary line port receives a higher
power than the primary line port in normal condition， and a
positive offset means the opposite. The offset will only work
when the relative switch threshold is set to a non-zero
value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relative_switch_threshold_offset must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__relative_switch_threshold_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relative_switch_threshold_offset(self):
    self.__relative_switch_threshold_offset = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_force_to_port(self):
    """
    Getter method for force_to_port, mapped from YANG variable /aps/aps_modules/aps_module/config/force_to_port (enumeration)

    YANG Description: Explicitly set the switch to stay on a port regardless of
its operational condition
    """
    return self.__force_to_port
      
  def _set_force_to_port(self, v, load=False):
    """
    Setter method for force_to_port, mapped from YANG variable /aps/aps_modules/aps_module/config/force_to_port (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_force_to_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_force_to_port() directly.

    YANG Description: Explicitly set the switch to stay on a port regardless of
its operational condition
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=str("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """force_to_port must be of a type compatible with enumeration""",
          'defined-type': "openconfig-transport-line-protection:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=str("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)""",
        })

    self.__force_to_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_force_to_port(self):
    self.__force_to_port = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=str("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revertive = __builtin__.property(_get_revertive, _set_revertive)
  wait_to_restore_time = __builtin__.property(_get_wait_to_restore_time, _set_wait_to_restore_time)
  hold_off_time = __builtin__.property(_get_hold_off_time, _set_hold_off_time)
  primary_switch_threshold = __builtin__.property(_get_primary_switch_threshold, _set_primary_switch_threshold)
  primary_switch_hysteresis = __builtin__.property(_get_primary_switch_hysteresis, _set_primary_switch_hysteresis)
  secondary_switch_threshold = __builtin__.property(_get_secondary_switch_threshold, _set_secondary_switch_threshold)
  relative_switch_threshold = __builtin__.property(_get_relative_switch_threshold, _set_relative_switch_threshold)
  relative_switch_threshold_offset = __builtin__.property(_get_relative_switch_threshold_offset, _set_relative_switch_threshold_offset)
  force_to_port = __builtin__.property(_get_force_to_port, _set_force_to_port)


  _pyangbind_elements = OrderedDict([('name', name), ('revertive', revertive), ('wait_to_restore_time', wait_to_restore_time), ('hold_off_time', hold_off_time), ('primary_switch_threshold', primary_switch_threshold), ('primary_switch_hysteresis', primary_switch_hysteresis), ('secondary_switch_threshold', secondary_switch_threshold), ('relative_switch_threshold', relative_switch_threshold), ('relative_switch_threshold_offset', relative_switch_threshold_offset), ('force_to_port', force_to_port), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-transport-line-protection - based on the path /aps/aps-modules/aps-module/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for an automatic protection
switch module
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__revertive','__wait_to_restore_time','__hold_off_time','__primary_switch_threshold','__primary_switch_hysteresis','__secondary_switch_threshold','__relative_switch_threshold','__relative_switch_threshold_offset','__force_to_port',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/optical-transport-line-protection'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    self.__wait_to_restore_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    self.__hold_off_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__relative_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__relative_switch_threshold_offset = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    self.__force_to_port = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=str("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['aps', 'aps-modules', 'aps-module', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /aps/aps_modules/aps_module/config/name (leafref)

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /aps/aps_modules/aps_module/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the component name (in the platform model)
corresponding to this automatic protection switch module
in the device
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='leafref', is_config=True)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/config/revertive (boolean)

    YANG Description: Revertive behavior of the module. If True, then
automatically revert after protection switch once the
fault is restored. This leaf is not valid when the
relative-switch-threshold is in effect
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /aps/aps_modules/aps_module/config/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: Revertive behavior of the module. If True, then
automatically revert after protection switch once the
fault is restored. This leaf is not valid when the
relative-switch-threshold is in effect
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='boolean', is_config=True)


  def _get_wait_to_restore_time(self):
    """
    Getter method for wait_to_restore_time, mapped from YANG variable /aps/aps_modules/aps_module/config/wait_to_restore_time (uint32)

    YANG Description: The time that must elapse before an APS path
that has recovered from an signal failure (SF) or signal
degradation (SD) condition can be used again to transport
the normal traffic signal. During this time period, an SF or
SD condition shall override the wait-to-restore time period.
This leaf can only take effect when the revertive leaf
equals true
    """
    return self.__wait_to_restore_time
      
  def _set_wait_to_restore_time(self, v, load=False):
    """
    Setter method for wait_to_restore_time, mapped from YANG variable /aps/aps_modules/aps_module/config/wait_to_restore_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_wait_to_restore_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_wait_to_restore_time() directly.

    YANG Description: The time that must elapse before an APS path
that has recovered from an signal failure (SF) or signal
degradation (SD) condition can be used again to transport
the normal traffic signal. During this time period, an SF or
SD condition shall override the wait-to-restore time period.
This leaf can only take effect when the revertive leaf
equals true
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """wait_to_restore_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)""",
        })

    self.__wait_to_restore_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_wait_to_restore_time(self):
    self.__wait_to_restore_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="wait-to-restore-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)


  def _get_hold_off_time(self):
    """
    Getter method for hold_off_time, mapped from YANG variable /aps/aps_modules/aps_module/config/hold_off_time (uint32)

    YANG Description: The time delay between the declaration of an SF or SD
condition and the initiation of the protection switching
algorithm
    """
    return self.__hold_off_time
      
  def _set_hold_off_time(self, v, load=False):
    """
    Setter method for hold_off_time, mapped from YANG variable /aps/aps_modules/aps_module/config/hold_off_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hold_off_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hold_off_time() directly.

    YANG Description: The time delay between the declaration of an SF or SD
condition and the initiation of the protection switching
algorithm
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hold_off_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)""",
        })

    self.__hold_off_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hold_off_time(self):
    self.__hold_off_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="hold-off-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='uint32', is_config=True)


  def _get_primary_switch_threshold(self):
    """
    Getter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_threshold (decimal64)

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
primary switch threshold will be overridden
    """
    return self.__primary_switch_threshold
      
  def _set_primary_switch_threshold(self, v, load=False):
    """
    Setter method for primary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_threshold() directly.

    YANG Description: The threshold at which the primary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
primary switch threshold will be overridden
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__primary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_threshold(self):
    self.__primary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="primary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_primary_switch_hysteresis(self):
    """
    Getter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_hysteresis (decimal64)

    YANG Description: The delta in dB between the primary-switch-threshold
and the signal received on the primary APS_PATH before
initiating a switch from the secondary APS_PATH to the
primary APS_PATH, in order to prevent toggling between ports
when an input signal is very close to the threshold. A zero
value means the switch hysteresis is disabled.
    """
    return self.__primary_switch_hysteresis
      
  def _set_primary_switch_hysteresis(self, v, load=False):
    """
    Setter method for primary_switch_hysteresis, mapped from YANG variable /aps/aps_modules/aps_module/config/primary_switch_hysteresis (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_switch_hysteresis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_switch_hysteresis() directly.

    YANG Description: The delta in dB between the primary-switch-threshold
and the signal received on the primary APS_PATH before
initiating a switch from the secondary APS_PATH to the
primary APS_PATH, in order to prevent toggling between ports
when an input signal is very close to the threshold. A zero
value means the switch hysteresis is disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """primary_switch_hysteresis must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__primary_switch_hysteresis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_primary_switch_hysteresis(self):
    self.__primary_switch_hysteresis = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="primary-switch-hysteresis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_secondary_switch_threshold(self):
    """
    Getter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_threshold (decimal64)

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
secondary switch threshold will be overridden
    """
    return self.__secondary_switch_threshold
      
  def _set_secondary_switch_threshold(self, v, load=False):
    """
    Setter method for secondary_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/secondary_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_switch_threshold() directly.

    YANG Description: The threshold at which the secondary line port will switch to
the opposite line port in increments of 0.01 dBm. If the
hardware supports only one switch threshold for primary and
and secondary ports then it is recommended to set both
primary-switch-threshold and secondary-switch-threshold to
the same value to be explicit. When the relative switch
threshold is enabled, i.e. set to a non-zero value, the
secondary switch threshold will be overridden
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """secondary_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__secondary_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_secondary_switch_threshold(self):
    self.__secondary_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), is_leaf=True, yang_name="secondary-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_relative_switch_threshold(self):
    """
    Getter method for relative_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold (decimal64)

    YANG Description: The delta threshold in dB at which the current line port
will switch to the opposite line port. It can be set to
the value of 0dB. When set to 0dB, the threshold is ignored
and the system automatically applies the primary and
secondary switch thresholds. When set to a non-zero value,
it overrides the primary and secondary switch thresholds
    """
    return self.__relative_switch_threshold
      
  def _set_relative_switch_threshold(self, v, load=False):
    """
    Setter method for relative_switch_threshold, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relative_switch_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relative_switch_threshold() directly.

    YANG Description: The delta threshold in dB at which the current line port
will switch to the opposite line port. It can be set to
the value of 0dB. When set to 0dB, the threshold is ignored
and the system automatically applies the primary and
secondary switch thresholds. When set to a non-zero value,
it overrides the primary and secondary switch thresholds
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relative_switch_threshold must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__relative_switch_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relative_switch_threshold(self):
    self.__relative_switch_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_relative_switch_threshold_offset(self):
    """
    Getter method for relative_switch_threshold_offset, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold_offset (decimal64)

    YANG Description: The offset of the relative switch threshold that compensates
the normal difference of receiving power between the primary
and secondary line ports. A negative offset corresponds to
the situation where the secondary line port receives a higher
power than the primary line port in normal condition， and a
positive offset means the opposite. The offset will only work
when the relative switch threshold is set to a non-zero
value
    """
    return self.__relative_switch_threshold_offset
      
  def _set_relative_switch_threshold_offset(self, v, load=False):
    """
    Setter method for relative_switch_threshold_offset, mapped from YANG variable /aps/aps_modules/aps_module/config/relative_switch_threshold_offset (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relative_switch_threshold_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relative_switch_threshold_offset() directly.

    YANG Description: The offset of the relative switch threshold that compensates
the normal difference of receiving power between the primary
and secondary line ports. A negative offset corresponds to
the situation where the secondary line port receives a higher
power than the primary line port in normal condition， and a
positive offset means the opposite. The offset will only work
when the relative switch threshold is set to a non-zero
value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relative_switch_threshold_offset must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)""",
        })

    self.__relative_switch_threshold_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relative_switch_threshold_offset(self):
    self.__relative_switch_threshold_offset = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=2), default=Decimal(0), is_leaf=True, yang_name="relative-switch-threshold-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='decimal64', is_config=True)


  def _get_force_to_port(self):
    """
    Getter method for force_to_port, mapped from YANG variable /aps/aps_modules/aps_module/config/force_to_port (enumeration)

    YANG Description: Explicitly set the switch to stay on a port regardless of
its operational condition
    """
    return self.__force_to_port
      
  def _set_force_to_port(self, v, load=False):
    """
    Setter method for force_to_port, mapped from YANG variable /aps/aps_modules/aps_module/config/force_to_port (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_force_to_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_force_to_port() directly.

    YANG Description: Explicitly set the switch to stay on a port regardless of
its operational condition
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=str("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """force_to_port must be of a type compatible with enumeration""",
          'defined-type': "openconfig-transport-line-protection:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=str("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)""",
        })

    self.__force_to_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_force_to_port(self):
    self.__force_to_port = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'NONE': {}, 'PRIMARY': {}, 'SECONDARY': {}},), default=str("NONE"), is_leaf=True, yang_name="force-to-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/optical-transport-line-protection', defining_module='openconfig-transport-line-protection', yang_type='enumeration', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  revertive = __builtin__.property(_get_revertive, _set_revertive)
  wait_to_restore_time = __builtin__.property(_get_wait_to_restore_time, _set_wait_to_restore_time)
  hold_off_time = __builtin__.property(_get_hold_off_time, _set_hold_off_time)
  primary_switch_threshold = __builtin__.property(_get_primary_switch_threshold, _set_primary_switch_threshold)
  primary_switch_hysteresis = __builtin__.property(_get_primary_switch_hysteresis, _set_primary_switch_hysteresis)
  secondary_switch_threshold = __builtin__.property(_get_secondary_switch_threshold, _set_secondary_switch_threshold)
  relative_switch_threshold = __builtin__.property(_get_relative_switch_threshold, _set_relative_switch_threshold)
  relative_switch_threshold_offset = __builtin__.property(_get_relative_switch_threshold_offset, _set_relative_switch_threshold_offset)
  force_to_port = __builtin__.property(_get_force_to_port, _set_force_to_port)


  _pyangbind_elements = OrderedDict([('name', name), ('revertive', revertive), ('wait_to_restore_time', wait_to_restore_time), ('hold_off_time', hold_off_time), ('primary_switch_threshold', primary_switch_threshold), ('primary_switch_hysteresis', primary_switch_hysteresis), ('secondary_switch_threshold', secondary_switch_threshold), ('relative_switch_threshold', relative_switch_threshold), ('relative_switch_threshold_offset', relative_switch_threshold_offset), ('force_to_port', force_to_port), ])


