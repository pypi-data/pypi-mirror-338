# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/time-properties-ds/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data of time properties data set.
  """
  __slots__ = ('_path_helper', '_extmethods', '__current_utc_offset','__current_utc_offset_valid','__leap59','__leap61','__time_traceable','__frequency_traceable','__ptp_timescale','__time_source',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__current_utc_offset = YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)
    self.__current_utc_offset_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__leap59 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__leap61 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__time_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__frequency_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__ptp_timescale = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__time_source = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'time-properties-ds', 'config']

  def _get_current_utc_offset(self):
    """
    Getter method for current_utc_offset, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset (int16)

    YANG Description: Specified as <dLS> in IERS Bulletin C, this provides
the offset from UTC (TAI - UTC). The offset is in
units of seconds.
    """
    return self.__current_utc_offset
      
  def _set_current_utc_offset(self, v, load=False):
    """
    Setter method for current_utc_offset, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset (int16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_utc_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_utc_offset() directly.

    YANG Description: Specified as <dLS> in IERS Bulletin C, this provides
the offset from UTC (TAI - UTC). The offset is in
units of seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_utc_offset must be of a type compatible with int16""",
          'defined-type': "int16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)""",
        })

    self.__current_utc_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_utc_offset(self):
    self.__current_utc_offset = YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)


  def _get_current_utc_offset_valid(self):
    """
    Getter method for current_utc_offset_valid, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset_valid (boolean)

    YANG Description: The value of current-utc-offset-valid shall be true
if the values of current-utc-offset, leap59, and leap61
are known to be correct, otherwise it shall be false.
NOTE - The constraint for leap59 and leap61 did not
exist in IEEE Std 1588-2008, and for compatibility,
corresponding when statements were not included below.
    """
    return self.__current_utc_offset_valid
      
  def _set_current_utc_offset_valid(self, v, load=False):
    """
    Setter method for current_utc_offset_valid, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset_valid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_utc_offset_valid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_utc_offset_valid() directly.

    YANG Description: The value of current-utc-offset-valid shall be true
if the values of current-utc-offset, leap59, and leap61
are known to be correct, otherwise it shall be false.
NOTE - The constraint for leap59 and leap61 did not
exist in IEEE Std 1588-2008, and for compatibility,
corresponding when statements were not included below.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_utc_offset_valid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__current_utc_offset_valid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_utc_offset_valid(self):
    self.__current_utc_offset_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_leap59(self):
    """
    Getter method for leap59, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap59 (boolean)

    YANG Description: If the timescale is PTP, a true value for leap59
shall indicate that the last minute of the
current UTC day contains 59 seconds.
If the timescale is not PTP, the value shall be
false.
    """
    return self.__leap59
      
  def _set_leap59(self, v, load=False):
    """
    Setter method for leap59, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap59 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leap59 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leap59() directly.

    YANG Description: If the timescale is PTP, a true value for leap59
shall indicate that the last minute of the
current UTC day contains 59 seconds.
If the timescale is not PTP, the value shall be
false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leap59 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__leap59 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leap59(self):
    self.__leap59 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_leap61(self):
    """
    Getter method for leap61, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap61 (boolean)

    YANG Description: If the timescale is PTP, a true value for leap61 shall indicate
that the last minute of the current UTC day contains 61 seconds.
If the timescale is not PTP, the value shall be false.
    """
    return self.__leap61
      
  def _set_leap61(self, v, load=False):
    """
    Setter method for leap61, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap61 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leap61 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leap61() directly.

    YANG Description: If the timescale is PTP, a true value for leap61 shall indicate
that the last minute of the current UTC day contains 61 seconds.
If the timescale is not PTP, the value shall be false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leap61 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__leap61 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leap61(self):
    self.__leap61 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_time_traceable(self):
    """
    Getter method for time_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_traceable (boolean)

    YANG Description: The value of time-traceable shall be true if the timescale is
traceable to a primary reference; otherwise, the value shall be
false. The uncertainty specifications appropriate to the
evaluation of whether traceability to a primary reference is
achieved should be defined in the applicable PTP Profile. In
the absence of such a definition the value of time-traceable is
implementation specific.
    """
    return self.__time_traceable
      
  def _set_time_traceable(self, v, load=False):
    """
    Setter method for time_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_traceable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_traceable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_traceable() directly.

    YANG Description: The value of time-traceable shall be true if the timescale is
traceable to a primary reference; otherwise, the value shall be
false. The uncertainty specifications appropriate to the
evaluation of whether traceability to a primary reference is
achieved should be defined in the applicable PTP Profile. In
the absence of such a definition the value of time-traceable is
implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_traceable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__time_traceable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_traceable(self):
    self.__time_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_frequency_traceable(self):
    """
    Getter method for frequency_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/frequency_traceable (boolean)

    YANG Description: The value of time-traceable shall be true if the frequency
determining the timescale is traceable to a primary reference;
otherwise, the value shall be false.
The uncertainty specifications appropriate to the evaluation
of whether traceability to a primary reference is achieved
should be defined in the applicable PTP Profile. In the absence
of such a definition the value of frequency-traceable is
implementation specific.
    """
    return self.__frequency_traceable
      
  def _set_frequency_traceable(self, v, load=False):
    """
    Setter method for frequency_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/frequency_traceable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency_traceable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency_traceable() directly.

    YANG Description: The value of time-traceable shall be true if the frequency
determining the timescale is traceable to a primary reference;
otherwise, the value shall be false.
The uncertainty specifications appropriate to the evaluation
of whether traceability to a primary reference is achieved
should be defined in the applicable PTP Profile. In the absence
of such a definition the value of frequency-traceable is
implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency_traceable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__frequency_traceable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency_traceable(self):
    self.__frequency_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_ptp_timescale(self):
    """
    Getter method for ptp_timescale, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/ptp_timescale (boolean)

    YANG Description: If ptp-timescale is true, the timescale of the Grandmaster PTP
Instance is PTP, which is the elapsed time since the PTP epoch
measured using the second defined by International Atomic Time (TAI).
If ptp-timescale is false, the timescale of the Grandmaster PTP
Instance is ARB, which is the elapsed time since an arbitrary epoch.
    """
    return self.__ptp_timescale
      
  def _set_ptp_timescale(self, v, load=False):
    """
    Setter method for ptp_timescale, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/ptp_timescale (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptp_timescale is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptp_timescale() directly.

    YANG Description: If ptp-timescale is true, the timescale of the Grandmaster PTP
Instance is PTP, which is the elapsed time since the PTP epoch
measured using the second defined by International Atomic Time (TAI).
If ptp-timescale is false, the timescale of the Grandmaster PTP
Instance is ARB, which is the elapsed time since an arbitrary epoch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptp_timescale must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__ptp_timescale = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptp_timescale(self):
    self.__ptp_timescale = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_time_source(self):
    """
    Getter method for time_source, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_source (identityref)

    YANG Description: The source of time used by the Grandmaster
PTP Instance.
    """
    return self.__time_source
      
  def _set_time_source(self, v, load=False):
    """
    Setter method for time_source, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_source (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_source() directly.

    YANG Description: The source of time used by the Grandmaster
PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_source must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)""",
        })

    self.__time_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_source(self):
    self.__time_source = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)

  current_utc_offset = __builtin__.property(_get_current_utc_offset, _set_current_utc_offset)
  current_utc_offset_valid = __builtin__.property(_get_current_utc_offset_valid, _set_current_utc_offset_valid)
  leap59 = __builtin__.property(_get_leap59, _set_leap59)
  leap61 = __builtin__.property(_get_leap61, _set_leap61)
  time_traceable = __builtin__.property(_get_time_traceable, _set_time_traceable)
  frequency_traceable = __builtin__.property(_get_frequency_traceable, _set_frequency_traceable)
  ptp_timescale = __builtin__.property(_get_ptp_timescale, _set_ptp_timescale)
  time_source = __builtin__.property(_get_time_source, _set_time_source)


  _pyangbind_elements = OrderedDict([('current_utc_offset', current_utc_offset), ('current_utc_offset_valid', current_utc_offset_valid), ('leap59', leap59), ('leap61', leap61), ('time_traceable', time_traceable), ('frequency_traceable', frequency_traceable), ('ptp_timescale', ptp_timescale), ('time_source', time_source), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ptp - based on the path /ptp/instances/instance/time-properties-ds/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data of time properties data set.
  """
  __slots__ = ('_path_helper', '_extmethods', '__current_utc_offset','__current_utc_offset_valid','__leap59','__leap61','__time_traceable','__frequency_traceable','__ptp_timescale','__time_source',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ptp'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__current_utc_offset = YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)
    self.__current_utc_offset_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__leap59 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__leap61 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__time_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__frequency_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__ptp_timescale = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    self.__time_source = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ptp', 'instances', 'instance', 'time-properties-ds', 'config']

  def _get_current_utc_offset(self):
    """
    Getter method for current_utc_offset, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset (int16)

    YANG Description: Specified as <dLS> in IERS Bulletin C, this provides
the offset from UTC (TAI - UTC). The offset is in
units of seconds.
    """
    return self.__current_utc_offset
      
  def _set_current_utc_offset(self, v, load=False):
    """
    Setter method for current_utc_offset, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset (int16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_utc_offset is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_utc_offset() directly.

    YANG Description: Specified as <dLS> in IERS Bulletin C, this provides
the offset from UTC (TAI - UTC). The offset is in
units of seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_utc_offset must be of a type compatible with int16""",
          'defined-type': "int16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)""",
        })

    self.__current_utc_offset = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_utc_offset(self):
    self.__current_utc_offset = YANGDynClass(base=RestrictedClassType(base_type=int,restriction_dict={'range': ['-32768..32767']}, int_size=16), is_leaf=True, yang_name="current-utc-offset", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='int16', is_config=True)


  def _get_current_utc_offset_valid(self):
    """
    Getter method for current_utc_offset_valid, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset_valid (boolean)

    YANG Description: The value of current-utc-offset-valid shall be true
if the values of current-utc-offset, leap59, and leap61
are known to be correct, otherwise it shall be false.
NOTE - The constraint for leap59 and leap61 did not
exist in IEEE Std 1588-2008, and for compatibility,
corresponding when statements were not included below.
    """
    return self.__current_utc_offset_valid
      
  def _set_current_utc_offset_valid(self, v, load=False):
    """
    Setter method for current_utc_offset_valid, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/current_utc_offset_valid (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_current_utc_offset_valid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_current_utc_offset_valid() directly.

    YANG Description: The value of current-utc-offset-valid shall be true
if the values of current-utc-offset, leap59, and leap61
are known to be correct, otherwise it shall be false.
NOTE - The constraint for leap59 and leap61 did not
exist in IEEE Std 1588-2008, and for compatibility,
corresponding when statements were not included below.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """current_utc_offset_valid must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__current_utc_offset_valid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_current_utc_offset_valid(self):
    self.__current_utc_offset_valid = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="current-utc-offset-valid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_leap59(self):
    """
    Getter method for leap59, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap59 (boolean)

    YANG Description: If the timescale is PTP, a true value for leap59
shall indicate that the last minute of the
current UTC day contains 59 seconds.
If the timescale is not PTP, the value shall be
false.
    """
    return self.__leap59
      
  def _set_leap59(self, v, load=False):
    """
    Setter method for leap59, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap59 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leap59 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leap59() directly.

    YANG Description: If the timescale is PTP, a true value for leap59
shall indicate that the last minute of the
current UTC day contains 59 seconds.
If the timescale is not PTP, the value shall be
false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leap59 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__leap59 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leap59(self):
    self.__leap59 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap59", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_leap61(self):
    """
    Getter method for leap61, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap61 (boolean)

    YANG Description: If the timescale is PTP, a true value for leap61 shall indicate
that the last minute of the current UTC day contains 61 seconds.
If the timescale is not PTP, the value shall be false.
    """
    return self.__leap61
      
  def _set_leap61(self, v, load=False):
    """
    Setter method for leap61, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/leap61 (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leap61 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leap61() directly.

    YANG Description: If the timescale is PTP, a true value for leap61 shall indicate
that the last minute of the current UTC day contains 61 seconds.
If the timescale is not PTP, the value shall be false.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """leap61 must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__leap61 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_leap61(self):
    self.__leap61 = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="leap61", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_time_traceable(self):
    """
    Getter method for time_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_traceable (boolean)

    YANG Description: The value of time-traceable shall be true if the timescale is
traceable to a primary reference; otherwise, the value shall be
false. The uncertainty specifications appropriate to the
evaluation of whether traceability to a primary reference is
achieved should be defined in the applicable PTP Profile. In
the absence of such a definition the value of time-traceable is
implementation specific.
    """
    return self.__time_traceable
      
  def _set_time_traceable(self, v, load=False):
    """
    Setter method for time_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_traceable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_traceable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_traceable() directly.

    YANG Description: The value of time-traceable shall be true if the timescale is
traceable to a primary reference; otherwise, the value shall be
false. The uncertainty specifications appropriate to the
evaluation of whether traceability to a primary reference is
achieved should be defined in the applicable PTP Profile. In
the absence of such a definition the value of time-traceable is
implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_traceable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__time_traceable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_traceable(self):
    self.__time_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="time-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_frequency_traceable(self):
    """
    Getter method for frequency_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/frequency_traceable (boolean)

    YANG Description: The value of time-traceable shall be true if the frequency
determining the timescale is traceable to a primary reference;
otherwise, the value shall be false.
The uncertainty specifications appropriate to the evaluation
of whether traceability to a primary reference is achieved
should be defined in the applicable PTP Profile. In the absence
of such a definition the value of frequency-traceable is
implementation specific.
    """
    return self.__frequency_traceable
      
  def _set_frequency_traceable(self, v, load=False):
    """
    Setter method for frequency_traceable, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/frequency_traceable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_frequency_traceable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_frequency_traceable() directly.

    YANG Description: The value of time-traceable shall be true if the frequency
determining the timescale is traceable to a primary reference;
otherwise, the value shall be false.
The uncertainty specifications appropriate to the evaluation
of whether traceability to a primary reference is achieved
should be defined in the applicable PTP Profile. In the absence
of such a definition the value of frequency-traceable is
implementation specific.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """frequency_traceable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__frequency_traceable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_frequency_traceable(self):
    self.__frequency_traceable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="frequency-traceable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_ptp_timescale(self):
    """
    Getter method for ptp_timescale, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/ptp_timescale (boolean)

    YANG Description: If ptp-timescale is true, the timescale of the Grandmaster PTP
Instance is PTP, which is the elapsed time since the PTP epoch
measured using the second defined by International Atomic Time (TAI).
If ptp-timescale is false, the timescale of the Grandmaster PTP
Instance is ARB, which is the elapsed time since an arbitrary epoch.
    """
    return self.__ptp_timescale
      
  def _set_ptp_timescale(self, v, load=False):
    """
    Setter method for ptp_timescale, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/ptp_timescale (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ptp_timescale is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ptp_timescale() directly.

    YANG Description: If ptp-timescale is true, the timescale of the Grandmaster PTP
Instance is PTP, which is the elapsed time since the PTP epoch
measured using the second defined by International Atomic Time (TAI).
If ptp-timescale is false, the timescale of the Grandmaster PTP
Instance is ARB, which is the elapsed time since an arbitrary epoch.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ptp_timescale must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)""",
        })

    self.__ptp_timescale = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ptp_timescale(self):
    self.__ptp_timescale = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ptp-timescale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='boolean', is_config=True)


  def _get_time_source(self):
    """
    Getter method for time_source, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_source (identityref)

    YANG Description: The source of time used by the Grandmaster
PTP Instance.
    """
    return self.__time_source
      
  def _set_time_source(self, v, load=False):
    """
    Setter method for time_source, mapped from YANG variable /ptp/instances/instance/time_properties_ds/config/time_source (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_time_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_time_source() directly.

    YANG Description: The source of time used by the Grandmaster
PTP Instance.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """time_source must be of a type compatible with identityref""",
          'defined-type': "openconfig-ptp:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)""",
        })

    self.__time_source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_time_source(self):
    self.__time_source = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={},), is_leaf=True, yang_name="time-source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ptp', defining_module='openconfig-ptp', yang_type='identityref', is_config=True)

  current_utc_offset = __builtin__.property(_get_current_utc_offset, _set_current_utc_offset)
  current_utc_offset_valid = __builtin__.property(_get_current_utc_offset_valid, _set_current_utc_offset_valid)
  leap59 = __builtin__.property(_get_leap59, _set_leap59)
  leap61 = __builtin__.property(_get_leap61, _set_leap61)
  time_traceable = __builtin__.property(_get_time_traceable, _set_time_traceable)
  frequency_traceable = __builtin__.property(_get_frequency_traceable, _set_frequency_traceable)
  ptp_timescale = __builtin__.property(_get_ptp_timescale, _set_ptp_timescale)
  time_source = __builtin__.property(_get_time_source, _set_time_source)


  _pyangbind_elements = OrderedDict([('current_utc_offset', current_utc_offset), ('current_utc_offset_valid', current_utc_offset_valid), ('leap59', leap59), ('leap61', leap61), ('time_traceable', time_traceable), ('frequency_traceable', frequency_traceable), ('ptp_timescale', ptp_timescale), ('time_source', time_source), ])


