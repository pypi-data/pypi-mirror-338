# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/storage/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of storage specific statistics entitites.
  """
  __slots__ = ('_path_helper', '_extmethods', '__soft_read_error_rate','__reallocated_sectors','__end_to_end_error','__offline_uncorrectable_sectors_count','__life_left','__percentage_used',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__soft_read_error_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__reallocated_sectors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__end_to_end_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__offline_uncorrectable_sectors_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__life_left = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    self.__percentage_used = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'storage', 'state', 'counters']

  def _get_soft_read_error_rate(self):
    """
    Getter method for soft_read_error_rate, mapped from YANG variable /components/component/storage/state/counters/soft_read_error_rate (oc-yang:counter64)

    YANG Description: Uncorrected read errors reported to the operating system. SMART ID
201.
    """
    return self.__soft_read_error_rate
      
  def _set_soft_read_error_rate(self, v, load=False):
    """
    Setter method for soft_read_error_rate, mapped from YANG variable /components/component/storage/state/counters/soft_read_error_rate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_read_error_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_read_error_rate() directly.

    YANG Description: Uncorrected read errors reported to the operating system. SMART ID
201.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_read_error_rate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__soft_read_error_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_read_error_rate(self):
    self.__soft_read_error_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_reallocated_sectors(self):
    """
    Getter method for reallocated_sectors, mapped from YANG variable /components/component/storage/state/counters/reallocated_sectors (oc-yang:counter64)

    YANG Description: Count of reallocated sectors. The raw value represents a count of
the bad sectors that have been found and remapped. SMART ID 5.
    """
    return self.__reallocated_sectors
      
  def _set_reallocated_sectors(self, v, load=False):
    """
    Setter method for reallocated_sectors, mapped from YANG variable /components/component/storage/state/counters/reallocated_sectors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reallocated_sectors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reallocated_sectors() directly.

    YANG Description: Count of reallocated sectors. The raw value represents a count of
the bad sectors that have been found and remapped. SMART ID 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reallocated_sectors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__reallocated_sectors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reallocated_sectors(self):
    self.__reallocated_sectors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_end_to_end_error(self):
    """
    Getter method for end_to_end_error, mapped from YANG variable /components/component/storage/state/counters/end_to_end_error (oc-yang:counter64)

    YANG Description: Count of parity errors which occur in the data path to the media.
SMART ID 184.
    """
    return self.__end_to_end_error
      
  def _set_end_to_end_error(self, v, load=False):
    """
    Setter method for end_to_end_error, mapped from YANG variable /components/component/storage/state/counters/end_to_end_error (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_to_end_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_to_end_error() directly.

    YANG Description: Count of parity errors which occur in the data path to the media.
SMART ID 184.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_to_end_error must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__end_to_end_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_to_end_error(self):
    self.__end_to_end_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_offline_uncorrectable_sectors_count(self):
    """
    Getter method for offline_uncorrectable_sectors_count, mapped from YANG variable /components/component/storage/state/counters/offline_uncorrectable_sectors_count (oc-yang:counter64)

    YANG Description: The total count of uncorrectable errors when reading/writing a
sector. SMART ID 198.
    """
    return self.__offline_uncorrectable_sectors_count
      
  def _set_offline_uncorrectable_sectors_count(self, v, load=False):
    """
    Setter method for offline_uncorrectable_sectors_count, mapped from YANG variable /components/component/storage/state/counters/offline_uncorrectable_sectors_count (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offline_uncorrectable_sectors_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offline_uncorrectable_sectors_count() directly.

    YANG Description: The total count of uncorrectable errors when reading/writing a
sector. SMART ID 198.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offline_uncorrectable_sectors_count must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__offline_uncorrectable_sectors_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offline_uncorrectable_sectors_count(self):
    self.__offline_uncorrectable_sectors_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_life_left(self):
    """
    Getter method for life_left, mapped from YANG variable /components/component/storage/state/counters/life_left (uint8)

    YANG Description: Indicates the approximate SSD life left, in terms of program/erase
cycles or available reserved blocks. A normalized value of 100
represents a new drive, with a threshold value at 10 indicating a need
for replacement. A value of 0 may mean that the drive is operating in
read-only mode to allow data recovery. SMART ID 231.
    """
    return self.__life_left
      
  def _set_life_left(self, v, load=False):
    """
    Setter method for life_left, mapped from YANG variable /components/component/storage/state/counters/life_left (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_life_left is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_life_left() directly.

    YANG Description: Indicates the approximate SSD life left, in terms of program/erase
cycles or available reserved blocks. A normalized value of 100
represents a new drive, with a threshold value at 10 indicating a need
for replacement. A value of 0 may mean that the drive is operating in
read-only mode to allow data recovery. SMART ID 231.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """life_left must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)""",
        })

    self.__life_left = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_life_left(self):
    self.__life_left = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)


  def _get_percentage_used(self):
    """
    Getter method for percentage_used, mapped from YANG variable /components/component/storage/state/counters/percentage_used (uint8)

    YANG Description: Contains a vendor specific estimate of the percentage of NVM
subsystem life used based on the actual usage and the manufacturer’s
prediction of NVM life. A value of 100 indicates that the estimated
endurance of the NVM in the NVM subsystem has been consumed, but may
not indicate an NVM subsystem failure. The value is allowed to exceed
100. Percentages greater than 254 shall be represented as 255.
    """
    return self.__percentage_used
      
  def _set_percentage_used(self, v, load=False):
    """
    Setter method for percentage_used, mapped from YANG variable /components/component/storage/state/counters/percentage_used (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_percentage_used is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_percentage_used() directly.

    YANG Description: Contains a vendor specific estimate of the percentage of NVM
subsystem life used based on the actual usage and the manufacturer’s
prediction of NVM life. A value of 100 indicates that the estimated
endurance of the NVM in the NVM subsystem has been consumed, but may
not indicate an NVM subsystem failure. The value is allowed to exceed
100. Percentages greater than 254 shall be represented as 255.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """percentage_used must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)""",
        })

    self.__percentage_used = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_percentage_used(self):
    self.__percentage_used = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)

  soft_read_error_rate = __builtin__.property(_get_soft_read_error_rate)
  reallocated_sectors = __builtin__.property(_get_reallocated_sectors)
  end_to_end_error = __builtin__.property(_get_end_to_end_error)
  offline_uncorrectable_sectors_count = __builtin__.property(_get_offline_uncorrectable_sectors_count)
  life_left = __builtin__.property(_get_life_left)
  percentage_used = __builtin__.property(_get_percentage_used)


  _pyangbind_elements = OrderedDict([('soft_read_error_rate', soft_read_error_rate), ('reallocated_sectors', reallocated_sectors), ('end_to_end_error', end_to_end_error), ('offline_uncorrectable_sectors_count', offline_uncorrectable_sectors_count), ('life_left', life_left), ('percentage_used', percentage_used), ])


class counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /components/component/storage/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of storage specific statistics entitites.
  """
  __slots__ = ('_path_helper', '_extmethods', '__soft_read_error_rate','__reallocated_sectors','__end_to_end_error','__offline_uncorrectable_sectors_count','__life_left','__percentage_used',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__soft_read_error_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__reallocated_sectors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__end_to_end_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__offline_uncorrectable_sectors_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__life_left = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    self.__percentage_used = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'storage', 'state', 'counters']

  def _get_soft_read_error_rate(self):
    """
    Getter method for soft_read_error_rate, mapped from YANG variable /components/component/storage/state/counters/soft_read_error_rate (oc-yang:counter64)

    YANG Description: Uncorrected read errors reported to the operating system. SMART ID
201.
    """
    return self.__soft_read_error_rate
      
  def _set_soft_read_error_rate(self, v, load=False):
    """
    Setter method for soft_read_error_rate, mapped from YANG variable /components/component/storage/state/counters/soft_read_error_rate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_read_error_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_read_error_rate() directly.

    YANG Description: Uncorrected read errors reported to the operating system. SMART ID
201.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_read_error_rate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__soft_read_error_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_read_error_rate(self):
    self.__soft_read_error_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_reallocated_sectors(self):
    """
    Getter method for reallocated_sectors, mapped from YANG variable /components/component/storage/state/counters/reallocated_sectors (oc-yang:counter64)

    YANG Description: Count of reallocated sectors. The raw value represents a count of
the bad sectors that have been found and remapped. SMART ID 5.
    """
    return self.__reallocated_sectors
      
  def _set_reallocated_sectors(self, v, load=False):
    """
    Setter method for reallocated_sectors, mapped from YANG variable /components/component/storage/state/counters/reallocated_sectors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reallocated_sectors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reallocated_sectors() directly.

    YANG Description: Count of reallocated sectors. The raw value represents a count of
the bad sectors that have been found and remapped. SMART ID 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reallocated_sectors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__reallocated_sectors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reallocated_sectors(self):
    self.__reallocated_sectors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_end_to_end_error(self):
    """
    Getter method for end_to_end_error, mapped from YANG variable /components/component/storage/state/counters/end_to_end_error (oc-yang:counter64)

    YANG Description: Count of parity errors which occur in the data path to the media.
SMART ID 184.
    """
    return self.__end_to_end_error
      
  def _set_end_to_end_error(self, v, load=False):
    """
    Setter method for end_to_end_error, mapped from YANG variable /components/component/storage/state/counters/end_to_end_error (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_to_end_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_to_end_error() directly.

    YANG Description: Count of parity errors which occur in the data path to the media.
SMART ID 184.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_to_end_error must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__end_to_end_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_to_end_error(self):
    self.__end_to_end_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_offline_uncorrectable_sectors_count(self):
    """
    Getter method for offline_uncorrectable_sectors_count, mapped from YANG variable /components/component/storage/state/counters/offline_uncorrectable_sectors_count (oc-yang:counter64)

    YANG Description: The total count of uncorrectable errors when reading/writing a
sector. SMART ID 198.
    """
    return self.__offline_uncorrectable_sectors_count
      
  def _set_offline_uncorrectable_sectors_count(self, v, load=False):
    """
    Setter method for offline_uncorrectable_sectors_count, mapped from YANG variable /components/component/storage/state/counters/offline_uncorrectable_sectors_count (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offline_uncorrectable_sectors_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offline_uncorrectable_sectors_count() directly.

    YANG Description: The total count of uncorrectable errors when reading/writing a
sector. SMART ID 198.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offline_uncorrectable_sectors_count must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__offline_uncorrectable_sectors_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offline_uncorrectable_sectors_count(self):
    self.__offline_uncorrectable_sectors_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_life_left(self):
    """
    Getter method for life_left, mapped from YANG variable /components/component/storage/state/counters/life_left (uint8)

    YANG Description: Indicates the approximate SSD life left, in terms of program/erase
cycles or available reserved blocks. A normalized value of 100
represents a new drive, with a threshold value at 10 indicating a need
for replacement. A value of 0 may mean that the drive is operating in
read-only mode to allow data recovery. SMART ID 231.
    """
    return self.__life_left
      
  def _set_life_left(self, v, load=False):
    """
    Setter method for life_left, mapped from YANG variable /components/component/storage/state/counters/life_left (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_life_left is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_life_left() directly.

    YANG Description: Indicates the approximate SSD life left, in terms of program/erase
cycles or available reserved blocks. A normalized value of 100
represents a new drive, with a threshold value at 10 indicating a need
for replacement. A value of 0 may mean that the drive is operating in
read-only mode to allow data recovery. SMART ID 231.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """life_left must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)""",
        })

    self.__life_left = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_life_left(self):
    self.__life_left = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)


  def _get_percentage_used(self):
    """
    Getter method for percentage_used, mapped from YANG variable /components/component/storage/state/counters/percentage_used (uint8)

    YANG Description: Contains a vendor specific estimate of the percentage of NVM
subsystem life used based on the actual usage and the manufacturer’s
prediction of NVM life. A value of 100 indicates that the estimated
endurance of the NVM in the NVM subsystem has been consumed, but may
not indicate an NVM subsystem failure. The value is allowed to exceed
100. Percentages greater than 254 shall be represented as 255.
    """
    return self.__percentage_used
      
  def _set_percentage_used(self, v, load=False):
    """
    Setter method for percentage_used, mapped from YANG variable /components/component/storage/state/counters/percentage_used (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_percentage_used is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_percentage_used() directly.

    YANG Description: Contains a vendor specific estimate of the percentage of NVM
subsystem life used based on the actual usage and the manufacturer’s
prediction of NVM life. A value of 100 indicates that the estimated
endurance of the NVM in the NVM subsystem has been consumed, but may
not indicate an NVM subsystem failure. The value is allowed to exceed
100. Percentages greater than 254 shall be represented as 255.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """percentage_used must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)""",
        })

    self.__percentage_used = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_percentage_used(self):
    self.__percentage_used = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)

  soft_read_error_rate = __builtin__.property(_get_soft_read_error_rate)
  reallocated_sectors = __builtin__.property(_get_reallocated_sectors)
  end_to_end_error = __builtin__.property(_get_end_to_end_error)
  offline_uncorrectable_sectors_count = __builtin__.property(_get_offline_uncorrectable_sectors_count)
  life_left = __builtin__.property(_get_life_left)
  percentage_used = __builtin__.property(_get_percentage_used)


  _pyangbind_elements = OrderedDict([('soft_read_error_rate', soft_read_error_rate), ('reallocated_sectors', reallocated_sectors), ('end_to_end_error', end_to_end_error), ('offline_uncorrectable_sectors_count', offline_uncorrectable_sectors_count), ('life_left', life_left), ('percentage_used', percentage_used), ])


class counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/storage/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of storage specific statistics entitites.
  """
  __slots__ = ('_path_helper', '_extmethods', '__soft_read_error_rate','__reallocated_sectors','__end_to_end_error','__offline_uncorrectable_sectors_count','__life_left','__percentage_used',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__soft_read_error_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__reallocated_sectors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__end_to_end_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__offline_uncorrectable_sectors_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__life_left = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    self.__percentage_used = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'storage', 'state', 'counters']

  def _get_soft_read_error_rate(self):
    """
    Getter method for soft_read_error_rate, mapped from YANG variable /components/component/storage/state/counters/soft_read_error_rate (oc-yang:counter64)

    YANG Description: Uncorrected read errors reported to the operating system. SMART ID
201.
    """
    return self.__soft_read_error_rate
      
  def _set_soft_read_error_rate(self, v, load=False):
    """
    Setter method for soft_read_error_rate, mapped from YANG variable /components/component/storage/state/counters/soft_read_error_rate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_read_error_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_read_error_rate() directly.

    YANG Description: Uncorrected read errors reported to the operating system. SMART ID
201.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_read_error_rate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__soft_read_error_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_read_error_rate(self):
    self.__soft_read_error_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_reallocated_sectors(self):
    """
    Getter method for reallocated_sectors, mapped from YANG variable /components/component/storage/state/counters/reallocated_sectors (oc-yang:counter64)

    YANG Description: Count of reallocated sectors. The raw value represents a count of
the bad sectors that have been found and remapped. SMART ID 5.
    """
    return self.__reallocated_sectors
      
  def _set_reallocated_sectors(self, v, load=False):
    """
    Setter method for reallocated_sectors, mapped from YANG variable /components/component/storage/state/counters/reallocated_sectors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reallocated_sectors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reallocated_sectors() directly.

    YANG Description: Count of reallocated sectors. The raw value represents a count of
the bad sectors that have been found and remapped. SMART ID 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reallocated_sectors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__reallocated_sectors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reallocated_sectors(self):
    self.__reallocated_sectors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_end_to_end_error(self):
    """
    Getter method for end_to_end_error, mapped from YANG variable /components/component/storage/state/counters/end_to_end_error (oc-yang:counter64)

    YANG Description: Count of parity errors which occur in the data path to the media.
SMART ID 184.
    """
    return self.__end_to_end_error
      
  def _set_end_to_end_error(self, v, load=False):
    """
    Setter method for end_to_end_error, mapped from YANG variable /components/component/storage/state/counters/end_to_end_error (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_to_end_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_to_end_error() directly.

    YANG Description: Count of parity errors which occur in the data path to the media.
SMART ID 184.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_to_end_error must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__end_to_end_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_to_end_error(self):
    self.__end_to_end_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_offline_uncorrectable_sectors_count(self):
    """
    Getter method for offline_uncorrectable_sectors_count, mapped from YANG variable /components/component/storage/state/counters/offline_uncorrectable_sectors_count (oc-yang:counter64)

    YANG Description: The total count of uncorrectable errors when reading/writing a
sector. SMART ID 198.
    """
    return self.__offline_uncorrectable_sectors_count
      
  def _set_offline_uncorrectable_sectors_count(self, v, load=False):
    """
    Setter method for offline_uncorrectable_sectors_count, mapped from YANG variable /components/component/storage/state/counters/offline_uncorrectable_sectors_count (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offline_uncorrectable_sectors_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offline_uncorrectable_sectors_count() directly.

    YANG Description: The total count of uncorrectable errors when reading/writing a
sector. SMART ID 198.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offline_uncorrectable_sectors_count must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__offline_uncorrectable_sectors_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offline_uncorrectable_sectors_count(self):
    self.__offline_uncorrectable_sectors_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_life_left(self):
    """
    Getter method for life_left, mapped from YANG variable /components/component/storage/state/counters/life_left (uint8)

    YANG Description: Indicates the approximate SSD life left, in terms of program/erase
cycles or available reserved blocks. A normalized value of 100
represents a new drive, with a threshold value at 10 indicating a need
for replacement. A value of 0 may mean that the drive is operating in
read-only mode to allow data recovery. SMART ID 231.
    """
    return self.__life_left
      
  def _set_life_left(self, v, load=False):
    """
    Setter method for life_left, mapped from YANG variable /components/component/storage/state/counters/life_left (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_life_left is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_life_left() directly.

    YANG Description: Indicates the approximate SSD life left, in terms of program/erase
cycles or available reserved blocks. A normalized value of 100
represents a new drive, with a threshold value at 10 indicating a need
for replacement. A value of 0 may mean that the drive is operating in
read-only mode to allow data recovery. SMART ID 231.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """life_left must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)""",
        })

    self.__life_left = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_life_left(self):
    self.__life_left = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)


  def _get_percentage_used(self):
    """
    Getter method for percentage_used, mapped from YANG variable /components/component/storage/state/counters/percentage_used (uint8)

    YANG Description: Contains a vendor specific estimate of the percentage of NVM
subsystem life used based on the actual usage and the manufacturer’s
prediction of NVM life. A value of 100 indicates that the estimated
endurance of the NVM in the NVM subsystem has been consumed, but may
not indicate an NVM subsystem failure. The value is allowed to exceed
100. Percentages greater than 254 shall be represented as 255.
    """
    return self.__percentage_used
      
  def _set_percentage_used(self, v, load=False):
    """
    Setter method for percentage_used, mapped from YANG variable /components/component/storage/state/counters/percentage_used (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_percentage_used is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_percentage_used() directly.

    YANG Description: Contains a vendor specific estimate of the percentage of NVM
subsystem life used based on the actual usage and the manufacturer’s
prediction of NVM life. A value of 100 indicates that the estimated
endurance of the NVM in the NVM subsystem has been consumed, but may
not indicate an NVM subsystem failure. The value is allowed to exceed
100. Percentages greater than 254 shall be represented as 255.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """percentage_used must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)""",
        })

    self.__percentage_used = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_percentage_used(self):
    self.__percentage_used = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)

  soft_read_error_rate = __builtin__.property(_get_soft_read_error_rate)
  reallocated_sectors = __builtin__.property(_get_reallocated_sectors)
  end_to_end_error = __builtin__.property(_get_end_to_end_error)
  offline_uncorrectable_sectors_count = __builtin__.property(_get_offline_uncorrectable_sectors_count)
  life_left = __builtin__.property(_get_life_left)
  percentage_used = __builtin__.property(_get_percentage_used)


  _pyangbind_elements = OrderedDict([('soft_read_error_rate', soft_read_error_rate), ('reallocated_sectors', reallocated_sectors), ('end_to_end_error', end_to_end_error), ('offline_uncorrectable_sectors_count', offline_uncorrectable_sectors_count), ('life_left', life_left), ('percentage_used', percentage_used), ])


class counters(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /components/component/storage/state/counters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A collection of storage specific statistics entitites.
  """
  __slots__ = ('_path_helper', '_extmethods', '__soft_read_error_rate','__reallocated_sectors','__end_to_end_error','__offline_uncorrectable_sectors_count','__life_left','__percentage_used',)

  _yang_name = 'counters'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__soft_read_error_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__reallocated_sectors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__end_to_end_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__offline_uncorrectable_sectors_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    self.__life_left = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    self.__percentage_used = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'storage', 'state', 'counters']

  def _get_soft_read_error_rate(self):
    """
    Getter method for soft_read_error_rate, mapped from YANG variable /components/component/storage/state/counters/soft_read_error_rate (oc-yang:counter64)

    YANG Description: Uncorrected read errors reported to the operating system. SMART ID
201.
    """
    return self.__soft_read_error_rate
      
  def _set_soft_read_error_rate(self, v, load=False):
    """
    Setter method for soft_read_error_rate, mapped from YANG variable /components/component/storage/state/counters/soft_read_error_rate (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_soft_read_error_rate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_soft_read_error_rate() directly.

    YANG Description: Uncorrected read errors reported to the operating system. SMART ID
201.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """soft_read_error_rate must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__soft_read_error_rate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_soft_read_error_rate(self):
    self.__soft_read_error_rate = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="soft-read-error-rate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_reallocated_sectors(self):
    """
    Getter method for reallocated_sectors, mapped from YANG variable /components/component/storage/state/counters/reallocated_sectors (oc-yang:counter64)

    YANG Description: Count of reallocated sectors. The raw value represents a count of
the bad sectors that have been found and remapped. SMART ID 5.
    """
    return self.__reallocated_sectors
      
  def _set_reallocated_sectors(self, v, load=False):
    """
    Setter method for reallocated_sectors, mapped from YANG variable /components/component/storage/state/counters/reallocated_sectors (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reallocated_sectors is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reallocated_sectors() directly.

    YANG Description: Count of reallocated sectors. The raw value represents a count of
the bad sectors that have been found and remapped. SMART ID 5.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """reallocated_sectors must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__reallocated_sectors = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_reallocated_sectors(self):
    self.__reallocated_sectors = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reallocated-sectors", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_end_to_end_error(self):
    """
    Getter method for end_to_end_error, mapped from YANG variable /components/component/storage/state/counters/end_to_end_error (oc-yang:counter64)

    YANG Description: Count of parity errors which occur in the data path to the media.
SMART ID 184.
    """
    return self.__end_to_end_error
      
  def _set_end_to_end_error(self, v, load=False):
    """
    Setter method for end_to_end_error, mapped from YANG variable /components/component/storage/state/counters/end_to_end_error (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_end_to_end_error is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_end_to_end_error() directly.

    YANG Description: Count of parity errors which occur in the data path to the media.
SMART ID 184.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """end_to_end_error must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__end_to_end_error = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_end_to_end_error(self):
    self.__end_to_end_error = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="end-to-end-error", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_offline_uncorrectable_sectors_count(self):
    """
    Getter method for offline_uncorrectable_sectors_count, mapped from YANG variable /components/component/storage/state/counters/offline_uncorrectable_sectors_count (oc-yang:counter64)

    YANG Description: The total count of uncorrectable errors when reading/writing a
sector. SMART ID 198.
    """
    return self.__offline_uncorrectable_sectors_count
      
  def _set_offline_uncorrectable_sectors_count(self, v, load=False):
    """
    Setter method for offline_uncorrectable_sectors_count, mapped from YANG variable /components/component/storage/state/counters/offline_uncorrectable_sectors_count (oc-yang:counter64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_offline_uncorrectable_sectors_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_offline_uncorrectable_sectors_count() directly.

    YANG Description: The total count of uncorrectable errors when reading/writing a
sector. SMART ID 198.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """offline_uncorrectable_sectors_count must be of a type compatible with oc-yang:counter64""",
          'defined-type': "oc-yang:counter64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)""",
        })

    self.__offline_uncorrectable_sectors_count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_offline_uncorrectable_sectors_count(self):
    self.__offline_uncorrectable_sectors_count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="offline-uncorrectable-sectors-count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='oc-yang:counter64', is_config=False)


  def _get_life_left(self):
    """
    Getter method for life_left, mapped from YANG variable /components/component/storage/state/counters/life_left (uint8)

    YANG Description: Indicates the approximate SSD life left, in terms of program/erase
cycles or available reserved blocks. A normalized value of 100
represents a new drive, with a threshold value at 10 indicating a need
for replacement. A value of 0 may mean that the drive is operating in
read-only mode to allow data recovery. SMART ID 231.
    """
    return self.__life_left
      
  def _set_life_left(self, v, load=False):
    """
    Setter method for life_left, mapped from YANG variable /components/component/storage/state/counters/life_left (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_life_left is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_life_left() directly.

    YANG Description: Indicates the approximate SSD life left, in terms of program/erase
cycles or available reserved blocks. A normalized value of 100
represents a new drive, with a threshold value at 10 indicating a need
for replacement. A value of 0 may mean that the drive is operating in
read-only mode to allow data recovery. SMART ID 231.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """life_left must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)""",
        })

    self.__life_left = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_life_left(self):
    self.__life_left = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="life-left", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)


  def _get_percentage_used(self):
    """
    Getter method for percentage_used, mapped from YANG variable /components/component/storage/state/counters/percentage_used (uint8)

    YANG Description: Contains a vendor specific estimate of the percentage of NVM
subsystem life used based on the actual usage and the manufacturer’s
prediction of NVM life. A value of 100 indicates that the estimated
endurance of the NVM in the NVM subsystem has been consumed, but may
not indicate an NVM subsystem failure. The value is allowed to exceed
100. Percentages greater than 254 shall be represented as 255.
    """
    return self.__percentage_used
      
  def _set_percentage_used(self, v, load=False):
    """
    Setter method for percentage_used, mapped from YANG variable /components/component/storage/state/counters/percentage_used (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_percentage_used is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_percentage_used() directly.

    YANG Description: Contains a vendor specific estimate of the percentage of NVM
subsystem life used based on the actual usage and the manufacturer’s
prediction of NVM life. A value of 100 indicates that the estimated
endurance of the NVM in the NVM subsystem has been consumed, but may
not indicate an NVM subsystem failure. The value is allowed to exceed
100. Percentages greater than 254 shall be represented as 255.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """percentage_used must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)""",
        })

    self.__percentage_used = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_percentage_used(self):
    self.__percentage_used = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="percentage-used", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform/storage', defining_module='openconfig-platform-storage', yang_type='uint8', is_config=False)

  soft_read_error_rate = __builtin__.property(_get_soft_read_error_rate)
  reallocated_sectors = __builtin__.property(_get_reallocated_sectors)
  end_to_end_error = __builtin__.property(_get_end_to_end_error)
  offline_uncorrectable_sectors_count = __builtin__.property(_get_offline_uncorrectable_sectors_count)
  life_left = __builtin__.property(_get_life_left)
  percentage_used = __builtin__.property(_get_percentage_used)


  _pyangbind_elements = OrderedDict([('soft_read_error_rate', soft_read_error_rate), ('reallocated_sectors', reallocated_sectors), ('end_to_end_error', end_to_end_error), ('offline_uncorrectable_sectors_count', offline_uncorrectable_sectors_count), ('life_left', life_left), ('percentage_used', percentage_used), ])


