# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/integrated-circuit/pipeline-counters/errors/fabric-block/fabric-block-error/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Errors corresponding to the fabric subsystem of the IC.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__count','__threshold','__action','__active','__level',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    self.__action = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'integrated-circuit', 'pipeline-counters', 'errors', 'fabric-block', 'fabric-block-error', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/name (string)

    YANG Description: Name of the interrupt, hardware error, or software error in the NPU.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the interrupt, hardware error, or software error in the NPU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/count (uint64)

    YANG Description: Total count of errors of this type.
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Total count of errors of this type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)


  def _get_threshold(self):
    """
    Getter method for threshold, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/threshold (uint64)

    YANG Description: Number of errors before a recovery action is automatically
taken by the system.
    """
    return self.__threshold
      
  def _set_threshold(self, v, load=False):
    """
    Setter method for threshold, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold() directly.

    YANG Description: Number of errors before a recovery action is automatically
taken by the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)""",
        })

    self.__threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold(self):
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/action (enumeration)

    YANG Description: Error actions that are taken by the system - log, linecard reboot,
linecard offline, NPU reset, NPU offline, gather diagnostic data,
raise an alarm.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Error actions that are taken by the system - log, linecard reboot,
linecard offline, NPU reset, NPU offline, gather diagnostic data,
raise an alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-pipeline-counters:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/active (boolean)

    YANG Description: The error is currently in an active state. When the system detects
that the specified threshold is exceeded, this value should be set to
true.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: The error is currently in an active state. When the system detects
that the specified threshold is exceeded, this value should be set to
true.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/level (enumeration)

    YANG Description: The severity of the error that is being recorded by the system. This
value can be used by a consumer to determine the action when this error
is recorded.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/level (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: The severity of the error that is being recorded by the system. This
value can be used by a consumer to determine the action when this error
is recorded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-pipeline-counters:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)

  name = __builtin__.property(_get_name)
  count = __builtin__.property(_get_count)
  threshold = __builtin__.property(_get_threshold)
  action = __builtin__.property(_get_action)
  active = __builtin__.property(_get_active)
  level = __builtin__.property(_get_level)


  _pyangbind_elements = OrderedDict([('name', name), ('count', count), ('threshold', threshold), ('action', action), ('active', active), ('level', level), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /components/component/integrated-circuit/pipeline-counters/errors/fabric-block/fabric-block-error/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Errors corresponding to the fabric subsystem of the IC.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__count','__threshold','__action','__active','__level',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    self.__action = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'integrated-circuit', 'pipeline-counters', 'errors', 'fabric-block', 'fabric-block-error', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/name (string)

    YANG Description: Name of the interrupt, hardware error, or software error in the NPU.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the interrupt, hardware error, or software error in the NPU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/count (uint64)

    YANG Description: Total count of errors of this type.
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Total count of errors of this type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)


  def _get_threshold(self):
    """
    Getter method for threshold, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/threshold (uint64)

    YANG Description: Number of errors before a recovery action is automatically
taken by the system.
    """
    return self.__threshold
      
  def _set_threshold(self, v, load=False):
    """
    Setter method for threshold, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold() directly.

    YANG Description: Number of errors before a recovery action is automatically
taken by the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)""",
        })

    self.__threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold(self):
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/action (enumeration)

    YANG Description: Error actions that are taken by the system - log, linecard reboot,
linecard offline, NPU reset, NPU offline, gather diagnostic data,
raise an alarm.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Error actions that are taken by the system - log, linecard reboot,
linecard offline, NPU reset, NPU offline, gather diagnostic data,
raise an alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-pipeline-counters:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/active (boolean)

    YANG Description: The error is currently in an active state. When the system detects
that the specified threshold is exceeded, this value should be set to
true.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: The error is currently in an active state. When the system detects
that the specified threshold is exceeded, this value should be set to
true.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/level (enumeration)

    YANG Description: The severity of the error that is being recorded by the system. This
value can be used by a consumer to determine the action when this error
is recorded.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/level (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: The severity of the error that is being recorded by the system. This
value can be used by a consumer to determine the action when this error
is recorded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-pipeline-counters:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)

  name = __builtin__.property(_get_name)
  count = __builtin__.property(_get_count)
  threshold = __builtin__.property(_get_threshold)
  action = __builtin__.property(_get_action)
  active = __builtin__.property(_get_active)
  level = __builtin__.property(_get_level)


  _pyangbind_elements = OrderedDict([('name', name), ('count', count), ('threshold', threshold), ('action', action), ('active', active), ('level', level), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/integrated-circuit/pipeline-counters/errors/fabric-block/fabric-block-error/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Errors corresponding to the fabric subsystem of the IC.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__count','__threshold','__action','__active','__level',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    self.__action = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'integrated-circuit', 'pipeline-counters', 'errors', 'fabric-block', 'fabric-block-error', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/name (string)

    YANG Description: Name of the interrupt, hardware error, or software error in the NPU.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the interrupt, hardware error, or software error in the NPU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/count (uint64)

    YANG Description: Total count of errors of this type.
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Total count of errors of this type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)


  def _get_threshold(self):
    """
    Getter method for threshold, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/threshold (uint64)

    YANG Description: Number of errors before a recovery action is automatically
taken by the system.
    """
    return self.__threshold
      
  def _set_threshold(self, v, load=False):
    """
    Setter method for threshold, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold() directly.

    YANG Description: Number of errors before a recovery action is automatically
taken by the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)""",
        })

    self.__threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold(self):
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/action (enumeration)

    YANG Description: Error actions that are taken by the system - log, linecard reboot,
linecard offline, NPU reset, NPU offline, gather diagnostic data,
raise an alarm.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Error actions that are taken by the system - log, linecard reboot,
linecard offline, NPU reset, NPU offline, gather diagnostic data,
raise an alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-pipeline-counters:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/active (boolean)

    YANG Description: The error is currently in an active state. When the system detects
that the specified threshold is exceeded, this value should be set to
true.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: The error is currently in an active state. When the system detects
that the specified threshold is exceeded, this value should be set to
true.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/level (enumeration)

    YANG Description: The severity of the error that is being recorded by the system. This
value can be used by a consumer to determine the action when this error
is recorded.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/level (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: The severity of the error that is being recorded by the system. This
value can be used by a consumer to determine the action when this error
is recorded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-pipeline-counters:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)

  name = __builtin__.property(_get_name)
  count = __builtin__.property(_get_count)
  threshold = __builtin__.property(_get_threshold)
  action = __builtin__.property(_get_action)
  active = __builtin__.property(_get_active)
  level = __builtin__.property(_get_level)


  _pyangbind_elements = OrderedDict([('name', name), ('count', count), ('threshold', threshold), ('action', action), ('active', active), ('level', level), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform-common - based on the path /components/component/integrated-circuit/pipeline-counters/errors/fabric-block/fabric-block-error/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Errors corresponding to the fabric subsystem of the IC.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__count','__threshold','__action','__active','__level',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    self.__action = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    self.__active = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'integrated-circuit', 'pipeline-counters', 'errors', 'fabric-block', 'fabric-block-error', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/name (string)

    YANG Description: Name of the interrupt, hardware error, or software error in the NPU.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the interrupt, hardware error, or software error in the NPU.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=str, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='string', is_config=False)


  def _get_count(self):
    """
    Getter method for count, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/count (uint64)

    YANG Description: Total count of errors of this type.
    """
    return self.__count
      
  def _set_count(self, v, load=False):
    """
    Setter method for count, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/count (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_count is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_count() directly.

    YANG Description: Total count of errors of this type.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """count must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)""",
        })

    self.__count = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_count(self):
    self.__count = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="count", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)


  def _get_threshold(self):
    """
    Getter method for threshold, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/threshold (uint64)

    YANG Description: Number of errors before a recovery action is automatically
taken by the system.
    """
    return self.__threshold
      
  def _set_threshold(self, v, load=False):
    """
    Setter method for threshold, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/threshold (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold() directly.

    YANG Description: Number of errors before a recovery action is automatically
taken by the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """threshold must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)""",
        })

    self.__threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_threshold(self):
    self.__threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='uint64', is_config=False)


  def _get_action(self):
    """
    Getter method for action, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/action (enumeration)

    YANG Description: Error actions that are taken by the system - log, linecard reboot,
linecard offline, NPU reset, NPU offline, gather diagnostic data,
raise an alarm.
    """
    return self.__action
      
  def _set_action(self, v, load=False):
    """
    Setter method for action, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/action (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_action() directly.

    YANG Description: Error actions that are taken by the system - log, linecard reboot,
linecard offline, NPU reset, NPU offline, gather diagnostic data,
raise an alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """action must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-pipeline-counters:enumeration",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)""",
        })

    self.__action = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_action(self):
    self.__action = YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'LOG': {}, 'LINECARD_REBOOT': {}, 'LINECARD_OFFLINE': {}, 'NPU_RESET': {}, 'NPU_OFFLINE': {}, 'GET_DIAGNOSTIC_INFO': {}, 'ALARM': {}},)), is_leaf=False, yang_name="action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)


  def _get_active(self):
    """
    Getter method for active, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/active (boolean)

    YANG Description: The error is currently in an active state. When the system detects
that the specified threshold is exceeded, this value should be set to
true.
    """
    return self.__active
      
  def _set_active(self, v, load=False):
    """
    Setter method for active, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/active (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_active is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_active() directly.

    YANG Description: The error is currently in an active state. When the system detects
that the specified threshold is exceeded, this value should be set to
true.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """active must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)""",
        })

    self.__active = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_active(self):
    self.__active = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="active", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='boolean', is_config=False)


  def _get_level(self):
    """
    Getter method for level, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/level (enumeration)

    YANG Description: The severity of the error that is being recorded by the system. This
value can be used by a consumer to determine the action when this error
is recorded.
    """
    return self.__level
      
  def _set_level(self, v, load=False):
    """
    Setter method for level, mapped from YANG variable /components/component/integrated_circuit/pipeline_counters/errors/fabric_block/fabric_block_error/state/level (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_level() directly.

    YANG Description: The severity of the error that is being recorded by the system. This
value can be used by a consumer to determine the action when this error
is recorded.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """level must be of a type compatible with enumeration""",
          'defined-type': "openconfig-platform-pipeline-counters:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)""",
        })

    self.__level = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_level(self):
    self.__level = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'FATAL': {}, 'MAJOR': {}, 'MINOR': {}, 'INFORMATIONAL': {}},), is_leaf=True, yang_name="level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform-pipeline-counters', defining_module='openconfig-platform-pipeline-counters', yang_type='enumeration', is_config=False)

  name = __builtin__.property(_get_name)
  count = __builtin__.property(_get_count)
  threshold = __builtin__.property(_get_threshold)
  action = __builtin__.property(_get_action)
  active = __builtin__.property(_get_active)
  level = __builtin__.property(_get_level)


  _pyangbind_elements = OrderedDict([('name', name), ('count', count), ('threshold', threshold), ('action', action), ('active', active), ('level', level), ])


