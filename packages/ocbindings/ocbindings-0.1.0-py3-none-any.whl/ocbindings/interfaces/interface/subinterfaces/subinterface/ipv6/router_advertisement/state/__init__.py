# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to router
advertisements for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__interval','__lifetime','__suppress','__mode','__managed','__other_config',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}, 'DISABLE_UNSOLICITED_RA': {}},), default=str("ALL"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement', 'state']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/enable (boolean)

    YANG Description: If set to false, all IPv6 router advertisement functions are
disabled.  The local system will not transmit router advertisement
messages and will not respond to router solicitation messages.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: If set to false, all IPv6 router advertisement functions are
disabled.  The local system will not transmit router advertisement
messages and will not respond to router solicitation messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/interval (uint32)

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_lifetime(self):
    """
    Getter method for lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/lifetime (uint32)

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    return self.__lifetime
      
  def _set_lifetime(self, v, load=False):
    """
    Setter method for lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifetime() directly.

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifetime(self):
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/suppress (boolean)

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/mode (enumeration)

    YANG Description: Mode controls which set of behaviors the local system should perform
to support IPv6 router advertisements.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Mode controls which set of behaviors the local system should perform
to support IPv6 router advertisements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}, 'DISABLE_UNSOLICITED_RA': {}},), default=str("ALL"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}, 'DISABLE_UNSOLICITED_RA': {}},), default=str("ALL"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}, 'DISABLE_UNSOLICITED_RA': {}},), default=str("ALL"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)


  def _get_managed(self):
    """
    Getter method for managed, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/managed (boolean)

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    return self.__managed
      
  def _set_managed(self, v, load=False):
    """
    Setter method for managed, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/managed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed() directly.

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed(self):
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_other_config(self):
    """
    Getter method for other_config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/other_config (boolean)

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    return self.__other_config
      
  def _set_other_config(self, v, load=False):
    """
    Setter method for other_config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/other_config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_config() directly.

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__other_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_config(self):
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  enable = __builtin__.property(_get_enable)
  interval = __builtin__.property(_get_interval)
  lifetime = __builtin__.property(_get_lifetime)
  suppress = __builtin__.property(_get_suppress)
  mode = __builtin__.property(_get_mode)
  managed = __builtin__.property(_get_managed)
  other_config = __builtin__.property(_get_other_config)


  _pyangbind_elements = OrderedDict([('enable', enable), ('interval', interval), ('lifetime', lifetime), ('suppress', suppress), ('mode', mode), ('managed', managed), ('other_config', other_config), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-interfaces - based on the path /interfaces/interface/subinterfaces/subinterface/ipv6/router-advertisement/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state parameters relating to router
advertisements for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__enable','__interval','__lifetime','__suppress','__mode','__managed','__other_config',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/interfaces'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}, 'DISABLE_UNSOLICITED_RA': {}},), default=str("ALL"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['interfaces', 'interface', 'subinterfaces', 'subinterface', 'ipv6', 'router-advertisement', 'state']

  def _get_enable(self):
    """
    Getter method for enable, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/enable (boolean)

    YANG Description: If set to false, all IPv6 router advertisement functions are
disabled.  The local system will not transmit router advertisement
messages and will not respond to router solicitation messages.
    """
    return self.__enable
      
  def _set_enable(self, v, load=False):
    """
    Setter method for enable, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/enable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable() directly.

    YANG Description: If set to false, all IPv6 router advertisement functions are
disabled.  The local system will not transmit router advertisement
messages and will not respond to router solicitation messages.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__enable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable(self):
    self.__enable = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/interval (uint32)

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: The interval between periodic router advertisement neighbor
discovery messages sent on this interface expressed in
seconds.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_lifetime(self):
    """
    Getter method for lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/lifetime (uint32)

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    return self.__lifetime
      
  def _set_lifetime(self, v, load=False):
    """
    Setter method for lifetime, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/lifetime (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifetime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifetime() directly.

    YANG Description: The lifetime advertised in the router advertisement neighbor
discovery message on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lifetime must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)""",
        })

    self.__lifetime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lifetime(self):
    self.__lifetime = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="lifetime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='uint32', is_config=False)


  def _get_suppress(self):
    """
    Getter method for suppress, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/suppress (boolean)

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    return self.__suppress
      
  def _set_suppress(self, v, load=False):
    """
    Setter method for suppress, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/suppress (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_suppress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_suppress() directly.

    YANG Description: When set to true, router advertisement neighbor discovery
messages are not transmitted on this interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """suppress must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__suppress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_suppress(self):
    self.__suppress = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="suppress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_mode(self):
    """
    Getter method for mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/mode (enumeration)

    YANG Description: Mode controls which set of behaviors the local system should perform
to support IPv6 router advertisements.
    """
    return self.__mode
      
  def _set_mode(self, v, load=False):
    """
    Setter method for mode, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mode() directly.

    YANG Description: Mode controls which set of behaviors the local system should perform
to support IPv6 router advertisements.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}, 'DISABLE_UNSOLICITED_RA': {}},), default=str("ALL"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mode must be of a type compatible with enumeration""",
          'defined-type': "openconfig-if-ip:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}, 'DISABLE_UNSOLICITED_RA': {}},), default=str("ALL"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)""",
        })

    self.__mode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mode(self):
    self.__mode = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'ALL': {}, 'DISABLE_UNSOLICITED_RA': {}},), default=str("ALL"), is_leaf=True, yang_name="mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='enumeration', is_config=False)


  def _get_managed(self):
    """
    Getter method for managed, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/managed (boolean)

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    return self.__managed
      
  def _set_managed(self, v, load=False):
    """
    Setter method for managed, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/managed (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_managed is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_managed() directly.

    YANG Description: When set to true, the managed address configuration (M) flag is set in
the advertised router advertisement. The M flag indicates that there are
addresses available via DHCPv6.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """managed must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__managed = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_managed(self):
    self.__managed = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="managed", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)


  def _get_other_config(self):
    """
    Getter method for other_config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/other_config (boolean)

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    return self.__other_config
      
  def _set_other_config(self, v, load=False):
    """
    Setter method for other_config, mapped from YANG variable /interfaces/interface/subinterfaces/subinterface/ipv6/router_advertisement/state/other_config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_other_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_other_config() directly.

    YANG Description: When set to true, the other configuration (O) flag is set in the
advertised router advertisement. The O flag indicates that there is
other configuration available via DHCPv6 (e.g., DNS servers).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """other_config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)""",
        })

    self.__other_config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_other_config(self):
    self.__other_config = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="other-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/interfaces/ip', defining_module='openconfig-if-ip', yang_type='boolean', is_config=False)

  enable = __builtin__.property(_get_enable)
  interval = __builtin__.property(_get_interval)
  lifetime = __builtin__.property(_get_lifetime)
  suppress = __builtin__.property(_get_suppress)
  mode = __builtin__.property(_get_mode)
  managed = __builtin__.property(_get_managed)
  other_config = __builtin__.property(_get_other_config)


  _pyangbind_elements = OrderedDict([('enable', enable), ('interval', interval), ('lifetime', lifetime), ('suppress', suppress), ('mode', mode), ('managed', managed), ('other_config', other_config), ])


