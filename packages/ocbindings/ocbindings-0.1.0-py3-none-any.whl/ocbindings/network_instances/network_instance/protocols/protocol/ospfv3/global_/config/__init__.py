# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/ospfv3/global/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global configuration parameters for OSPF
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__log_adjacency_changes','__hide_transit_only_networks','__abr_capability',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)
    self.__log_adjacency_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__hide_transit_only_networks = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__abr_capability = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'ospfv3', 'global', 'config']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number represented as a dotted quad assigned to
each router running the OSPF protocol. This number should
be unique within the autonomous system
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number represented as a dotted quad assigned to
each router running the OSPF protocol. This number should
be unique within the autonomous system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)


  def _get_log_adjacency_changes(self):
    """
    Getter method for log_adjacency_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/log_adjacency_changes (boolean)

    YANG Description: When this leaf is set to true, a log message will be
generated when the state of an OSPF neighbour changes.
    """
    return self.__log_adjacency_changes
      
  def _set_log_adjacency_changes(self, v, load=False):
    """
    Setter method for log_adjacency_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/log_adjacency_changes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_adjacency_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_adjacency_changes() directly.

    YANG Description: When this leaf is set to true, a log message will be
generated when the state of an OSPF neighbour changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_adjacency_changes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__log_adjacency_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_adjacency_changes(self):
    self.__log_adjacency_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_hide_transit_only_networks(self):
    """
    Getter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/hide_transit_only_networks (boolean)

    YANG Description: When this leaf is set to true, do not advertise prefixes
into OSPF that correspond to transit interfaces, as per
the behaviour discussed in RFC6860.
    """
    return self.__hide_transit_only_networks
      
  def _set_hide_transit_only_networks(self, v, load=False):
    """
    Setter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/hide_transit_only_networks (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hide_transit_only_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hide_transit_only_networks() directly.

    YANG Description: When this leaf is set to true, do not advertise prefixes
into OSPF that correspond to transit interfaces, as per
the behaviour discussed in RFC6860.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hide_transit_only_networks must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__hide_transit_only_networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hide_transit_only_networks(self):
    self.__hide_transit_only_networks = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_abr_capability(self):
    """
    Getter method for abr_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/abr_capability (identityref)

    YANG Description: When the leaf is set to RFC2328_ABR, the router
acts as an ABR when it participates in multiple OSPF
areas. It does not matter whether the backbone area
exists or not. When the leaf is set to RFC3509_ABR,
the router acts as an ABR when the router participates
in multiple OSPF areas, one of which must be backbone.
    """
    return self.__abr_capability
      
  def _set_abr_capability(self, v, load=False):
    """
    Setter method for abr_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/abr_capability (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abr_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abr_capability() directly.

    YANG Description: When the leaf is set to RFC2328_ABR, the router
acts as an ABR when it participates in multiple OSPF
areas. It does not matter whether the backbone area
exists or not. When the leaf is set to RFC3509_ABR,
the router acts as an ABR when the router participates
in multiple OSPF areas, one of which must be backbone.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abr_capability must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)""",
        })

    self.__abr_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abr_capability(self):
    self.__abr_capability = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  log_adjacency_changes = __builtin__.property(_get_log_adjacency_changes, _set_log_adjacency_changes)
  hide_transit_only_networks = __builtin__.property(_get_hide_transit_only_networks, _set_hide_transit_only_networks)
  abr_capability = __builtin__.property(_get_abr_capability, _set_abr_capability)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('log_adjacency_changes', log_adjacency_changes), ('hide_transit_only_networks', hide_transit_only_networks), ('abr_capability', abr_capability), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/ospfv3/global/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global configuration parameters for OSPF
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__log_adjacency_changes','__hide_transit_only_networks','__abr_capability',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)
    self.__log_adjacency_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__hide_transit_only_networks = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__abr_capability = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'ospfv3', 'global', 'config']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number represented as a dotted quad assigned to
each router running the OSPF protocol. This number should
be unique within the autonomous system
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number represented as a dotted quad assigned to
each router running the OSPF protocol. This number should
be unique within the autonomous system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)


  def _get_log_adjacency_changes(self):
    """
    Getter method for log_adjacency_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/log_adjacency_changes (boolean)

    YANG Description: When this leaf is set to true, a log message will be
generated when the state of an OSPF neighbour changes.
    """
    return self.__log_adjacency_changes
      
  def _set_log_adjacency_changes(self, v, load=False):
    """
    Setter method for log_adjacency_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/log_adjacency_changes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_adjacency_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_adjacency_changes() directly.

    YANG Description: When this leaf is set to true, a log message will be
generated when the state of an OSPF neighbour changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_adjacency_changes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__log_adjacency_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_adjacency_changes(self):
    self.__log_adjacency_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_hide_transit_only_networks(self):
    """
    Getter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/hide_transit_only_networks (boolean)

    YANG Description: When this leaf is set to true, do not advertise prefixes
into OSPF that correspond to transit interfaces, as per
the behaviour discussed in RFC6860.
    """
    return self.__hide_transit_only_networks
      
  def _set_hide_transit_only_networks(self, v, load=False):
    """
    Setter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/hide_transit_only_networks (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hide_transit_only_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hide_transit_only_networks() directly.

    YANG Description: When this leaf is set to true, do not advertise prefixes
into OSPF that correspond to transit interfaces, as per
the behaviour discussed in RFC6860.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hide_transit_only_networks must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__hide_transit_only_networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hide_transit_only_networks(self):
    self.__hide_transit_only_networks = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_abr_capability(self):
    """
    Getter method for abr_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/abr_capability (identityref)

    YANG Description: When the leaf is set to RFC2328_ABR, the router
acts as an ABR when it participates in multiple OSPF
areas. It does not matter whether the backbone area
exists or not. When the leaf is set to RFC3509_ABR,
the router acts as an ABR when the router participates
in multiple OSPF areas, one of which must be backbone.
    """
    return self.__abr_capability
      
  def _set_abr_capability(self, v, load=False):
    """
    Setter method for abr_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/abr_capability (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abr_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abr_capability() directly.

    YANG Description: When the leaf is set to RFC2328_ABR, the router
acts as an ABR when it participates in multiple OSPF
areas. It does not matter whether the backbone area
exists or not. When the leaf is set to RFC3509_ABR,
the router acts as an ABR when the router participates
in multiple OSPF areas, one of which must be backbone.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abr_capability must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)""",
        })

    self.__abr_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abr_capability(self):
    self.__abr_capability = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  log_adjacency_changes = __builtin__.property(_get_log_adjacency_changes, _set_log_adjacency_changes)
  hide_transit_only_networks = __builtin__.property(_get_hide_transit_only_networks, _set_hide_transit_only_networks)
  abr_capability = __builtin__.property(_get_abr_capability, _set_abr_capability)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('log_adjacency_changes', log_adjacency_changes), ('hide_transit_only_networks', hide_transit_only_networks), ('abr_capability', abr_capability), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance - based on the path /network-instances/network-instance/protocols/protocol/ospfv3/global/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global configuration parameters for OSPF
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__log_adjacency_changes','__hide_transit_only_networks','__abr_capability',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)
    self.__log_adjacency_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__hide_transit_only_networks = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__abr_capability = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'ospfv3', 'global', 'config']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number represented as a dotted quad assigned to
each router running the OSPF protocol. This number should
be unique within the autonomous system
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number represented as a dotted quad assigned to
each router running the OSPF protocol. This number should
be unique within the autonomous system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)


  def _get_log_adjacency_changes(self):
    """
    Getter method for log_adjacency_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/log_adjacency_changes (boolean)

    YANG Description: When this leaf is set to true, a log message will be
generated when the state of an OSPF neighbour changes.
    """
    return self.__log_adjacency_changes
      
  def _set_log_adjacency_changes(self, v, load=False):
    """
    Setter method for log_adjacency_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/log_adjacency_changes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_adjacency_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_adjacency_changes() directly.

    YANG Description: When this leaf is set to true, a log message will be
generated when the state of an OSPF neighbour changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_adjacency_changes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__log_adjacency_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_adjacency_changes(self):
    self.__log_adjacency_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_hide_transit_only_networks(self):
    """
    Getter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/hide_transit_only_networks (boolean)

    YANG Description: When this leaf is set to true, do not advertise prefixes
into OSPF that correspond to transit interfaces, as per
the behaviour discussed in RFC6860.
    """
    return self.__hide_transit_only_networks
      
  def _set_hide_transit_only_networks(self, v, load=False):
    """
    Setter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/hide_transit_only_networks (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hide_transit_only_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hide_transit_only_networks() directly.

    YANG Description: When this leaf is set to true, do not advertise prefixes
into OSPF that correspond to transit interfaces, as per
the behaviour discussed in RFC6860.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hide_transit_only_networks must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__hide_transit_only_networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hide_transit_only_networks(self):
    self.__hide_transit_only_networks = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_abr_capability(self):
    """
    Getter method for abr_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/abr_capability (identityref)

    YANG Description: When the leaf is set to RFC2328_ABR, the router
acts as an ABR when it participates in multiple OSPF
areas. It does not matter whether the backbone area
exists or not. When the leaf is set to RFC3509_ABR,
the router acts as an ABR when the router participates
in multiple OSPF areas, one of which must be backbone.
    """
    return self.__abr_capability
      
  def _set_abr_capability(self, v, load=False):
    """
    Setter method for abr_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/abr_capability (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abr_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abr_capability() directly.

    YANG Description: When the leaf is set to RFC2328_ABR, the router
acts as an ABR when it participates in multiple OSPF
areas. It does not matter whether the backbone area
exists or not. When the leaf is set to RFC3509_ABR,
the router acts as an ABR when the router participates
in multiple OSPF areas, one of which must be backbone.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abr_capability must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)""",
        })

    self.__abr_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abr_capability(self):
    self.__abr_capability = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  log_adjacency_changes = __builtin__.property(_get_log_adjacency_changes, _set_log_adjacency_changes)
  hide_transit_only_networks = __builtin__.property(_get_hide_transit_only_networks, _set_hide_transit_only_networks)
  abr_capability = __builtin__.property(_get_abr_capability, _set_abr_capability)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('log_adjacency_changes', log_adjacency_changes), ('hide_transit_only_networks', hide_transit_only_networks), ('abr_capability', abr_capability), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-network-instance-l2 - based on the path /network-instances/network-instance/protocols/protocol/ospfv3/global/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Global configuration parameters for OSPF
  """
  __slots__ = ('_path_helper', '_extmethods', '__router_id','__log_adjacency_changes','__hide_transit_only_networks','__abr_capability',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/network-instance'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)
    self.__log_adjacency_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__hide_transit_only_networks = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    self.__abr_capability = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['network-instances', 'network-instance', 'protocols', 'protocol', 'ospfv3', 'global', 'config']

  def _get_router_id(self):
    """
    Getter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/router_id (yang:dotted-quad)

    YANG Description: A 32-bit number represented as a dotted quad assigned to
each router running the OSPF protocol. This number should
be unique within the autonomous system
    """
    return self.__router_id
      
  def _set_router_id(self, v, load=False):
    """
    Setter method for router_id, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/router_id (yang:dotted-quad)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_router_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_router_id() directly.

    YANG Description: A 32-bit number represented as a dotted quad assigned to
each router running the OSPF protocol. This number should
be unique within the autonomous system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """router_id must be of a type compatible with yang:dotted-quad""",
          'defined-type': "yang:dotted-quad",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)""",
        })

    self.__router_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_router_id(self):
    self.__router_id = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'}), is_leaf=True, yang_name="router-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='yang:dotted-quad', is_config=True)


  def _get_log_adjacency_changes(self):
    """
    Getter method for log_adjacency_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/log_adjacency_changes (boolean)

    YANG Description: When this leaf is set to true, a log message will be
generated when the state of an OSPF neighbour changes.
    """
    return self.__log_adjacency_changes
      
  def _set_log_adjacency_changes(self, v, load=False):
    """
    Setter method for log_adjacency_changes, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/log_adjacency_changes (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_log_adjacency_changes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_log_adjacency_changes() directly.

    YANG Description: When this leaf is set to true, a log message will be
generated when the state of an OSPF neighbour changes.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """log_adjacency_changes must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__log_adjacency_changes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_log_adjacency_changes(self):
    self.__log_adjacency_changes = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="log-adjacency-changes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_hide_transit_only_networks(self):
    """
    Getter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/hide_transit_only_networks (boolean)

    YANG Description: When this leaf is set to true, do not advertise prefixes
into OSPF that correspond to transit interfaces, as per
the behaviour discussed in RFC6860.
    """
    return self.__hide_transit_only_networks
      
  def _set_hide_transit_only_networks(self, v, load=False):
    """
    Setter method for hide_transit_only_networks, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/hide_transit_only_networks (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hide_transit_only_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hide_transit_only_networks() directly.

    YANG Description: When this leaf is set to true, do not advertise prefixes
into OSPF that correspond to transit interfaces, as per
the behaviour discussed in RFC6860.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hide_transit_only_networks must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)""",
        })

    self.__hide_transit_only_networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hide_transit_only_networks(self):
    self.__hide_transit_only_networks = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="hide-transit-only-networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='boolean', is_config=True)


  def _get_abr_capability(self):
    """
    Getter method for abr_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/abr_capability (identityref)

    YANG Description: When the leaf is set to RFC2328_ABR, the router
acts as an ABR when it participates in multiple OSPF
areas. It does not matter whether the backbone area
exists or not. When the leaf is set to RFC3509_ABR,
the router acts as an ABR when the router participates
in multiple OSPF areas, one of which must be backbone.
    """
    return self.__abr_capability
      
  def _set_abr_capability(self, v, load=False):
    """
    Setter method for abr_capability, mapped from YANG variable /network_instances/network_instance/protocols/protocol/ospfv3/global/config/abr_capability (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_abr_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_abr_capability() directly.

    YANG Description: When the leaf is set to RFC2328_ABR, the router
acts as an ABR when it participates in multiple OSPF
areas. It does not matter whether the backbone area
exists or not. When the leaf is set to RFC3509_ABR,
the router acts as an ABR when the router participates
in multiple OSPF areas, one of which must be backbone.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """abr_capability must be of a type compatible with identityref""",
          'defined-type': "openconfig-network-instance:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)""",
        })

    self.__abr_capability = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_abr_capability(self):
    self.__abr_capability = YANGDynClass(base=RestrictedClassType(base_type=str, restriction_type="dict_key", restriction_arg={'RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC3509_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'openconfig-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospf-types:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}, 'oc-ospft:RFC2328_ABR': {'@module': 'openconfig-ospf-types', '@namespace': 'http://openconfig.net/yang/ospf-types'}},), is_leaf=True, yang_name="abr-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/network-instance', defining_module='openconfig-network-instance', yang_type='identityref', is_config=True)

  router_id = __builtin__.property(_get_router_id, _set_router_id)
  log_adjacency_changes = __builtin__.property(_get_log_adjacency_changes, _set_log_adjacency_changes)
  hide_transit_only_networks = __builtin__.property(_get_hide_transit_only_networks, _set_hide_transit_only_networks)
  abr_capability = __builtin__.property(_get_abr_capability, _set_abr_capability)


  _pyangbind_elements = OrderedDict([('router_id', router_id), ('log_adjacency_changes', log_adjacency_changes), ('hide_transit_only_networks', hide_transit_only_networks), ('abr_capability', abr_capability), ])


