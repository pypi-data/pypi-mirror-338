# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device-properties - based on the path /linecard-descriptors/linecard-descriptor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Static features or properties which characterize the
component descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__component_descriptor_id','__system_vendor_name','__system_vendor_part_no','__mfg_name','__mfg_part_no','__hardware_version','__firmware_version','__software_version','__clei_code',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-terminal-device-properties'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__component_descriptor_id = YANGDynClass(base=str, is_leaf=True, yang_name="component-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__system_vendor_name = YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__system_vendor_part_no = YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__mfg_name = YANGDynClass(base=str, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__mfg_part_no = YANGDynClass(base=str, is_leaf=True, yang_name="mfg-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__hardware_version = YANGDynClass(base=str, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__firmware_version = YANGDynClass(base=str, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__software_version = YANGDynClass(base=str, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__clei_code = YANGDynClass(base=str, is_leaf=True, yang_name="clei-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['linecard-descriptors', 'linecard-descriptor', 'state']

  def _get_component_descriptor_id(self):
    """
    Getter method for component_descriptor_id, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/component_descriptor_id (string)

    YANG Description: Unique identifier assigned by the system vendor for the
component descriptor.
    """
    return self.__component_descriptor_id
      
  def _set_component_descriptor_id(self, v, load=False):
    """
    Setter method for component_descriptor_id, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/component_descriptor_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component_descriptor_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component_descriptor_id() directly.

    YANG Description: Unique identifier assigned by the system vendor for the
component descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="component-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component_descriptor_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="component-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__component_descriptor_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component_descriptor_id(self):
    self.__component_descriptor_id = YANGDynClass(base=str, is_leaf=True, yang_name="component-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_system_vendor_name(self):
    """
    Getter method for system_vendor_name, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/system_vendor_name (string)

    YANG Description: System vendor company name
    """
    return self.__system_vendor_name
      
  def _set_system_vendor_name(self, v, load=False):
    """
    Setter method for system_vendor_name, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/system_vendor_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_vendor_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_vendor_name() directly.

    YANG Description: System vendor company name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="system-vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_vendor_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__system_vendor_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_vendor_name(self):
    self.__system_vendor_name = YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_system_vendor_part_no(self):
    """
    Getter method for system_vendor_part_no, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/system_vendor_part_no (string)

    YANG Description: System-vendor assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replaceable unit)
    """
    return self.__system_vendor_part_no
      
  def _set_system_vendor_part_no(self, v, load=False):
    """
    Setter method for system_vendor_part_no, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/system_vendor_part_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_vendor_part_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_vendor_part_no() directly.

    YANG Description: System-vendor assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replaceable unit)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="system-vendor-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_vendor_part_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__system_vendor_part_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_vendor_part_no(self):
    self.__system_vendor_part_no = YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_mfg_name(self):
    """
    Getter method for mfg_name, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/mfg_name (string)

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    return self.__mfg_name
      
  def _set_mfg_name(self, v, load=False):
    """
    Setter method for mfg_name, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/mfg_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_name() directly.

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__mfg_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_name(self):
    self.__mfg_name = YANGDynClass(base=str, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_mfg_part_no(self):
    """
    Getter method for mfg_part_no, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/mfg_part_no (string)

    YANG Description: Transceiver manufacturer assigned part number for the component.
    """
    return self.__mfg_part_no
      
  def _set_mfg_part_no(self, v, load=False):
    """
    Setter method for mfg_part_no, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/mfg_part_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_part_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_part_no() directly.

    YANG Description: Transceiver manufacturer assigned part number for the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="mfg-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_part_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="mfg-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__mfg_part_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_part_no(self):
    self.__mfg_part_no = YANGDynClass(base=str, is_leaf=True, yang_name="mfg-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_hardware_version(self):
    """
    Getter method for hardware_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/hardware_version (string)

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    return self.__hardware_version
      
  def _set_hardware_version(self, v, load=False):
    """
    Setter method for hardware_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/hardware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware_version() directly.

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__hardware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware_version(self):
    self.__hardware_version = YANGDynClass(base=str, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_firmware_version(self):
    """
    Getter method for firmware_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/firmware_version (string)

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    return self.__firmware_version
      
  def _set_firmware_version(self, v, load=False):
    """
    Setter method for firmware_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/firmware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firmware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firmware_version() directly.

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firmware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__firmware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firmware_version(self):
    self.__firmware_version = YANGDynClass(base=str, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/software_version (string)

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    return self.__software_version
      
  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=str, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_clei_code(self):
    """
    Getter method for clei_code, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/clei_code (string)

    YANG Description: Common Language Equipment Identifier (CLEI) code of the
component.  This should be present in particular if the
component is also an FRU (field replaceable unit)
    """
    return self.__clei_code
      
  def _set_clei_code(self, v, load=False):
    """
    Setter method for clei_code, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/clei_code (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clei_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clei_code() directly.

    YANG Description: Common Language Equipment Identifier (CLEI) code of the
component.  This should be present in particular if the
component is also an FRU (field replaceable unit)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="clei-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clei_code must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="clei-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__clei_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clei_code(self):
    self.__clei_code = YANGDynClass(base=str, is_leaf=True, yang_name="clei-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)

  component_descriptor_id = __builtin__.property(_get_component_descriptor_id)
  system_vendor_name = __builtin__.property(_get_system_vendor_name)
  system_vendor_part_no = __builtin__.property(_get_system_vendor_part_no)
  mfg_name = __builtin__.property(_get_mfg_name)
  mfg_part_no = __builtin__.property(_get_mfg_part_no)
  hardware_version = __builtin__.property(_get_hardware_version)
  firmware_version = __builtin__.property(_get_firmware_version)
  software_version = __builtin__.property(_get_software_version)
  clei_code = __builtin__.property(_get_clei_code)


  _pyangbind_elements = OrderedDict([('component_descriptor_id', component_descriptor_id), ('system_vendor_name', system_vendor_name), ('system_vendor_part_no', system_vendor_part_no), ('mfg_name', mfg_name), ('mfg_part_no', mfg_part_no), ('hardware_version', hardware_version), ('firmware_version', firmware_version), ('software_version', software_version), ('clei_code', clei_code), ])


class state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-terminal-device-properties - based on the path /linecard-descriptors/linecard-descriptor/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Static features or properties which characterize the
component descriptor.
  """
  __slots__ = ('_path_helper', '_extmethods', '__component_descriptor_id','__system_vendor_name','__system_vendor_part_no','__mfg_name','__mfg_part_no','__hardware_version','__firmware_version','__software_version','__clei_code',)

  _yang_name = 'state'
  _yang_namespace = 'http://openconfig.net/yang/openconfig-terminal-device-properties'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__component_descriptor_id = YANGDynClass(base=str, is_leaf=True, yang_name="component-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__system_vendor_name = YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__system_vendor_part_no = YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__mfg_name = YANGDynClass(base=str, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__mfg_part_no = YANGDynClass(base=str, is_leaf=True, yang_name="mfg-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__hardware_version = YANGDynClass(base=str, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__firmware_version = YANGDynClass(base=str, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__software_version = YANGDynClass(base=str, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    self.__clei_code = YANGDynClass(base=str, is_leaf=True, yang_name="clei-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['linecard-descriptors', 'linecard-descriptor', 'state']

  def _get_component_descriptor_id(self):
    """
    Getter method for component_descriptor_id, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/component_descriptor_id (string)

    YANG Description: Unique identifier assigned by the system vendor for the
component descriptor.
    """
    return self.__component_descriptor_id
      
  def _set_component_descriptor_id(self, v, load=False):
    """
    Setter method for component_descriptor_id, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/component_descriptor_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component_descriptor_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component_descriptor_id() directly.

    YANG Description: Unique identifier assigned by the system vendor for the
component descriptor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="component-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component_descriptor_id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="component-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__component_descriptor_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component_descriptor_id(self):
    self.__component_descriptor_id = YANGDynClass(base=str, is_leaf=True, yang_name="component-descriptor-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_system_vendor_name(self):
    """
    Getter method for system_vendor_name, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/system_vendor_name (string)

    YANG Description: System vendor company name
    """
    return self.__system_vendor_name
      
  def _set_system_vendor_name(self, v, load=False):
    """
    Setter method for system_vendor_name, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/system_vendor_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_vendor_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_vendor_name() directly.

    YANG Description: System vendor company name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="system-vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_vendor_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__system_vendor_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_vendor_name(self):
    self.__system_vendor_name = YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_system_vendor_part_no(self):
    """
    Getter method for system_vendor_part_no, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/system_vendor_part_no (string)

    YANG Description: System-vendor assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replaceable unit)
    """
    return self.__system_vendor_part_no
      
  def _set_system_vendor_part_no(self, v, load=False):
    """
    Setter method for system_vendor_part_no, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/system_vendor_part_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_system_vendor_part_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_system_vendor_part_no() directly.

    YANG Description: System-vendor assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replaceable unit)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="system-vendor-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """system_vendor_part_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__system_vendor_part_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_system_vendor_part_no(self):
    self.__system_vendor_part_no = YANGDynClass(base=str, is_leaf=True, yang_name="system-vendor-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_mfg_name(self):
    """
    Getter method for mfg_name, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/mfg_name (string)

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    return self.__mfg_name
      
  def _set_mfg_name(self, v, load=False):
    """
    Setter method for mfg_name, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/mfg_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_name() directly.

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__mfg_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_name(self):
    self.__mfg_name = YANGDynClass(base=str, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_mfg_part_no(self):
    """
    Getter method for mfg_part_no, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/mfg_part_no (string)

    YANG Description: Transceiver manufacturer assigned part number for the component.
    """
    return self.__mfg_part_no
      
  def _set_mfg_part_no(self, v, load=False):
    """
    Setter method for mfg_part_no, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/mfg_part_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_part_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_part_no() directly.

    YANG Description: Transceiver manufacturer assigned part number for the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="mfg-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_part_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="mfg-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__mfg_part_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_part_no(self):
    self.__mfg_part_no = YANGDynClass(base=str, is_leaf=True, yang_name="mfg-part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_hardware_version(self):
    """
    Getter method for hardware_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/hardware_version (string)

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    return self.__hardware_version
      
  def _set_hardware_version(self, v, load=False):
    """
    Setter method for hardware_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/hardware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware_version() directly.

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__hardware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware_version(self):
    self.__hardware_version = YANGDynClass(base=str, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_firmware_version(self):
    """
    Getter method for firmware_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/firmware_version (string)

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    return self.__firmware_version
      
  def _set_firmware_version(self, v, load=False):
    """
    Setter method for firmware_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/firmware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firmware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firmware_version() directly.

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firmware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__firmware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firmware_version(self):
    self.__firmware_version = YANGDynClass(base=str, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/software_version (string)

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    return self.__software_version
      
  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=str, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)


  def _get_clei_code(self):
    """
    Getter method for clei_code, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/clei_code (string)

    YANG Description: Common Language Equipment Identifier (CLEI) code of the
component.  This should be present in particular if the
component is also an FRU (field replaceable unit)
    """
    return self.__clei_code
      
  def _set_clei_code(self, v, load=False):
    """
    Setter method for clei_code, mapped from YANG variable /linecard_descriptors/linecard_descriptor/state/clei_code (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clei_code is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clei_code() directly.

    YANG Description: Common Language Equipment Identifier (CLEI) code of the
component.  This should be present in particular if the
component is also an FRU (field replaceable unit)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="clei-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clei_code must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="clei-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)""",
        })

    self.__clei_code = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clei_code(self):
    self.__clei_code = YANGDynClass(base=str, is_leaf=True, yang_name="clei-code", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/openconfig-terminal-device-properties', defining_module='openconfig-terminal-device-properties', yang_type='string', is_config=False)

  component_descriptor_id = __builtin__.property(_get_component_descriptor_id)
  system_vendor_name = __builtin__.property(_get_system_vendor_name)
  system_vendor_part_no = __builtin__.property(_get_system_vendor_part_no)
  mfg_name = __builtin__.property(_get_mfg_name)
  mfg_part_no = __builtin__.property(_get_mfg_part_no)
  hardware_version = __builtin__.property(_get_hardware_version)
  firmware_version = __builtin__.property(_get_firmware_version)
  software_version = __builtin__.property(_get_software_version)
  clei_code = __builtin__.property(_get_clei_code)


  _pyangbind_elements = OrderedDict([('component_descriptor_id', component_descriptor_id), ('system_vendor_name', system_vendor_name), ('system_vendor_part_no', system_vendor_part_no), ('mfg_name', mfg_name), ('mfg_part_no', mfg_part_no), ('hardware_version', hardware_version), ('firmware_version', firmware_version), ('software_version', software_version), ('clei_code', clei_code), ])


