# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bfd - based on the path /bfd/interfaces/interface/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for BFD on the specified
interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__enabled','__local_address','__desired_minimum_tx_interval','__required_minimum_receive','__detection_multiplier','__enable_per_member_link',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/bfd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-if:interface-id', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-inet:ip-address', is_config=True)
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint8', is_config=True)
    self.__enable_per_member_link = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-per-member-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bfd', 'interfaces', 'interface', 'config']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /bfd/interfaces/interface/config/id (oc-if:interface-id)

    YANG Description: A unique identifier for the interface.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /bfd/interfaces/interface/config/id (oc-if:interface-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A unique identifier for the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-if:interface-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with oc-if:interface-id""",
          'defined-type': "oc-if:interface-id",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-if:interface-id', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-if:interface-id', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /bfd/interfaces/interface/config/enabled (boolean)

    YANG Description: When this leaf is set to true then the BFD session is enabled
on the specified interface - if it is set to false, it is
administratively disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /bfd/interfaces/interface/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When this leaf is set to true then the BFD session is enabled
on the specified interface - if it is set to false, it is
administratively disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /bfd/interfaces/interface/config/local_address (oc-inet:ip-address)

    YANG Description: The source IP address to be used for BFD sessions over this
interface.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /bfd/interfaces/interface/config/local_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: The source IP address to be used for BFD sessions over this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-inet:ip-address', is_config=True)


  def _get_desired_minimum_tx_interval(self):
    """
    Getter method for desired_minimum_tx_interval, mapped from YANG variable /bfd/interfaces/interface/config/desired_minimum_tx_interval (uint32)

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    return self.__desired_minimum_tx_interval
      
  def _set_desired_minimum_tx_interval(self, v, load=False):
    """
    Setter method for desired_minimum_tx_interval, mapped from YANG variable /bfd/interfaces/interface/config/desired_minimum_tx_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_desired_minimum_tx_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_desired_minimum_tx_interval() directly.

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """desired_minimum_tx_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)""",
        })

    self.__desired_minimum_tx_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_desired_minimum_tx_interval(self):
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)


  def _get_required_minimum_receive(self):
    """
    Getter method for required_minimum_receive, mapped from YANG variable /bfd/interfaces/interface/config/required_minimum_receive (uint32)

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    return self.__required_minimum_receive
      
  def _set_required_minimum_receive(self, v, load=False):
    """
    Setter method for required_minimum_receive, mapped from YANG variable /bfd/interfaces/interface/config/required_minimum_receive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required_minimum_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required_minimum_receive() directly.

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required_minimum_receive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)""",
        })

    self.__required_minimum_receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required_minimum_receive(self):
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)


  def _get_detection_multiplier(self):
    """
    Getter method for detection_multiplier, mapped from YANG variable /bfd/interfaces/interface/config/detection_multiplier (uint8)

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    return self.__detection_multiplier
      
  def _set_detection_multiplier(self, v, load=False):
    """
    Setter method for detection_multiplier, mapped from YANG variable /bfd/interfaces/interface/config/detection_multiplier (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detection_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detection_multiplier() directly.

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detection_multiplier must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint8', is_config=True)""",
        })

    self.__detection_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detection_multiplier(self):
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint8', is_config=True)


  def _get_enable_per_member_link(self):
    """
    Getter method for enable_per_member_link, mapped from YANG variable /bfd/interfaces/interface/config/enable_per_member_link (boolean)

    YANG Description: When this leaf is set to true - BFD will be enabled on
each member interface of the aggregated Ethernet bundle.
    """
    return self.__enable_per_member_link
      
  def _set_enable_per_member_link(self, v, load=False):
    """
    Setter method for enable_per_member_link, mapped from YANG variable /bfd/interfaces/interface/config/enable_per_member_link (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_per_member_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_per_member_link() directly.

    YANG Description: When this leaf is set to true - BFD will be enabled on
each member interface of the aggregated Ethernet bundle.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-per-member-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_per_member_link must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-per-member-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)""",
        })

    self.__enable_per_member_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_per_member_link(self):
    self.__enable_per_member_link = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-per-member-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  local_address = __builtin__.property(_get_local_address, _set_local_address)
  desired_minimum_tx_interval = __builtin__.property(_get_desired_minimum_tx_interval, _set_desired_minimum_tx_interval)
  required_minimum_receive = __builtin__.property(_get_required_minimum_receive, _set_required_minimum_receive)
  detection_multiplier = __builtin__.property(_get_detection_multiplier, _set_detection_multiplier)
  enable_per_member_link = __builtin__.property(_get_enable_per_member_link, _set_enable_per_member_link)


  _pyangbind_elements = OrderedDict([('id', id), ('enabled', enabled), ('local_address', local_address), ('desired_minimum_tx_interval', desired_minimum_tx_interval), ('required_minimum_receive', required_minimum_receive), ('detection_multiplier', detection_multiplier), ('enable_per_member_link', enable_per_member_link), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-bfd - based on the path /bfd/interfaces/interface/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for BFD on the specified
interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__enabled','__local_address','__desired_minimum_tx_interval','__required_minimum_receive','__detection_multiplier','__enable_per_member_link',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/bfd'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-if:interface-id', is_config=True)
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-inet:ip-address', is_config=True)
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint8', is_config=True)
    self.__enable_per_member_link = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-per-member-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bfd', 'interfaces', 'interface', 'config']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /bfd/interfaces/interface/config/id (oc-if:interface-id)

    YANG Description: A unique identifier for the interface.
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /bfd/interfaces/interface/config/id (oc-if:interface-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A unique identifier for the interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-if:interface-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with oc-if:interface-id""",
          'defined-type': "oc-if:interface-id",
          'generated-type': """YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-if:interface-id', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=str, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-if:interface-id', is_config=True)


  def _get_enabled(self):
    """
    Getter method for enabled, mapped from YANG variable /bfd/interfaces/interface/config/enabled (boolean)

    YANG Description: When this leaf is set to true then the BFD session is enabled
on the specified interface - if it is set to false, it is
administratively disabled.
    """
    return self.__enabled
      
  def _set_enabled(self, v, load=False):
    """
    Setter method for enabled, mapped from YANG variable /bfd/interfaces/interface/config/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: When this leaf is set to true then the BFD session is enabled
on the specified interface - if it is set to false, it is
administratively disabled.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enabled must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)""",
        })

    self.__enabled = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enabled(self):
    self.__enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)


  def _get_local_address(self):
    """
    Getter method for local_address, mapped from YANG variable /bfd/interfaces/interface/config/local_address (oc-inet:ip-address)

    YANG Description: The source IP address to be used for BFD sessions over this
interface.
    """
    return self.__local_address
      
  def _set_local_address(self, v, load=False):
    """
    Setter method for local_address, mapped from YANG variable /bfd/interfaces/interface/config/local_address (oc-inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_address() directly.

    YANG Description: The source IP address to be used for BFD sessions over this
interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """local_address must be of a type compatible with oc-inet:ip-address""",
          'defined-type': "oc-inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-inet:ip-address', is_config=True)""",
        })

    self.__local_address = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_local_address(self):
    self.__local_address = YANGDynClass(base=[RestrictedClassType(base_type=str, restriction_dict={'pattern': '([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){3}'}),RestrictedClassType(base_type=str, restriction_dict={'pattern': '(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))'}),], is_leaf=True, yang_name="local-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='oc-inet:ip-address', is_config=True)


  def _get_desired_minimum_tx_interval(self):
    """
    Getter method for desired_minimum_tx_interval, mapped from YANG variable /bfd/interfaces/interface/config/desired_minimum_tx_interval (uint32)

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    return self.__desired_minimum_tx_interval
      
  def _set_desired_minimum_tx_interval(self, v, load=False):
    """
    Setter method for desired_minimum_tx_interval, mapped from YANG variable /bfd/interfaces/interface/config/desired_minimum_tx_interval (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_desired_minimum_tx_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_desired_minimum_tx_interval() directly.

    YANG Description: The minimum interval between transmission of BFD control
packets that the operator desires. This value is advertised to
the peer, however the actual interval used is specified by
taking the maximum of desired-minimum-tx-interval and the
value of the remote required-minimum-receive interval value.
This value is specified as an integer number of microseconds.
The value 0 is reserved and cannot be used.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """desired_minimum_tx_interval must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)""",
        })

    self.__desired_minimum_tx_interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_desired_minimum_tx_interval(self):
    self.__desired_minimum_tx_interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="desired-minimum-tx-interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)


  def _get_required_minimum_receive(self):
    """
    Getter method for required_minimum_receive, mapped from YANG variable /bfd/interfaces/interface/config/required_minimum_receive (uint32)

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    return self.__required_minimum_receive
      
  def _set_required_minimum_receive(self, v, load=False):
    """
    Setter method for required_minimum_receive, mapped from YANG variable /bfd/interfaces/interface/config/required_minimum_receive (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required_minimum_receive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required_minimum_receive() directly.

    YANG Description: The minimum interval between received BFD control packets that
this system should support. This value is advertised to the
remote peer to indicate the maximum frequency (i.e., minimum
inter-packet interval) between BFD control packets that is
acceptable to the local system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """required_minimum_receive must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)""",
        })

    self.__required_minimum_receive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_required_minimum_receive(self):
    self.__required_minimum_receive = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="required-minimum-receive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint32', is_config=True)


  def _get_detection_multiplier(self):
    """
    Getter method for detection_multiplier, mapped from YANG variable /bfd/interfaces/interface/config/detection_multiplier (uint8)

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    return self.__detection_multiplier
      
  def _set_detection_multiplier(self, v, load=False):
    """
    Setter method for detection_multiplier, mapped from YANG variable /bfd/interfaces/interface/config/detection_multiplier (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_detection_multiplier is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_detection_multiplier() directly.

    YANG Description: The number of packets that must be missed to declare this
session as down. The detection interval for the BFD session
is calculated by multiplying the value of the negotiated
transmission interval by this value.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint8', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """detection_multiplier must be of a type compatible with uint8""",
          'defined-type': "uint8",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint8', is_config=True)""",
        })

    self.__detection_multiplier = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_detection_multiplier(self):
    self.__detection_multiplier = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="detection-multiplier", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='uint8', is_config=True)


  def _get_enable_per_member_link(self):
    """
    Getter method for enable_per_member_link, mapped from YANG variable /bfd/interfaces/interface/config/enable_per_member_link (boolean)

    YANG Description: When this leaf is set to true - BFD will be enabled on
each member interface of the aggregated Ethernet bundle.
    """
    return self.__enable_per_member_link
      
  def _set_enable_per_member_link(self, v, load=False):
    """
    Setter method for enable_per_member_link, mapped from YANG variable /bfd/interfaces/interface/config/enable_per_member_link (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enable_per_member_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enable_per_member_link() directly.

    YANG Description: When this leaf is set to true - BFD will be enabled on
each member interface of the aggregated Ethernet bundle.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-per-member-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """enable_per_member_link must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-per-member-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)""",
        })

    self.__enable_per_member_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_enable_per_member_link(self):
    self.__enable_per_member_link = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="enable-per-member-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/bfd', defining_module='openconfig-bfd', yang_type='boolean', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  enabled = __builtin__.property(_get_enabled, _set_enabled)
  local_address = __builtin__.property(_get_local_address, _set_local_address)
  desired_minimum_tx_interval = __builtin__.property(_get_desired_minimum_tx_interval, _set_desired_minimum_tx_interval)
  required_minimum_receive = __builtin__.property(_get_required_minimum_receive, _set_required_minimum_receive)
  detection_multiplier = __builtin__.property(_get_detection_multiplier, _set_detection_multiplier)
  enable_per_member_link = __builtin__.property(_get_enable_per_member_link, _set_enable_per_member_link)


  _pyangbind_elements = OrderedDict([('id', id), ('enabled', enabled), ('local_address', local_address), ('desired_minimum_tx_interval', desired_minimum_tx_interval), ('required_minimum_receive', required_minimum_receive), ('detection_multiplier', detection_multiplier), ('enable_per_member_link', enable_per_member_link), ])


