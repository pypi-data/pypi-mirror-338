# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments/ethernet-segment/df-election/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the Designated forwarding Election
  """
  __slots__ = ('_path_helper', '_extmethods', '__df_election_method','__preference','__revertive','__election_wait_time',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__df_election_method = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)
    self.__revertive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)
    self.__election_wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments', 'ethernet-segment', 'df-election', 'config']

  def _get_df_election_method(self):
    """
    Getter method for df_election_method, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/df_election_method (enumeration)

    YANG Description: Select the Designated Forwarder Election (DF) election method
    """
    return self.__df_election_method
      
  def _set_df_election_method(self, v, load=False):
    """
    Setter method for df_election_method, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/df_election_method (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df_election_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df_election_method() directly.

    YANG Description: Select the Designated Forwarder Election (DF) election method
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """df_election_method must be of a type compatible with enumeration""",
          'defined-type': "openconfig-ethernet-segments:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)""",
        })

    self.__df_election_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_df_election_method(self):
    self.__df_election_method = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)


  def _get_preference(self):
    """
    Getter method for preference, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/preference (uint16)

    YANG Description: Defines a 2-octet value that indicates the PE
preference to become the DF in the Ethernet-Segment.
    """
    return self.__preference
      
  def _set_preference(self, v, load=False):
    """
    Setter method for preference, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/preference (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preference() directly.

    YANG Description: Defines a 2-octet value that indicates the PE
preference to become the DF in the Ethernet-Segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preference must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)""",
        })

    self.__preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preference(self):
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/revertive (boolean)

    YANG Description: The 'preempt' or 'revertive' behavior. This option will allow a
non-revertive behavior in the DF election.
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: The 'preempt' or 'revertive' behavior. This option will allow a
non-revertive behavior in the DF election.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)


  def _get_election_wait_time(self):
    """
    Getter method for election_wait_time, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/election_wait_time (uint32)

    YANG Description: Designated Forwarder Election wait-time. When the DF timer expires,
the PE device selects the DF based on the highest preference value
    """
    return self.__election_wait_time
      
  def _set_election_wait_time(self, v, load=False):
    """
    Setter method for election_wait_time, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/election_wait_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_election_wait_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_election_wait_time() directly.

    YANG Description: Designated Forwarder Election wait-time. When the DF timer expires,
the PE device selects the DF based on the highest preference value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """election_wait_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)""",
        })

    self.__election_wait_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_election_wait_time(self):
    self.__election_wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)

  df_election_method = __builtin__.property(_get_df_election_method, _set_df_election_method)
  preference = __builtin__.property(_get_preference, _set_preference)
  revertive = __builtin__.property(_get_revertive, _set_revertive)
  election_wait_time = __builtin__.property(_get_election_wait_time, _set_election_wait_time)


  _pyangbind_elements = OrderedDict([('df_election_method', df_election_method), ('preference', preference), ('revertive', revertive), ('election_wait_time', election_wait_time), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-ethernet-segments - based on the path /ethernet-segments/ethernet-segment/df-election/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the Designated forwarding Election
  """
  __slots__ = ('_path_helper', '_extmethods', '__df_election_method','__preference','__revertive','__election_wait_time',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/ethernet-segments'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__df_election_method = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)
    self.__revertive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)
    self.__election_wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['ethernet-segments', 'ethernet-segment', 'df-election', 'config']

  def _get_df_election_method(self):
    """
    Getter method for df_election_method, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/df_election_method (enumeration)

    YANG Description: Select the Designated Forwarder Election (DF) election method
    """
    return self.__df_election_method
      
  def _set_df_election_method(self, v, load=False):
    """
    Setter method for df_election_method, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/df_election_method (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df_election_method is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df_election_method() directly.

    YANG Description: Select the Designated Forwarder Election (DF) election method
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """df_election_method must be of a type compatible with enumeration""",
          'defined-type': "openconfig-ethernet-segments:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)""",
        })

    self.__df_election_method = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_df_election_method(self):
    self.__df_election_method = YANGDynClass(base=RestrictedClassType(base_type=str,                                     restriction_type="dict_key",                                     restriction_arg={'DEFAULT': {'value': 0}, 'HIGHEST_RANDOM_WEIGHT': {'value': 1}, 'PREFERENCE': {'value': 2}},), is_leaf=True, yang_name="df-election-method", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='enumeration', is_config=True)


  def _get_preference(self):
    """
    Getter method for preference, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/preference (uint16)

    YANG Description: Defines a 2-octet value that indicates the PE
preference to become the DF in the Ethernet-Segment.
    """
    return self.__preference
      
  def _set_preference(self, v, load=False):
    """
    Setter method for preference, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/preference (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preference() directly.

    YANG Description: Defines a 2-octet value that indicates the PE
preference to become the DF in the Ethernet-Segment.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """preference must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)""",
        })

    self.__preference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_preference(self):
    self.__preference = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="preference", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint16', is_config=True)


  def _get_revertive(self):
    """
    Getter method for revertive, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/revertive (boolean)

    YANG Description: The 'preempt' or 'revertive' behavior. This option will allow a
non-revertive behavior in the DF election.
    """
    return self.__revertive
      
  def _set_revertive(self, v, load=False):
    """
    Setter method for revertive, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/revertive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_revertive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_revertive() directly.

    YANG Description: The 'preempt' or 'revertive' behavior. This option will allow a
non-revertive behavior in the DF election.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """revertive must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)""",
        })

    self.__revertive = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_revertive(self):
    self.__revertive = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="revertive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='boolean', is_config=True)


  def _get_election_wait_time(self):
    """
    Getter method for election_wait_time, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/election_wait_time (uint32)

    YANG Description: Designated Forwarder Election wait-time. When the DF timer expires,
the PE device selects the DF based on the highest preference value
    """
    return self.__election_wait_time
      
  def _set_election_wait_time(self, v, load=False):
    """
    Setter method for election_wait_time, mapped from YANG variable /ethernet_segments/ethernet_segment/df_election/config/election_wait_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_election_wait_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_election_wait_time() directly.

    YANG Description: Designated Forwarder Election wait-time. When the DF timer expires,
the PE device selects the DF based on the highest preference value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """election_wait_time must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)""",
        })

    self.__election_wait_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_election_wait_time(self):
    self.__election_wait_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="election-wait-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/ethernet-segments', defining_module='openconfig-ethernet-segments', yang_type='uint32', is_config=True)

  df_election_method = __builtin__.property(_get_df_election_method, _set_df_election_method)
  preference = __builtin__.property(_get_preference, _set_preference)
  revertive = __builtin__.property(_get_revertive, _set_revertive)
  election_wait_time = __builtin__.property(_get_election_wait_time, _set_election_wait_time)


  _pyangbind_elements = OrderedDict([('df_election_method', df_election_method), ('preference', preference), ('revertive', revertive), ('election_wait_time', election_wait_time), ])


