# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.yangtypes import YANGBinary
from pyangbind.lib.yangtypes import YANGBitsType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal

import builtins as __builtin__
long = int
class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system - based on the path /system/hashing/hashing-policies/hashing-policy/hash-field-modes/ipv6/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurable data at the hashing
inputs level for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__src_addr','__dst_addr','__src_port','__dst_port','__flow_label',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/system'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__src_addr = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    self.__dst_addr = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    self.__src_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    self.__dst_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    self.__flow_label = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['system', 'hashing', 'hashing-policies', 'hashing-policy', 'hash-field-modes', 'ipv6', 'config']

  def _get_src_addr(self):
    """
    Getter method for src_addr, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/src_addr (boolean)

    YANG Description: Use the source address in the calculation of the hash.
    """
    return self.__src_addr
      
  def _set_src_addr(self, v, load=False):
    """
    Setter method for src_addr, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/src_addr (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_addr() directly.

    YANG Description: Use the source address in the calculation of the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_addr must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__src_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_addr(self):
    self.__src_addr = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)


  def _get_dst_addr(self):
    """
    Getter method for dst_addr, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/dst_addr (boolean)

    YANG Description: Use the destination address in the calculation of the hash.
    """
    return self.__dst_addr
      
  def _set_dst_addr(self, v, load=False):
    """
    Setter method for dst_addr, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/dst_addr (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_addr() directly.

    YANG Description: Use the destination address in the calculation of the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dst-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_addr must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__dst_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_addr(self):
    self.__dst_addr = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)


  def _get_src_port(self):
    """
    Getter method for src_port, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/src_port (boolean)

    YANG Description: Use the source port from the transport header in the calculation
of the hash.
    """
    return self.__src_port
      
  def _set_src_port(self, v, load=False):
    """
    Setter method for src_port, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/src_port (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_port() directly.

    YANG Description: Use the source port from the transport header in the calculation
of the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_port must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__src_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_port(self):
    self.__src_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)


  def _get_dst_port(self):
    """
    Getter method for dst_port, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/dst_port (boolean)

    YANG Description: Use the destination port from the transport header in the
calculation of the hash.
    """
    return self.__dst_port
      
  def _set_dst_port(self, v, load=False):
    """
    Setter method for dst_port, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/dst_port (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_port() directly.

    YANG Description: Use the destination port from the transport header in the
calculation of the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_port must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__dst_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_port(self):
    self.__dst_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)


  def _get_flow_label(self):
    """
    Getter method for flow_label, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/flow_label (boolean)

    YANG Description: Use the flow label in the IPv6 header
to calculate the hash.
    """
    return self.__flow_label
      
  def _set_flow_label(self, v, load=False):
    """
    Setter method for flow_label, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/flow_label (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_label() directly.

    YANG Description: Use the flow label in the IPv6 header
to calculate the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="flow-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_label must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__flow_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_label(self):
    self.__flow_label = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)

  src_addr = __builtin__.property(_get_src_addr, _set_src_addr)
  dst_addr = __builtin__.property(_get_dst_addr, _set_dst_addr)
  src_port = __builtin__.property(_get_src_port, _set_src_port)
  dst_port = __builtin__.property(_get_dst_port, _set_dst_port)
  flow_label = __builtin__.property(_get_flow_label, _set_flow_label)


  _pyangbind_elements = OrderedDict([('src_addr', src_addr), ('dst_addr', dst_addr), ('src_port', src_port), ('dst_port', dst_port), ('flow_label', flow_label), ])


class config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-system - based on the path /system/hashing/hashing-policies/hashing-policy/hash-field-modes/ipv6/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configurable data at the hashing
inputs level for IPv6.
  """
  __slots__ = ('_path_helper', '_extmethods', '__src_addr','__dst_addr','__src_port','__dst_port','__flow_label',)

  _yang_name = 'config'
  _yang_namespace = 'http://openconfig.net/yang/system'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__src_addr = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    self.__dst_addr = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    self.__src_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    self.__dst_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    self.__flow_label = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['system', 'hashing', 'hashing-policies', 'hashing-policy', 'hash-field-modes', 'ipv6', 'config']

  def _get_src_addr(self):
    """
    Getter method for src_addr, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/src_addr (boolean)

    YANG Description: Use the source address in the calculation of the hash.
    """
    return self.__src_addr
      
  def _set_src_addr(self, v, load=False):
    """
    Setter method for src_addr, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/src_addr (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_addr() directly.

    YANG Description: Use the source address in the calculation of the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_addr must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__src_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_addr(self):
    self.__src_addr = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)


  def _get_dst_addr(self):
    """
    Getter method for dst_addr, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/dst_addr (boolean)

    YANG Description: Use the destination address in the calculation of the hash.
    """
    return self.__dst_addr
      
  def _set_dst_addr(self, v, load=False):
    """
    Setter method for dst_addr, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/dst_addr (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_addr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_addr() directly.

    YANG Description: Use the destination address in the calculation of the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dst-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_addr must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__dst_addr = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_addr(self):
    self.__dst_addr = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-addr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)


  def _get_src_port(self):
    """
    Getter method for src_port, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/src_port (boolean)

    YANG Description: Use the source port from the transport header in the calculation
of the hash.
    """
    return self.__src_port
      
  def _set_src_port(self, v, load=False):
    """
    Setter method for src_port, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/src_port (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_src_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_src_port() directly.

    YANG Description: Use the source port from the transport header in the calculation
of the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """src_port must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__src_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_src_port(self):
    self.__src_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="src-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)


  def _get_dst_port(self):
    """
    Getter method for dst_port, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/dst_port (boolean)

    YANG Description: Use the destination port from the transport header in the
calculation of the hash.
    """
    return self.__dst_port
      
  def _set_dst_port(self, v, load=False):
    """
    Setter method for dst_port, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/dst_port (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dst_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dst_port() directly.

    YANG Description: Use the destination port from the transport header in the
calculation of the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dst_port must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__dst_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dst_port(self):
    self.__dst_port = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="dst-port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)


  def _get_flow_label(self):
    """
    Getter method for flow_label, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/flow_label (boolean)

    YANG Description: Use the flow label in the IPv6 header
to calculate the hash.
    """
    return self.__flow_label
      
  def _set_flow_label(self, v, load=False):
    """
    Setter method for flow_label, mapped from YANG variable /system/hashing/hashing_policies/hashing_policy/hash_field_modes/ipv6/config/flow_label (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_label() directly.

    YANG Description: Use the flow label in the IPv6 header
to calculate the hash.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="flow-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """flow_label must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)""",
        })

    self.__flow_label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_flow_label(self):
    self.__flow_label = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="flow-label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/hashing', defining_module='openconfig-hashing', yang_type='boolean', is_config=True)

  src_addr = __builtin__.property(_get_src_addr, _set_src_addr)
  dst_addr = __builtin__.property(_get_dst_addr, _set_dst_addr)
  src_port = __builtin__.property(_get_src_port, _set_src_port)
  dst_port = __builtin__.property(_get_dst_port, _set_dst_port)
  flow_label = __builtin__.property(_get_flow_label, _set_flow_label)


  _pyangbind_elements = OrderedDict([('src_addr', src_addr), ('dst_addr', dst_addr), ('src_port', src_port), ('dst_port', dst_port), ('flow_label', flow_label), ])


