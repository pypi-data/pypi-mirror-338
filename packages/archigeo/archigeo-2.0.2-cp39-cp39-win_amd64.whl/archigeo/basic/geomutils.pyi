from _typeshed import Incomplete

def near(a, b, max_gap): ...
def near_l1(lsta, lstb, max_gap): ...
def near_l2(lsta, lstb, max_gap): ...
def bubble_sort(lst0): ...
def list_min(xs): ...
def list_max(xs): ...
def list_max_index(xs): ...
def index_bubble_sort(lst0, indexs0): ...
def avg_near_x(xs, tole: int = 1): ...
def avg_near_xg(xs, tole: int = 1): ...
def list2d_len(xss): ...
def list_sum(xs): ...
def list_avg(xs): ...
def in_list(x0, xs): ...
def list_2to1(xss): ...
def index_1to2(index, xss): ...
def get_remainder(x, unit, x_min: int = 0, count_limit: int = 100): ...
def get_congruence(x, unit, x_min: int = 0, x_max: int = 1, count_limit2: int = 100): ...
def randints(start, end, num, gap: int = 0): ...
def solve_linear_equation(ass, bs): ...
def pt2d(pt): ...
def pt3d(pt, z: int = 0): ...
def pts_mirror2quadrant(pts, quadrant: int = 1): ...
def pt_mirror2quadrant(pt, quadrant: int = 1): ...
def pt_add(pt1, pt2): ...
def pt_sub(pt1, pt2): ...
def pt_sum(pts): ...
def pt_wsum(pts, ws): ...
def vec_dot(vec1, vec2): ...
def vec_dot_angle(vec1, vec2): ...
def vec3d_cross(vec1, vec2): ...
def vec_mag(vec): ...
def vec_unitize(vec): ...
def angle2vec(angle, r: int = 1): ...
def vec2angle(vec): ...
def vec_proj(vec, dir_vec): ...
def vec_proj_length(vec, dir_vec): ...
def vec_proj_relative_length(vec, dir_unit_vec): ...
def pt_cloud(x_range=[0, 10, 1], y_range=[0, 10, 1], z_range=[0, 10, 1]): ...
def rangef(start, stop, step: int = 1): ...
def dimenset_conbine(dimensets): ...
def add_dimension(pt_cloud, dimenset): ...
def pts_c2o(pts): ...
def pts_o2c(pts): ...
def pts_changestart(pts, startpt): ...
def remove_repeat(pts): ...
def turnaround(pts): ...
def anti_clockwise(pts): ...
def poly_area(pts): ...
def pts_quadrant_select(pts, quadrants=[1, 2, 3, 4]): ...
def pts_quadrant_num(pts): ...
def orientation(pta, ptb, ptc): ...
def get_convex_attrs(pts): ...
def convex_hull(pts): ...
def pts2convexs(pts): ...
def is_convex(pts): ...
def average_pt(pts): ...
def scale_pt(pt, ratio, basept=[0, 0, 0]): ...
def scale_pts(pts, ratio, basept=[0, 0, 0]): ...
def rotate_pt(pt, angle, basept=[0, 0]): ...
def rotate_pts(pts, angle, basept=[0, 0]): ...
def rotate2onto(pts, max_angle: int = 60): ...
def offset_lineseg(pt1, pt2, dir: bool = True, distance: int = 0): ...
def offset_anglept(pt1, pt2, pt3, d, dir: bool = True): ...
def offset_anglept_byangle(pt1, pt2, angle, d, dir: bool = True): ...
def line_expr(pt, angle): ...
def line_expr_by2pt(pta, ptb): ...
def line_segment(startpt, endpt, rate): ...
def perpendicular_bisector(pta, ptb): ...
def line_intersection(abc1, abc2): ...
def line_segment_byline(startpt, endpt, abc): ...

class Circle:
    r: Incomplete
    cen: Incomplete
    def __init__(self, r, cen=[0, 0]) -> None: ...
    def angle2pt(self, angle): ...
    def cut(self, start_angle, end_angle): ...
    def cross_pts(self, other_cir): ...

class Arc:
    s3d: Incomplete
    startpt_s3d: Incomplete
    endpt_s3d: Incomplete
    start_tangent_angle: Incomplete
    end_tangent_angle: Incomplete
    isline: Incomplete
    cen_s3d: Incomplete
    r_s3d: Incomplete
    midpt_s3d: Incomplete
    def __init__(self, startpt_s3d, endpt_s3d, start_tangent_angle: Incomplete | None = None, space3d: Incomplete | None = None) -> None: ...
    def get_turning(self): ...
    startpt_world: Incomplete
    endpt_world: Incomplete
    midpt_world: Incomplete
    cen_world: Incomplete
    r_world: Incomplete
    def update_world_description(self) -> None: ...
    def radial_move(self, d, lefthand: bool = False) -> None: ...
    def move_under_s3d(self, move_vec) -> None: ...
    def change_s3d_keep_absoulute(self, new_s3d) -> None: ...
    def change_s3d_keep_relative(self, new_s3d) -> None: ...
    @classmethod
    def by3pt(cls, startpt, endpt, pt_on_arc) -> None: ...

class Arc2d3pt(Arc):
    def __init__(self, startpt, endpt, pt_on_arc) -> None: ...

class ArcSeries:
    arcs: Incomplete
    def __init__(self, arcs=[]) -> None: ...
    def reinit_continuous(self) -> None: ...
    def update(self) -> None: ...
    def total_turning(self): ...
    def absolute_total_turning(self): ...
    def is_convex_curve(self): ...
    def radial_move(self, d, lefthand: bool = False) -> None: ...

class SmoothArcSeries(ArcSeries):
    s3d: Incomplete
    def __init__(self, pts, start_tangent_angle, s3d: Incomplete | None = None) -> None: ...
    def s3d_move(self, move_vec) -> None: ...
    @classmethod
    def generate_chamrect(cls, w, d, r, h: int = 0): ...
    @classmethod
    def generate_4cencir_byblendpt(cls, blendpt, k_angle, h: int = 0): ...
    @classmethod
    def generate_4cencir_byabk(cls, a, b, k_angle, h: int = 0): ...
    @classmethod
    def generate_4cencir_byabr(cls, a, b, r1, h: int = 0): ...
    @classmethod
    def generate_8cencir_byblendpt(cls, blendpt1, blendpt2, delta_angle, h: int = 0): ...
    @classmethod
    def generate_8cencir_byabr(cls, a, b, r1, r2, r3, h: int = 0): ...
    @classmethod
    def generate_8cencir_byab(cls, a, b, blendpt1, k_angle2, h: int = 0): ...
    @classmethod
    def generate_8cencir_byabrk(cls, a, b, r1, k_angle1, k_angle2, h: int = 0): ...

def plane_expr(pt, dir): ...
def plane_expr_by3pt(pt1, pt2, pt3): ...
def plane_expr_bylpt(line_expr, pt): ...
def plane_expr_by2angle(angle_xy, angle_z: int = 0, basept=[0, 0]): ...
def line3d_expr_by2pt(pt1, pt2): ...
def line_plane_intersection(line_expr, plane_expr): ...
def plane_plane_angle(plane1, plane2=[0, 0, 1, 0]): ...
def project_pt2plane(pt, plane): ...
def angle_360(angle): ...
def angle_180(angle): ...
def angle_9090(angle): ...
def angle_byline(line_expr): ...
def angle_by2pt(pta, ptb): ...
def angle_by2pt_360(pt0, pt): ...
def angle_by3pt_360(pta, ptb, ptb0): ...
def angle_by4pt_360(pta, ptb, pta0, ptb0): ...
def angle2xy(angle, r: int = 1): ...
def angle_sub(angle, angle0): ...
def vec_angle_sub(vec, vec0): ...
def line_buffer(pta, ptb, d): ...
def in_line_buffer(pt, abcs): ...
def pt_in_poly(pt, pts): ...
def distance_pt2pt(pt1, pt2): ...
def distance_pt2line(pt, line): ...
def distance_pt2plane(pt, plane): ...
def distance_pt2lineseg(pt, pta, ptb): ...
def distance_lineseg2lineseg(l1pta, l1ptb, l2pta, l2ptb): ...
def distance_pt2poly(pt, pts): ...
def pt_on_lineseg(pt, pta, ptb): ...
def project_pt2line(pt, line): ...
def poly_l_intersection(pts, abc): ...
def y2pp(pts, y): ...
def ys2pps(pts, ys): ...
def bound(xs): ...
def aabb(pts): ...
def aabb_3d(pts): ...
def obb_byangle(pts, angle): ...
def angles_of_convexedges(pts): ...
def angle_90(angle, angle_max: int = 60): ...
def obb_min(pts): ...
def replace_border(border, angle: Incomplete | None = None): ...
def border_processing(pts, id: str = 'noid'): ...
def arange(t, sum): ...
def arg(elements, n): ...
def arg_n12(elements_n1, elements_n2, sum_range, n12=[2, 3]): ...
def cbn(elements, n): ...
def cbn_n12(elements_n1, elements_n2, sum_range, n12=[2, 3]): ...
def sampling_lineseg(lineseg, unit, cut: int = 0): ...
def sampling_poly(poly_pts, unit, cut): ...

class Space_1d:
    basept: Incomplete
    dir_vec: Incomplete
    def __init__(self, basept_2d=[0, 0], pt2=[1, 0]) -> None: ...
    def line_expr(self): ...
    def decrease(self, pt): ...
    def increase(self, x): ...
    def move_pt(self, pt, delta_x): ...
    def pt_remainder(self, pt, modular_unit: int = 1, x_min: int = 0, count_limit: int = 100): ...
    def pt_reverse_remainder(self, pt, modular_unit: int = 1, x_max: int = 0, contain: bool = True): ...
    def get_pt_congruence(self, pt, unit, x_min: int = 0, x_max: int = 1): ...

class Space_2d:
    basept: Incomplete
    dir_vec: Incomplete
    def __init__(self, basept_2d=[0, 0, 0], dir=[0, 0, 1], xdir=[]) -> None: ...
    def plane_expr(self) -> None: ...

class Space3d:
    basept: Incomplete
    scale: Incomplete
    x_dir_unit: Incomplete
    y_dir_unit: Incomplete
    z_dir_unit: Incomplete
    dirs: Incomplete
    def __init__(self, basept=[0, 0, 0], x_dir=[1, 0, 0], y_dir_maybe=[0, 1, 0], scale: int = 1) -> None: ...
    def update(self) -> None: ...
    def plane_expr(self): ...
    def pt_relative_describe(self, pt_world): ...
    def vec_relative_describe(self, vec_world): ...
    def move(self, move_vec) -> None: ...
    def pt_absolute_describe(self, pt_s3d): ...
    def vec_absolute_describe(self, vec_s3d): ...
    def pt_transform(self, to_s3d, pt): ...
    def pts_transform(self, to_s3d, pts): ...
    def to_dict(self): ...
    def from_dict(dict): ...
    def get_reverse(self): ...
    @classmethod
    def by3pt(cls, cen, pt_on_x, pt_maybeon_y): ...

class Perspective:
    viewpt: Incomplete
    plane_expr: Incomplete
    img_cen: Incomplete
    def __init__(self, viewpt, plane_expr) -> None: ...
    def pt_prespective(self, pt): ...
    def pts_perspective(self, pts): ...
    def pts_perspective_limited(self, pts, r_limit: int = 30): ...
    def pts_singleside(self, pts, type: bool = True): ...

def pts_shortest_order(pts): ...
def pt_prespective(pt, viewpt, plane_expr): ...
def pts_prespective(pts, viewpt, plane_expr): ...
def get_angle(pt, angle_grid, unit: int = 10): ...
def get_angle_ingrid(pt, angle_grid, unit: int = 10): ...
def field_path(start_pt, field, step: int = 2, limit: int = 100, step_rate: float = 0.1): ...
def lim_angle_grid(angle_grid, max_angle: int = 60): ...
def part_grid(pts, w: int = 500, d: int = 500, unit: int = 10): ...
