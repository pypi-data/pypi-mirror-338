{"version":3,"file":"4082.8cd4a3f39920e4b6.js","sources":["webpack://knx-frontend/./homeassistant-frontend/src/components/ha-selector/ha-selector-label.ts","webpack://knx-frontend/./node_modules/home-assistant-js-websocket/dist/store.js","webpack://knx-frontend/./node_modules/home-assistant-js-websocket/dist/collection.js"],"sourcesContent":["import { LitElement, css, html } from \"lit\";\nimport { customElement, property } from \"lit/decorators\";\nimport { ensureArray } from \"../../common/array/ensure-array\";\nimport { fireEvent } from \"../../common/dom/fire_event\";\nimport type { LabelSelector } from \"../../data/selector\";\nimport type { HomeAssistant } from \"../../types\";\nimport \"../ha-labels-picker\";\n\n@customElement(\"ha-selector-label\")\nexport class HaLabelSelector extends LitElement {\n  @property({ attribute: false }) public hass?: HomeAssistant;\n\n  @property() public value?: string | string[];\n\n  @property() public name?: string;\n\n  @property() public label?: string;\n\n  @property() public placeholder?: string;\n\n  @property() public helper?: string;\n\n  @property({ attribute: false }) public selector!: LabelSelector;\n\n  @property({ type: Boolean }) public disabled = false;\n\n  @property({ type: Boolean }) public required = true;\n\n  protected render() {\n    if (this.selector.label.multiple) {\n      return html`\n        <ha-labels-picker\n          no-add\n          .hass=${this.hass}\n          .value=${ensureArray(this.value ?? [])}\n          .required=${this.required}\n          .disabled=${this.disabled}\n          .label=${this.label}\n          @value-changed=${this._handleChange}\n        >\n        </ha-labels-picker>\n      `;\n    }\n    return html`\n      <ha-label-picker\n        no-add\n        .hass=${this.hass}\n        .value=${this.value}\n        .required=${this.required}\n        .disabled=${this.disabled}\n        .label=${this.label}\n        @value-changed=${this._handleChange}\n      >\n      </ha-label-picker>\n    `;\n  }\n\n  private _handleChange(ev) {\n    let value = ev.detail.value;\n    if (this.value === value) {\n      return;\n    }\n    if (\n      (value === \"\" || (Array.isArray(value) && value.length === 0)) &&\n      !this.required\n    ) {\n      value = undefined;\n    }\n\n    fireEvent(this, \"value-changed\", { value });\n  }\n\n  static styles = css`\n    ha-labels-picker {\n      display: block;\n      width: 100%;\n    }\n  `;\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"ha-selector-label\": HaLabelSelector;\n  }\n}\n","export const createStore = (state) => {\n    let listeners = [];\n    function unsubscribe(listener) {\n        let out = [];\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i] === listener) {\n                listener = null;\n            }\n            else {\n                out.push(listeners[i]);\n            }\n        }\n        listeners = out;\n    }\n    function setState(update, overwrite) {\n        state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n        let currentListeners = listeners;\n        for (let i = 0; i < currentListeners.length; i++) {\n            currentListeners[i](state);\n        }\n    }\n    /**\n     * An observable state container, returned from {@link createStore}\n     * @name store\n     */\n    return {\n        get state() {\n            return state;\n        },\n        /**\n         * Create a bound copy of the given action function.\n         * The bound returned function invokes action() and persists the result back to the store.\n         * If the return value of `action` is a Promise, the resolved value will be used as state.\n         * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n         * @returns {Function} boundAction()\n         */\n        action(action) {\n            function apply(result) {\n                setState(result, false);\n            }\n            // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n            return function () {\n                let args = [state];\n                for (let i = 0; i < arguments.length; i++)\n                    args.push(arguments[i]);\n                // @ts-ignore\n                let ret = action.apply(this, args);\n                if (ret != null) {\n                    return ret instanceof Promise ? ret.then(apply) : apply(ret);\n                }\n            };\n        },\n        /**\n         * Apply a partial state object to the current state, invoking registered listeners.\n         * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n         * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n         */\n        setState,\n        clearState() {\n            state = undefined;\n        },\n        /**\n         * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n         * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n         * @returns {Function} unsubscribe()\n         */\n        subscribe(listener) {\n            listeners.push(listener);\n            return () => {\n                unsubscribe(listener);\n            };\n        },\n        // /**\n        //  * Remove a previously-registered listener function.\n        //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n        //  * @function\n        //  */\n        // unsubscribe,\n    };\n};\n","import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = { unsubGrace: true }) => {\n    // @ts-ignore\n    if (conn[key]) {\n        // @ts-ignore\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = createStore();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        store.clearState();\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    // @ts-ignore\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    options.unsubGrace\n                        ? scheduleTeardownUpdateSubscription()\n                        : teardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    // @ts-ignore\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n"],"names":["HaLabelSelector","_decorate","customElement","_initialize","_LitElement","F","constructor","args","d","kind","decorators","property","attribute","key","value","type","Boolean","this","selector","label","multiple","html","hass","ensureArray","required","disabled","_handleChange","ev","detail","Array","isArray","length","undefined","fireEvent","static","css","LitElement","createStore","state","listeners","setState","update","overwrite","Object","assign","currentListeners","i","action","apply","result","arguments","push","ret","Promise","then","clearState","subscribe","listener","out","unsubscribe","getCollection","conn","fetchCollection","subscribeUpdates","options","unsubGrace","unsubProm","unsubTimer","active","store","refresh","Error","refreshSwallow","catch","err","connected","teardownUpdateSubscription","unsub","removeEventListener","handleDisconnect","clearTimeout","subscriber","setupUpdateSubscription","addEventListener","setTimeout","createCollection","onChange"],"mappings":"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"}