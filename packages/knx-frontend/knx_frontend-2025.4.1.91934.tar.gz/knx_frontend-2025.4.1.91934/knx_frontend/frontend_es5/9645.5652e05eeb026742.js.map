{"version":3,"file":"9645.5652e05eeb026742.js","sources":["webpack://knx-frontend/../../src/layouts/shared/SizeCache.ts","webpack://knx-frontend/../src/layouts/flow.ts","webpack://knx-frontend/../../src/layouts/shared/BaseLayout.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nexport interface SizeCacheConfig {\n  roundAverageSize?: boolean;\n}\n\nexport class SizeCache {\n  private _map = new Map<number | string, number>();\n  private _roundAverageSize = false;\n  totalSize = 0;\n\n  constructor(config?: SizeCacheConfig) {\n    if (config?.roundAverageSize === true) {\n      this._roundAverageSize = true;\n    }\n  }\n\n  set(index: number | string, value: number): void {\n    const prev = this._map.get(index) || 0;\n    this._map.set(index, value);\n    this.totalSize += value - prev;\n  }\n\n  get averageSize(): number {\n    if (this._map.size > 0) {\n      const average = this.totalSize / this._map.size;\n      return this._roundAverageSize ? Math.round(average) : average;\n    }\n    return 0;\n  }\n\n  getSize(index: number | string) {\n    return this._map.get(index);\n  }\n\n  clear() {\n    this._map.clear();\n    this.totalSize = 0;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {SizeCache} from './shared/SizeCache.js';\nimport {BaseLayout, dim1} from './shared/BaseLayout.js';\nimport {\n  Positions,\n  Size,\n  Margins,\n  margin,\n  ScrollDirection,\n  offsetAxis,\n  ChildMeasurements,\n  BaseLayoutConfig,\n  LayoutHostSink,\n} from './shared/Layout.js';\n\ntype ItemBounds = {\n  pos: number;\n  size: number;\n};\n\ntype FlowLayoutConstructor = {\n  prototype: FlowLayout;\n  new (hostSink: LayoutHostSink, config?: BaseLayoutConfig): FlowLayout;\n};\n\ntype FlowLayoutSpecifier = BaseLayoutConfig & {\n  type: FlowLayoutConstructor;\n};\n\ntype FlowLayoutSpecifierFactory = (\n  config?: BaseLayoutConfig\n) => FlowLayoutSpecifier;\n\nexport const flow: FlowLayoutSpecifierFactory = (config?: BaseLayoutConfig) =>\n  Object.assign(\n    {\n      type: FlowLayout,\n    },\n    config\n  );\n\nfunction leadingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\n\nfunction trailingMargin(direction: ScrollDirection): margin {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\n\nfunction offset(direction: ScrollDirection): offsetAxis {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\n\nfunction collapseMargins(a: number, b: number): number {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\n\nclass MetricsCache {\n  private _childSizeCache = new SizeCache();\n  private _marginSizeCache = new SizeCache();\n  private _metricsCache = new Map<number, Size & Margins>();\n\n  update(metrics: {[key: number]: Size & Margins}, direction: ScrollDirection) {\n    const marginsToUpdate = new Set<number>();\n    Object.keys(metrics).forEach((key) => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n      const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n\n  get averageChildSize(): number {\n    return this._childSizeCache.averageSize;\n  }\n\n  get totalChildSize(): number {\n    return this._childSizeCache.totalSize;\n  }\n\n  get averageMarginSize(): number {\n    return this._marginSizeCache.averageSize;\n  }\n\n  get totalMarginSize(): number {\n    return this._marginSizeCache.totalSize;\n  }\n\n  getLeadingMarginValue(index: number, direction: ScrollDirection) {\n    return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n  }\n\n  getChildSize(index: number) {\n    return this._childSizeCache.getSize(index);\n  }\n\n  getMarginSize(index: number) {\n    return this._marginSizeCache.getSize(index);\n  }\n\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\n\nexport class FlowLayout extends BaseLayout<BaseLayoutConfig> {\n  /**\n   * Initial estimate of item size\n   */\n  _itemSize: Size = {width: 100, height: 100};\n\n  /**\n   * Indices of children mapped to their (position and length) in the scrolling\n   * direction. Used to keep track of children that are in range.\n   */\n  _physicalItems = new Map<number, ItemBounds>();\n\n  /**\n   * Used in tandem with _physicalItems to track children in range across\n   * reflows.\n   */\n  _newPhysicalItems = new Map<number, ItemBounds>();\n\n  /**\n   * Width and height of children by their index.\n   */\n  _metricsCache = new MetricsCache();\n\n  /**\n   * anchorIdx is the anchor around which we reflow. It is designed to allow\n   * jumping to any point of the scroll size. We choose it once and stick with\n   * it until stable. _first and _last are deduced around it.\n   */\n  _anchorIdx: number | null = null;\n\n  /**\n   * Position in the scrolling direction of the anchor child.\n   */\n  _anchorPos: number | null = null;\n\n  /**\n   * Whether all children in range were in range during the previous reflow.\n   */\n  _stable = true;\n\n  private _measureChildren = true;\n\n  _estimate = true;\n\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n\n  // })\n\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n\n  get measureChildren() {\n    return this._measureChildren;\n  }\n\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes: ChildMeasurements) {\n    this._metricsCache.update(sizes as Size & Margins, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n\n  _getPhysicalItem(idx: number): ItemBounds | undefined {\n    return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n  }\n\n  _getSize(idx: number): number | undefined {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n\n  _getAverageSize(): number {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n\n  _estimatePosition(idx: number): number {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return (\n        c.averageMarginSize +\n        idx * (c.averageMarginSize + this._getAverageSize())\n      );\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return (\n          refItem!.pos -\n          (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n          (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize)\n        );\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return (\n          refItem!.pos +\n          (c.getChildSize(this._last) || c.averageChildSize) +\n          (c.getMarginSize(this._last) || c.averageMarginSize) +\n          delta * (c.averageChildSize + c.averageMarginSize)\n        );\n      }\n    }\n  }\n\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx: number): number {\n    const item = this._getPhysicalItem(idx);\n    const {averageMarginSize} = this._metricsCache;\n    return idx === 0\n      ? this._metricsCache.getMarginSize(0) ?? averageMarginSize\n      : item\n        ? item.pos\n        : this._estimatePosition(idx);\n  }\n\n  _calculateAnchor(lower: number, upper: number): number {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(\n      0,\n      Math.min(\n        this.items.length - 1,\n        Math.floor((lower + upper) / 2 / this._delta)\n      )\n    );\n  }\n\n  _getAnchor(lower: number, upper: number): number {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem!.pos,\n      lastMin = lastItem!.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last)!;\n\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate!.pos + this._metricsCache.getChildSize(candidateIdx)!;\n    }\n    return candidateIdx;\n  }\n\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {index} = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n\n    const anchorLeadingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx) ??\n      this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin =\n      this._metricsCache.getMarginSize(this._anchorIdx + 1) ??\n      this._metricsCache.averageMarginSize;\n\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n\n    items.set(this._anchorIdx, {pos: this._anchorPos, size: anchorSize});\n\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {pos, size});\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {pos, size});\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach((item) => (item.pos -= extentErr));\n      this._scrollError += extentErr;\n    }\n\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n\n  _calculateError(): number {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return (\n        this._physicalMax -\n        this._scrollSize +\n        (this.items.length - 1 - this._last) * this._delta\n      );\n    }\n    return 0;\n  }\n\n  override _reflow() {\n    const {_first, _last} = this;\n    super._reflow();\n    if (\n      (this._first === -1 && this._last == -1) ||\n      (this._first === _first && this._last === _last)\n    ) {\n      this._resetReflowState();\n    }\n  }\n\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n\n  _updateScrollSize() {\n    const {averageMarginSize} = this._metricsCache;\n    this._scrollSize = Math.max(\n      1,\n      this.items.length * (averageMarginSize + this._getAverageSize()) +\n        averageMarginSize\n    );\n  }\n\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  protected get _delta(): number {\n    const {averageMarginSize} = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx: number): Positions {\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -(\n        this._metricsCache.getLeadingMarginValue(idx, this.direction) ??\n        this._metricsCache.averageMarginSize\n      ),\n    } as Positions;\n  }\n\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx: number): Size {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n    } as Size;\n  }\n\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {\n  Layout,\n  ChildPositions,\n  Positions,\n  ScrollDirection,\n  Size,\n  dimension,\n  position,\n  PinOptions,\n  ScrollToCoordinates,\n  BaseLayoutConfig,\n  StateChangedMessage,\n  LayoutHostSink,\n} from './Layout.js';\n\ntype UpdateVisibleIndicesOptions = {\n  emit?: boolean;\n};\n\nexport function dim1(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\n\nexport function dim2(direction: ScrollDirection): dimension {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\n\nexport function pos1(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\n\nexport function pos2(direction: ScrollDirection): position {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\n\nexport abstract class BaseLayout<C extends BaseLayoutConfig> implements Layout {\n  /**\n   * The last set viewport scroll position.\n   */\n  private _latestCoords: Positions = {left: 0, top: 0};\n\n  /**\n   * Scrolling direction.\n   */\n  private _direction: ScrollDirection | null = null;\n\n  /**\n   * Dimensions of the viewport.\n   */\n  private _viewportSize: Size = {width: 0, height: 0};\n\n  public totalScrollSize: Size = {width: 0, height: 0};\n\n  public offsetWithinScroller: Positions = {left: 0, top: 0};\n\n  /**\n   * Flag for debouncing asynchronous reflow requests.\n   */\n  private _pendingReflow = false;\n\n  private _pendingLayoutUpdate = false;\n\n  protected _pin: PinOptions | null = null;\n\n  /**\n   * The index of the first item intersecting the viewport.\n   */\n  protected _firstVisible = 0;\n\n  /**\n   * The index of the last item intersecting the viewport.\n   */\n  protected _lastVisible = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the first child.\n   */\n  protected _physicalMin = 0;\n\n  /**\n   * Pixel offset in the scroll direction of the last child.\n   */\n  protected _physicalMax = 0;\n\n  /**\n   * Index of the first child.\n   */\n  protected _first = -1;\n\n  /**\n   * Index of the last child.\n   */\n  protected _last = -1;\n\n  /**\n   * Length in the scrolling direction.\n   */\n  protected _sizeDim: dimension = 'height';\n\n  /**\n   * Length in the non-scrolling direction.\n   */\n  protected _secondarySizeDim: dimension = 'width';\n\n  /**\n   * Position in the scrolling direction.\n   */\n  protected _positionDim: position = 'top';\n\n  /**\n   * Position in the non-scrolling direction.\n   */\n  protected _secondaryPositionDim: position = 'left';\n\n  /**\n   * Current scroll offset in pixels.\n   */\n  protected _scrollPosition = 0;\n\n  /**\n   * Difference between current scroll offset and scroll offset calculated due\n   * to a reflow.\n   */\n  protected _scrollError = 0;\n\n  /**\n   * Total number of items that could possibly be displayed. Used to help\n   * calculate the scroll size.\n   */\n  protected _items: unknown[] = [];\n\n  /**\n   * The total (estimated) length of all items in the scrolling direction.\n   */\n  protected _scrollSize = 1;\n\n  /**\n   * Number of pixels beyond the viewport to still include\n   * in the active range of items.\n   */\n  // TODO (graynorton): Probably want to make this something we calculate based\n  // on viewport size, item size, other factors, possibly still with a dial of some kind\n  protected _overhang = 1000;\n\n  /**\n   * Call this to deliver messages (e.g. stateChanged, unpinned) to host\n   */\n  private _hostSink: LayoutHostSink;\n\n  protected _getDefaultConfig(): C {\n    return {\n      direction: 'vertical',\n    } as C;\n  }\n\n  constructor(hostSink: LayoutHostSink, config?: C) {\n    this._hostSink = hostSink;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(\n      () => (this.config = config || this._getDefaultConfig())\n    );\n  }\n\n  set config(config: C) {\n    Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n  }\n\n  get config(): C {\n    return {\n      direction: this.direction,\n    } as C;\n  }\n\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items(): unknown[] {\n    return this._items;\n  }\n\n  set items(items: unknown[]) {\n    this._setItems(items);\n  }\n\n  protected _setItems(items: unknown[]) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n\n  /**\n   * Primary scrolling direction.\n   */\n  get direction(): ScrollDirection {\n    return this._direction!;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize(): Size {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {_viewDim1, _viewDim2} = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll(): Positions {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._checkThresholds();\n    }\n  }\n\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n\n  set pin(options: PinOptions | null) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n\n  get pin() {\n    if (this._pin !== null) {\n      const {index, block} = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block,\n      };\n    }\n    return null;\n  }\n\n  _clampScrollPosition(val: number) {\n    return Math.max(\n      -this.offsetWithinScroller[this._positionDim],\n      Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1)\n    );\n  }\n\n  unpin() {\n    if (this._pin !== null) {\n      this._sendUnpinnedMessage();\n      this._pin = null;\n    }\n  }\n\n  /**\n   * Get the top and left positioning of the item at idx.\n   */\n  protected abstract _getItemPosition(idx: number): Positions;\n\n  /**\n   * Update _first and _last based on items that should be in the current\n   * range.\n   */\n  protected abstract _getActiveItems(): void;\n\n  protected abstract _getItemSize(_idx: number): Size;\n\n  /**\n   * Calculates (precisely or by estimating, if needed) the total length of all items in\n   * the scrolling direction, including spacing, caching the value in the `_scrollSize` field.\n   *\n   * Should return a minimum value of 1 to ensure at least one item is rendered.\n   * TODO (graynorton): Possibly no longer required, but leaving here until it can be verified.\n   */\n  protected abstract _updateScrollSize(): void;\n\n  protected _updateLayout(): void {\n    // Override\n  }\n\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  protected get _viewDim1(): number {\n    return this._viewportSize[this._sizeDim];\n  }\n\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  protected get _viewDim2(): number {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n\n  protected _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n\n  protected _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  protected _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n\n  protected _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._sendStateChangedMessage();\n  }\n\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  protected _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {index, block} = this.pin;\n      this._scrollPosition =\n        this._calculateScrollIntoViewPosition({\n          index,\n          block: block || 'start',\n        }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  protected _calculateScrollIntoViewPosition(options: PinOptions) {\n    const {block} = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition =\n          itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition =\n            Math.abs(currentScrollPosition - itemStartPosition) <\n            Math.abs(currentScrollPosition - itemEndPosition)\n              ? itemStartPosition\n              : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n\n  public getScrollIntoViewCoordinates(\n    options: PinOptions\n  ): ScrollToCoordinates {\n    return {\n      [this._positionDim as position]:\n        this._calculateScrollIntoViewPosition(options),\n    } as ScrollToOptions;\n  }\n\n  private _sendUnpinnedMessage() {\n    this._hostSink({\n      type: 'unpinned',\n    });\n  }\n\n  private _sendVisibilityChangedMessage() {\n    this._hostSink({\n      type: 'visibilityChanged',\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible,\n    });\n  }\n\n  protected _sendStateChangedMessage() {\n    const childPositions: ChildPositions = new Map();\n    if (this._first !== -1 && this._last !== -1) {\n      for (let idx = this._first; idx <= this._last; idx++) {\n        childPositions.set(idx, this._getItemPosition(idx));\n      }\n    }\n    const message: StateChangedMessage = {\n      type: 'stateChanged',\n      scrollSize: {\n        [this._sizeDim]: this._scrollSize,\n        [this._secondarySizeDim]: null,\n      } as Size,\n      range: {\n        first: this._first,\n        last: this._last,\n        firstVisible: this._firstVisible,\n        lastVisible: this._lastVisible,\n      },\n      childPositions,\n    };\n    if (this._scrollError) {\n      message.scrollError = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0,\n      } as Positions;\n      this._scrollError = 0;\n    }\n    this._hostSink(message);\n  }\n\n  /**\n   * Number of items to display.\n   */\n  private get _num(): number {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n\n  private _checkThresholds() {\n    if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(\n        this._scrollSize,\n        this._scrollPosition + this._viewDim1 + this._overhang\n      );\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      } else {\n        this._updateVisibleIndices({emit: true});\n      }\n    }\n  }\n\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  protected _updateVisibleIndices(options?: UpdateVisibleIndicesOptions) {\n    if (this._first === -1 || this._last === -1) return;\n\n    let firstVisible = this._first;\n    while (\n      firstVisible < this._last &&\n      Math.round(\n        this._getItemPosition(firstVisible)[this._positionDim] +\n          this._getItemSize(firstVisible)[this._sizeDim]\n      ) <= Math.round(this._scrollPosition)\n    ) {\n      firstVisible++;\n    }\n\n    let lastVisible = this._last;\n    while (\n      lastVisible > this._first &&\n      Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n        Math.round(this._scrollPosition + this._viewDim1)\n    ) {\n      lastVisible--;\n    }\n\n    if (\n      firstVisible !== this._firstVisible ||\n      lastVisible !== this._lastVisible\n    ) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._sendVisibilityChangedMessage();\n      }\n    }\n  }\n}\n"],"names":["SizeCache","constructor","config","_map","Map","_roundAverageSize","totalSize","roundAverageSize","this","set","index","value","prev","get","averageSize","size","average","Math","round","getSize","clear","flow","Object","assign","type","FlowLayout","leadingMargin","direction","trailingMargin","offset","collapseMargins","a","b","m","sort","min","max","MetricsCache","_childSizeCache","_marginSizeCache","_metricsCache","update","metrics","marginsToUpdate","Set","keys","forEach","key","k","Number","dim1","add","_this$_metricsCache$g","_this$_metricsCache$g2","averageChildSize","totalChildSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","_this$_metricsCache$g3","getChildSize","getMarginSize","BaseLayout","_itemSize","width","height","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","measureChildren","updateItemSizes","sizes","_scheduleReflow","_getPhysicalItem","idx","_this$_newPhysicalIte","_getSize","_getAverageSize","_sizeDim","_estimatePosition","c","_first","_last","delta","pos","_getPosition","_this$_metricsCache$g4","item","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","items","length","floor","_delta","_getAnchor","firstItem","lastItem","firstMin","candidateIdx","_firstVisible","cMax","Infinity","_getActiveItems","_clearItems","_getItems","_physicalMin","_physicalMax","_this$_metricsCache$g5","_this$_metricsCache$g6","pin","_scrollPosition","_overhang","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","_scrollError","margin","extentErr","_calculateError","_reflow","super","_resetReflowState","_updateScrollSize","_getItemPosition","_this$_metricsCache$g7","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_viewDim2Changed","dim2","_getDefaultConfig","hostSink","_latestCoords","left","top","_direction","_viewportSize","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_lastVisible","_items","_hostSink","Promise","resolve","then","_setItems","dir","_triggerReflow","viewportSize","dims","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","abs","reflowIfNeeded","force","options","block","_clampScrollPosition","val","unpin","_sendUnpinnedMessage","_updateLayout","_setPositionFromPin","_updateVisibleIndices","_sendStateChangedMessage","lastScrollPosition","_calculateScrollIntoViewPosition","itemStartPosition","scrollPosition","itemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","_sendVisibilityChangedMessage","firstVisible","lastVisible","childPositions","message","scrollSize","range","first","last","scrollError","_num","emit"],"mappings":";qRAUM,MAAOA,EAKXC,WAAAA,CAAYC,GAJJ,KAAAC,KAAO,IAAIC,IACX,KAAAC,mBAAoB,EAC5B,KAAAC,UAAY,GAGuB,KAA7BJ,aAAM,EAANA,EAAQK,oBACVC,KAAKH,mBAAoB,EAE7B,CAEAI,GAAAA,CAAIC,EAAwBC,GAC1B,MAAMC,EAAOJ,KAAKL,KAAKU,IAAIH,IAAU,EACrCF,KAAKL,KAAKM,IAAIC,EAAOC,GACrBH,KAAKF,WAAaK,EAAQC,CAC5B,CAEA,eAAIE,GACF,GAAIN,KAAKL,KAAKY,KAAO,EAAG,CACtB,MAAMC,EAAUR,KAAKF,UAAYE,KAAKL,KAAKY,KAC3C,OAAOP,KAAKH,kBAAoBY,KAAKC,MAAMF,GAAWA,CACxD,CACA,OAAO,CACT,CAEAG,OAAAA,CAAQT,GACN,OAAOF,KAAKL,KAAKU,IAAIH,EACvB,CAEAU,KAAAA,GACEZ,KAAKL,KAAKiB,QACVZ,KAAKF,UAAY,CACnB,iBCJK,MAAMe,EAAoCnB,GAC/CoB,OAAOC,OACL,CACEC,KAAMC,GAERvB,GAGJ,SAASwB,EAAcC,GACrB,MAAqB,eAAdA,EAA6B,aAAe,WACrD,CAEA,SAASC,EAAeD,GACtB,MAAqB,eAAdA,EAA6B,cAAgB,cACtD,CAEA,SAASE,EAAOF,GACd,MAAqB,eAAdA,EAA6B,UAAY,SAClD,CAEA,SAASG,EAAgBC,EAAWC,GAClC,MAAMC,EAAI,CAACF,EAAGC,GAAGE,OACjB,OAAOD,EAAE,IAAM,EAAIhB,KAAKkB,OAAOF,GAAKA,EAAE,IAAM,EAAIhB,KAAKmB,OAAOH,GAAKA,EAAE,GAAKA,EAAE,EAC5E,CAEA,MAAMI,EAANpC,WAAAA,GACU,KAAAqC,gBAAkB,IAAItC,EACtB,KAAAuC,iBAAmB,IAAIvC,EACvB,KAAAwC,cAAgB,IAAIpC,GAmD9B,CAjDEqC,MAAAA,CAAOC,EAA0Cf,GAC/C,MAAMgB,EAAkB,IAAIC,IAC5BtB,OAAOuB,KAAKH,GAASI,SAASC,IAC5B,MAAMC,EAAIC,OAAOF,GACjBvC,KAAKgC,cAAc/B,IAAIuC,EAAGN,EAAQM,IAClCxC,KAAK8B,gBAAgB7B,IAAIuC,EAAGN,EAAQM,IAAGE,EAAAA,EAAAA,IAAKvB,KAC5CgB,EAAgBQ,IAAIH,GACpBL,EAAgBQ,IAAIH,EAAI,EAAE,IAE5B,IAAK,MAAMA,KAAKL,EAAiB,KAAAS,EAAAC,EAC/B,MAAMtB,GAA6B,QAAzBqB,EAAA5C,KAAKgC,cAAc3B,IAAImC,UAAE,IAAAI,OAAA,EAAzBA,EAA4B1B,EAAcC,MAAe,EAC7DK,GAAiC,QAA7BqB,EAAA7C,KAAKgC,cAAc3B,IAAImC,EAAI,UAAE,IAAAK,OAAA,EAA7BA,EAAgCzB,EAAeD,MAAe,EACxEnB,KAAK+B,iBAAiB9B,IAAIuC,EAAGlB,EAAgBC,EAAGC,GAClD,CACF,CAEA,oBAAIsB,GACF,OAAO9C,KAAK8B,gBAAgBxB,WAC9B,CAEA,kBAAIyC,GACF,OAAO/C,KAAK8B,gBAAgBhC,SAC9B,CAEA,qBAAIkD,GACF,OAAOhD,KAAK+B,iBAAiBzB,WAC/B,CAEA,mBAAI2C,GACF,OAAOjD,KAAK+B,iBAAiBjC,SAC/B,CAEAoD,qBAAAA,CAAsBhD,EAAeiB,GAA0B,IAAAgC,EAC7D,OAAoC,QAA7BA,EAAAnD,KAAKgC,cAAc3B,IAAIH,UAAM,IAAAiD,OAAA,EAA7BA,EAAgCjC,EAAcC,MAAe,CACtE,CAEAiC,YAAAA,CAAalD,GACX,OAAOF,KAAK8B,gBAAgBnB,QAAQT,EACtC,CAEAmD,aAAAA,CAAcnD,GACZ,OAAOF,KAAK+B,iBAAiBpB,QAAQT,EACvC,CAEAU,KAAAA,GACEZ,KAAK8B,gBAAgBlB,QACrBZ,KAAK+B,iBAAiBnB,QACtBZ,KAAKgC,cAAcpB,OACrB,EAGI,MAAOK,UAAmBqC,EAAAA,GAAhC7D,WAAAA,uBAIE,KAAA8D,UAAkB,CAACC,MAAO,IAAKC,OAAQ,KAMvC,KAAAC,eAAiB,IAAI9D,IAMrB,KAAA+D,kBAAoB,IAAI/D,IAKxB,KAAAoC,cAAgB,IAAIH,EAOpB,KAAA+B,WAA4B,KAK5B,KAAAC,WAA4B,KAK5B,KAAAC,SAAU,EAEF,KAAAC,kBAAmB,EAE3B,KAAAC,WAAY,CAsYd,CA5XE,mBAAIC,GACF,OAAOjE,KAAK+D,gBACd,CAMAG,eAAAA,CAAgBC,GACdnE,KAAKgC,cAAcC,OAAOkC,EAAyBnE,KAAKmB,WAGxDnB,KAAKoE,iBAEP,CAWAC,gBAAAA,CAAiBC,GAAW,IAAAC,EAC1B,OAAsC,QAAtCA,EAAOvE,KAAK2D,kBAAkBtD,IAAIiE,UAAI,IAAAC,EAAAA,EAAIvE,KAAK0D,eAAerD,IAAIiE,EACpE,CAEAE,QAAAA,CAASF,GAEP,OADatE,KAAKqE,iBAAiBC,IACpBtE,KAAKgC,cAAcoB,aAAakB,EACjD,CAEAG,eAAAA,GACE,OAAOzE,KAAKgC,cAAcc,kBAAoB9C,KAAKuD,UAAUvD,KAAK0E,SACpE,CAEAC,iBAAAA,CAAkBL,GAChB,MAAMM,EAAI5E,KAAKgC,cACf,IAAqB,IAAjBhC,KAAK6E,SAAiC,IAAhB7E,KAAK8E,MAC7B,OACEF,EAAE5B,kBACFsB,GAAOM,EAAE5B,kBAAoBhD,KAAKyE,mBAGpC,GAAIH,EAAMtE,KAAK6E,OAAQ,CACrB,MAAME,EAAQ/E,KAAK6E,OAASP,EAE5B,OADgBtE,KAAKqE,iBAAiBrE,KAAK6E,QAEhCG,KACRJ,EAAEvB,cAAcrD,KAAK6E,OAAS,IAAMD,EAAE5B,oBACtC+B,EAAQH,EAAE9B,kBAAoBiC,EAAQ,GAAKH,EAAE5B,kBAElD,CAAO,CACL,MAAM+B,EAAQT,EAAMtE,KAAK8E,MAEzB,OADgB9E,KAAKqE,iBAAiBrE,KAAK8E,OAEhCE,KACRJ,EAAExB,aAAapD,KAAK8E,QAAUF,EAAE9B,mBAChC8B,EAAEvB,cAAcrD,KAAK8E,QAAUF,EAAE5B,mBAClC+B,GAASH,EAAE9B,iBAAmB8B,EAAE5B,kBAEpC,CAEJ,CAMAiC,YAAAA,CAAaX,GAAW,IAAAY,EACtB,MAAMC,EAAOnF,KAAKqE,iBAAiBC,IAC7B,kBAACtB,GAAqBhD,KAAKgC,cACjC,OAAe,IAARsC,EACgC,QADvBY,EACZlF,KAAKgC,cAAcqB,cAAc,UAAE,IAAA6B,EAAAA,EAAIlC,EACvCmC,EACEA,EAAKH,IACLhF,KAAK2E,kBAAkBL,EAC/B,CAEAc,gBAAAA,CAAiBC,EAAeC,GAC9B,OAAID,GAAS,EACJ,EAELC,EAAQtF,KAAKuF,YAAcvF,KAAKwF,UAC3BxF,KAAKyF,MAAMC,OAAS,EAEtBjF,KAAKmB,IACV,EACAnB,KAAKkB,IACH3B,KAAKyF,MAAMC,OAAS,EACpBjF,KAAKkF,OAAON,EAAQC,GAAS,EAAItF,KAAK4F,SAG5C,CAEAC,UAAAA,CAAWR,EAAeC,GACxB,GAAiC,IAA7BtF,KAAK0D,eAAenD,KACtB,OAAOP,KAAKoF,iBAAiBC,EAAOC,GAEtC,GAAItF,KAAK6E,OAAS,EAChB,OAAO7E,KAAKoF,iBAAiBC,EAAOC,GAEtC,GAAItF,KAAK8E,MAAQ,EACf,OAAO9E,KAAKoF,iBAAiBC,EAAOC,GAGtC,MAAMQ,EAAY9F,KAAKqE,iBAAiBrE,KAAK6E,QAC3CkB,EAAW/F,KAAKqE,iBAAiBrE,KAAK8E,OACtCkB,EAAWF,EAAWd,IAIxB,GAHYe,EAAUf,IACAhF,KAAKgC,cAAcoB,aAAapD,KAAK8E,OAE7CO,EAEZ,OAAOrF,KAAKoF,iBAAiBC,EAAOC,GAEtC,GAAIU,EAAWV,EAEb,OAAOtF,KAAKoF,iBAAiBC,EAAOC,GAItC,IAAIW,EAAejG,KAAKkG,cAAgB,EACpCC,GAAQC,IACZ,KAAOD,EAAOd,GAAO,CAEnBc,EADkBnG,KAAKqE,mBAAmB4B,GACxBjB,IAAMhF,KAAKgC,cAAcoB,aAAa6C,EAC1D,CACA,OAAOA,CACT,CAMAI,eAAAA,GACyB,IAAnBrG,KAAKwF,WAAyC,IAAtBxF,KAAKyF,MAAMC,OACrC1F,KAAKsG,cAELtG,KAAKuG,WAET,CAKAD,WAAAA,GACEtG,KAAK6E,QAAU,EACf7E,KAAK8E,OAAS,EACd9E,KAAKwG,aAAe,EACpBxG,KAAKyG,aAAe,EACpB,MAAMhB,EAAQzF,KAAK2D,kBACnB3D,KAAK2D,kBAAoB3D,KAAK0D,eAC9B1D,KAAK2D,kBAAkB/C,QACvBZ,KAAK0D,eAAiB+B,EACtBzF,KAAK8D,SAAU,CACjB,CAKAyC,SAAAA,GAAS,IAAAG,EAAAC,EACP,MAAMlB,EAAQzF,KAAK2D,kBAEnB,IAAI0B,EAAOC,EAOX,GARAtF,KAAK8D,SAAU,EAQE,OAAb9D,KAAK4G,IAAc,CACrB,MAAM,MAAC1G,GAASF,KAAK4G,IACrB5G,KAAK4D,WAAa1D,EAClBF,KAAK6D,WAAa7D,KAAKiF,aAAa/E,EACtC,CAOA,GAHAmF,EAAQrF,KAAK6G,gBAAkB7G,KAAK8G,UACpCxB,EAAQtF,KAAK6G,gBAAkB7G,KAAKwF,UAAYxF,KAAK8G,UAEjDxB,EAAQ,GAAKD,EAAQrF,KAAKuF,YAE5B,YADAvF,KAAKsG,cAOiB,OAApBtG,KAAK4D,YAA2C,OAApB5D,KAAK6D,aACnC7D,KAAK4D,WAAa5D,KAAK6F,WAAWR,EAAOC,GACzCtF,KAAK6D,WAAa7D,KAAKiF,aAAajF,KAAK4D,aAG3C,IAAImD,EAAa/G,KAAKwE,SAASxE,KAAK4D,iBACjBoD,IAAfD,IACF/G,KAAK8D,SAAU,EACfiD,EAAa/G,KAAKyE,mBAGpB,MAAMwC,EAC6C,QAD1BP,EACvB1G,KAAKgC,cAAcqB,cAAcrD,KAAK4D,mBAAW,IAAA8C,EAAAA,EACjD1G,KAAKgC,cAAcgB,kBACfkE,EACiD,QAD7BP,EACxB3G,KAAKgC,cAAcqB,cAAcrD,KAAK4D,WAAa,UAAE,IAAA+C,EAAAA,EACrD3G,KAAKgC,cAAcgB,kBAEG,IAApBhD,KAAK4D,aACP5D,KAAK6D,WAAaoD,GAGhBjH,KAAK4D,aAAe5D,KAAKyF,MAAMC,OAAS,IAC1C1F,KAAK6D,WAAa7D,KAAKuF,YAAc2B,EAAuBH,GAK9D,IAAII,EAAY,EAuBhB,IArBInH,KAAK6D,WAAakD,EAAaG,EAAuB7B,IACxD8B,EAAY9B,GAASrF,KAAK6D,WAAakD,EAAaG,IAGlDlH,KAAK6D,WAAaoD,EAAsB3B,IAC1C6B,EAAY7B,GAAStF,KAAK6D,WAAaoD,IAGrCE,IACFnH,KAAK6G,iBAAmBM,EACxB9B,GAAS8B,EACT7B,GAAS6B,EACTnH,KAAKoH,cAAgBD,GAGvB1B,EAAMxF,IAAID,KAAK4D,WAAY,CAACoB,IAAKhF,KAAK6D,WAAYtD,KAAMwG,IAExD/G,KAAK6E,OAAS7E,KAAK8E,MAAQ9E,KAAK4D,WAChC5D,KAAKwG,aAAexG,KAAK6D,WAAaoD,EACtCjH,KAAKyG,aAAezG,KAAK6D,WAAakD,EAAaG,EAE5ClH,KAAKwG,aAAenB,GAASrF,KAAK6E,OAAS,GAAG,CACnD,IAAItE,EAAOP,KAAKwE,WAAWxE,KAAK6E,aACnBmC,IAATzG,IACFP,KAAK8D,SAAU,EACfvD,EAAOP,KAAKyE,mBAEd,IAAI4C,EAASrH,KAAKgC,cAAcqB,cAAcrD,KAAK6E,aACpCmC,IAAXK,IACFrH,KAAK8D,SAAU,EACfuD,EAASrH,KAAKgC,cAAcgB,mBAE9BhD,KAAKwG,cAAgBjG,EACrB,MAAMyE,EAAMhF,KAAKwG,aAGjB,GAFAf,EAAMxF,IAAID,KAAK6E,OAAQ,CAACG,MAAKzE,SAC7BP,KAAKwG,cAAgBa,GACA,IAAjBrH,KAAK8D,UAAwC,IAAnB9D,KAAKgE,UACjC,KAEJ,CAEA,KAAOhE,KAAKyG,aAAenB,GAAStF,KAAK8E,MAAQ9E,KAAKyF,MAAMC,OAAS,GAAG,CACtE,IAAInF,EAAOP,KAAKwE,WAAWxE,KAAK8E,YACnBkC,IAATzG,IACFP,KAAK8D,SAAU,EACfvD,EAAOP,KAAKyE,mBAEd,IAAI4C,EAASrH,KAAKgC,cAAcqB,cAAcrD,KAAK8E,YACpCkC,IAAXK,IACFrH,KAAK8D,SAAU,EACfuD,EAASrH,KAAKgC,cAAcgB,mBAE9B,MAAMgC,EAAMhF,KAAKyG,aAGjB,GAFAhB,EAAMxF,IAAID,KAAK8E,MAAO,CAACE,MAAKzE,SAC5BP,KAAKyG,cAAgBlG,EAAO8G,GACvBrH,KAAK8D,UAAY9D,KAAKgE,UACzB,KAEJ,CAGA,MAAMsD,EAAYtH,KAAKuH,kBACnBD,IACFtH,KAAKwG,cAAgBc,EACrBtH,KAAKyG,cAAgBa,EACrBtH,KAAK6D,YAAcyD,EACnBtH,KAAK6G,iBAAmBS,EACxB7B,EAAMnD,SAAS6C,GAAUA,EAAKH,KAAOsC,IACrCtH,KAAKoH,cAAgBE,GAGnBtH,KAAK8D,UACP9D,KAAK2D,kBAAoB3D,KAAK0D,eAC9B1D,KAAK2D,kBAAkB/C,QACvBZ,KAAK0D,eAAiB+B,EAE1B,CAEA8B,eAAAA,GACE,OAAoB,IAAhBvH,KAAK6E,OACA7E,KAAKwG,aACHxG,KAAKwG,cAAgB,EACvBxG,KAAKwG,aAAexG,KAAK6E,OAAS7E,KAAK4F,OACrC5F,KAAK8E,QAAU9E,KAAKyF,MAAMC,OAAS,EACrC1F,KAAKyG,aAAezG,KAAKuF,YACvBvF,KAAKyG,cAAgBzG,KAAKuF,YAEjCvF,KAAKyG,aACLzG,KAAKuF,aACJvF,KAAKyF,MAAMC,OAAS,EAAI1F,KAAK8E,OAAS9E,KAAK4F,OAGzC,CACT,CAES4B,OAAAA,GACP,MAAM,OAAC3C,EAAM,MAAEC,GAAS9E,KACxByH,MAAMD,YAEc,IAAjBxH,KAAK6E,SAAgC,GAAf7E,KAAK8E,OAC3B9E,KAAK6E,SAAWA,GAAU7E,KAAK8E,QAAUA,IAE1C9E,KAAK0H,mBAET,CAEAA,iBAAAA,GACE1H,KAAK4D,WAAa,KAClB5D,KAAK6D,WAAa,KAClB7D,KAAK8D,SAAU,CACjB,CAEA6D,iBAAAA,GACE,MAAM,kBAAC3E,GAAqBhD,KAAKgC,cACjChC,KAAKuF,YAAc9E,KAAKmB,IACtB,EACA5B,KAAKyF,MAAMC,QAAU1C,EAAoBhD,KAAKyE,mBAC5CzB,EAEN,CAMA,UAAc4C,GACZ,MAAM,kBAAC5C,GAAqBhD,KAAKgC,cACjC,OAAOhC,KAAKyE,kBAAoBzB,CAClC,CAKA4E,gBAAAA,CAAiBtD,GAAW,IAAAuD,EAC1B,MAAO,CACL,CAAC7H,KAAK8H,cAAe9H,KAAKiF,aAAaX,GACvC,CAACtE,KAAK+H,uBAAwB,EAC9B,CAAC1G,EAAOrB,KAAKmB,cACkD,QADrC0G,EACxB7H,KAAKgC,cAAckB,sBAAsBoB,EAAKtE,KAAKmB,kBAAU,IAAA0G,EAAAA,EAC7D7H,KAAKgC,cAAcgB,mBAGzB,CAKAgF,YAAAA,CAAa1D,GACX,MAAO,CACL,CAACtE,KAAK0E,UAAW1E,KAAKwE,SAASF,IAAQtE,KAAKyE,kBAC5C,CAACzE,KAAKiI,mBAAoBjI,KAAKuD,UAAUvD,KAAKiI,mBAElD,CAEAC,gBAAAA,GACElI,KAAKgC,cAAcpB,QACnBZ,KAAKoE,iBACP,kGC7gBI,SAAU1B,EAAKvB,GACnB,MAAqB,eAAdA,EAA6B,QAAU,QAChD,CAEM,SAAUgH,EAAKhH,GACnB,MAAqB,eAAdA,EAA6B,SAAW,OACjD,CAUM,MAAgBmC,EAkHV8E,iBAAAA,GACR,MAAO,CACLjH,UAAW,WAEf,CAEA1B,WAAAA,CAAY4I,EAA0B3I,GApH9B,KAAA4I,cAA2B,CAACC,KAAM,EAAGC,IAAK,GAK1C,KAAAC,WAAqC,KAKrC,KAAAC,cAAsB,CAAClF,MAAO,EAAGC,OAAQ,GAE1C,KAAAkF,gBAAwB,CAACnF,MAAO,EAAGC,OAAQ,GAE3C,KAAAmF,qBAAkC,CAACL,KAAM,EAAGC,IAAK,GAKhD,KAAAK,gBAAiB,EAEjB,KAAAC,sBAAuB,EAErB,KAAAC,KAA0B,KAK1B,KAAA7C,cAAgB,EAKhB,KAAA8C,aAAe,EAKf,KAAAxC,aAAe,EAKf,KAAAC,aAAe,EAKf,KAAA5B,QAAU,EAKV,KAAAC,OAAS,EAKT,KAAAJ,SAAsB,SAKtB,KAAAuD,kBAA+B,QAK/B,KAAAH,aAAyB,MAKzB,KAAAC,sBAAkC,OAKlC,KAAAlB,gBAAkB,EAMlB,KAAAO,aAAe,EAMf,KAAA6B,OAAoB,GAKpB,KAAA1D,YAAc,EAQd,KAAAuB,UAAY,IAcpB9G,KAAKkJ,UAAYb,EAEjBc,QAAQC,UAAUC,MAChB,IAAOrJ,KAAKN,OAASA,GAAUM,KAAKoI,qBAExC,CAEA,UAAI1I,CAAOA,GACToB,OAAOC,OAAOf,KAAMc,OAAOC,OAAO,CAAC,EAAGf,KAAKoI,oBAAqB1I,GAClE,CAEA,UAAIA,GACF,MAAO,CACLyB,UAAWnB,KAAKmB,UAEpB,CAMA,SAAIsE,GACF,OAAOzF,KAAKiJ,MACd,CAEA,SAAIxD,CAAMA,GACRzF,KAAKsJ,UAAU7D,EACjB,CAEU6D,SAAAA,CAAU7D,GACdA,IAAUzF,KAAKiJ,SACjBjJ,KAAKiJ,OAASxD,EACdzF,KAAKoE,kBAET,CAKA,aAAIjD,GACF,OAAOnB,KAAKyI,UACd,CACA,aAAItH,CAAUoI,IAEZA,EAAc,eAARA,EAAuBA,EAAM,cACvBvJ,KAAKyI,aACfzI,KAAKyI,WAAac,EAClBvJ,KAAK0E,SAAmB,eAAR6E,EAAuB,QAAU,SACjDvJ,KAAKiI,kBAA4B,eAARsB,EAAuB,SAAW,QAC3DvJ,KAAK8H,aAAuB,eAARyB,EAAuB,OAAS,MACpDvJ,KAAK+H,sBAAgC,eAARwB,EAAuB,MAAQ,OAC5DvJ,KAAKwJ,iBAET,CAKA,gBAAIC,GACF,OAAOzJ,KAAK0I,aACd,CACA,gBAAIe,CAAaC,GACf,MAAM,UAAClE,EAAS,UAAEmE,GAAa3J,KAC/Bc,OAAOC,OAAOf,KAAK0I,cAAegB,GAC9BC,IAAc3J,KAAK2J,UAErB3J,KAAK4J,wBACIpE,IAAcxF,KAAKwF,WAC5BxF,KAAK6J,kBAET,CAKA,kBAAIC,GACF,OAAO9J,KAAKsI,aACd,CACA,kBAAIwB,CAAeC,GACjBjJ,OAAOC,OAAOf,KAAKsI,cAAeyB,GAClC,MAAMC,EAAShK,KAAK6G,gBACpB7G,KAAK6G,gBAAkB7G,KAAKsI,cAActI,KAAK8H,cAChCrH,KAAKwJ,IAAID,EAAShK,KAAK6G,kBACxB,GACZ7G,KAAK6J,kBAET,CAKAK,cAAAA,CAAeC,GAAQ,IACjBA,GAASnK,KAAK6I,kBAChB7I,KAAK6I,gBAAiB,EACtB7I,KAAKwH,UAET,CAEA,OAAIZ,CAAIwD,GACNpK,KAAK+I,KAAOqB,EACZpK,KAAKwJ,gBACP,CAEA,OAAI5C,GACF,GAAkB,OAAd5G,KAAK+I,KAAe,CACtB,MAAM,MAAC7I,EAAK,MAAEmK,GAASrK,KAAK+I,KAC5B,MAAO,CACL7I,MAAOO,KAAKmB,IAAI,EAAGnB,KAAKkB,IAAIzB,EAAOF,KAAKyF,MAAMC,OAAS,IACvD2E,QAEJ,CACA,OAAO,IACT,CAEAC,oBAAAA,CAAqBC,GACnB,OAAO9J,KAAKmB,KACT5B,KAAK4I,qBAAqB5I,KAAK8H,cAChCrH,KAAKkB,IAAI4I,EAAKvK,KAAK2I,gBAAgBjG,EAAK1C,KAAKmB,YAAcnB,KAAKwF,WAEpE,CAEAgF,KAAAA,GACoB,OAAdxK,KAAK+I,OACP/I,KAAKyK,uBACLzK,KAAK+I,KAAO,KAEhB,CAwBU2B,aAAAA,GACR,CAUF,aAAclF,GACZ,OAAOxF,KAAK0I,cAAc1I,KAAK0E,SACjC,CAKA,aAAciF,GACZ,OAAO3J,KAAK0I,cAAc1I,KAAKiI,kBACjC,CAEU7D,eAAAA,GACRpE,KAAK6I,gBAAiB,CACxB,CAEUe,qBAAAA,GACR5J,KAAK8I,sBAAuB,EAC5B9I,KAAKoE,iBACP,CAIUoF,cAAAA,GACRxJ,KAAK4J,wBAKLT,QAAQC,UAAUC,MAAK,IAAMrJ,KAAKkK,kBACpC,CAEU1C,OAAAA,GACJxH,KAAK8I,uBACP9I,KAAK0K,gBACL1K,KAAK8I,sBAAuB,GAE9B9I,KAAK2H,oBACL3H,KAAK2K,sBACL3K,KAAKqG,kBACLrG,KAAK4K,wBACL5K,KAAK6K,0BACP,CASUF,mBAAAA,GACR,GAAiB,OAAb3K,KAAK4G,IAAc,CACrB,MAAMkE,EAAqB9K,KAAK6G,iBAC1B,MAAC3G,EAAK,MAAEmK,GAASrK,KAAK4G,IAC5B5G,KAAK6G,gBACH7G,KAAK+K,iCAAiC,CACpC7K,QACAmK,MAAOA,GAAS,UACbrK,KAAK4I,qBAAqB5I,KAAK8H,cACtC9H,KAAKoH,aAAe0D,EAAqB9K,KAAK6G,eAChD,CACF,CAaUkE,gCAAAA,CAAiCX,GACzC,MAAM,MAACC,GAASD,EACVlK,EAAQO,KAAKkB,IAAI3B,KAAKyF,MAAMC,OAAQjF,KAAKmB,IAAI,EAAGwI,EAAQlK,QACxD8K,EAAoBhL,KAAK4H,iBAAiB1H,GAAOF,KAAK8H,cAC5D,IAAImD,EAAiBD,EACrB,GAAc,UAAVX,EAAmB,CACrB,MAAMa,EAAWlL,KAAKgI,aAAa9H,GAAOF,KAAK0E,UAC/C,GAAc,WAAV2F,EACFY,EACED,EAAoB,GAAMhL,KAAKwF,UAAY,GAAM0F,MAC9C,CACL,MAAMC,EAAkBH,EAAoBhL,KAAKwF,UAAY0F,EAC7D,GAAc,QAAVb,EACFY,EAAiBE,MACZ,CAEL,MAAMC,EAAwBpL,KAAK6G,gBACnCoE,EACExK,KAAKwJ,IAAImB,EAAwBJ,GACjCvK,KAAKwJ,IAAImB,EAAwBD,GAC7BH,EACAG,CACR,CACF,CACF,CAEA,OADAF,GAAkBjL,KAAK4I,qBAAqB5I,KAAK8H,cAC1C9H,KAAKsK,qBAAqBW,EACnC,CAEOI,4BAAAA,CACLjB,GAEA,MAAO,CACL,CAACpK,KAAK8H,cACJ9H,KAAK+K,iCAAiCX,GAE5C,CAEQK,oBAAAA,GACNzK,KAAKkJ,UAAU,CACblI,KAAM,YAEV,CAEQsK,6BAAAA,GACNtL,KAAKkJ,UAAU,CACblI,KAAM,oBACNuK,aAAcvL,KAAKkG,cACnBsF,YAAaxL,KAAKgJ,cAEtB,CAEU6B,wBAAAA,GACR,MAAMY,EAAiC,IAAI7L,IAC3C,IAAqB,IAAjBI,KAAK6E,SAAiC,IAAhB7E,KAAK8E,MAC7B,IAAK,IAAIR,EAAMtE,KAAK6E,OAAQP,GAAOtE,KAAK8E,MAAOR,IAC7CmH,EAAexL,IAAIqE,EAAKtE,KAAK4H,iBAAiBtD,IAGlD,MAAMoH,EAA+B,CACnC1K,KAAM,eACN2K,WAAY,CACV,CAAC3L,KAAK0E,UAAW1E,KAAKuF,YACtB,CAACvF,KAAKiI,mBAAoB,MAE5B2D,MAAO,CACLC,MAAO7L,KAAK6E,OACZiH,KAAM9L,KAAK8E,MACXyG,aAAcvL,KAAKkG,cACnBsF,YAAaxL,KAAKgJ,cAEpByC,kBAEEzL,KAAKoH,eACPsE,EAAQK,YAAc,CACpB,CAAC/L,KAAK8H,cAAe9H,KAAKoH,aAC1B,CAACpH,KAAK+H,uBAAwB,GAEhC/H,KAAKoH,aAAe,GAEtBpH,KAAKkJ,UAAUwC,EACjB,CAKA,QAAYM,GACV,OAAqB,IAAjBhM,KAAK6E,SAAiC,IAAhB7E,KAAK8E,MACtB,EAEF9E,KAAK8E,MAAQ9E,KAAK6E,OAAS,CACpC,CAEQgF,gBAAAA,GACN,GAAwB,IAAnB7J,KAAKwF,WAAmBxF,KAAKgM,KAAO,GAAoB,OAAdhM,KAAK+I,KAClD/I,KAAKoE,sBACA,CACL,MAAMzC,EAAMlB,KAAKmB,IAAI,EAAG5B,KAAK6G,gBAAkB7G,KAAK8G,WAC9ClF,EAAMnB,KAAKkB,IACf3B,KAAKuF,YACLvF,KAAK6G,gBAAkB7G,KAAKwF,UAAYxF,KAAK8G,WAE3C9G,KAAKwG,aAAe7E,GAAO3B,KAAKyG,aAAe7E,EACjD5B,KAAKoE,kBAELpE,KAAK4K,sBAAsB,CAACqB,MAAM,GAEtC,CACF,CAMUrB,qBAAAA,CAAsBR,GAC9B,IAAqB,IAAjBpK,KAAK6E,SAAiC,IAAhB7E,KAAK8E,MAAc,OAE7C,IAAIyG,EAAevL,KAAK6E,OACxB,KACE0G,EAAevL,KAAK8E,OACpBrE,KAAKC,MACHV,KAAK4H,iBAAiB2D,GAAcvL,KAAK8H,cACvC9H,KAAKgI,aAAauD,GAAcvL,KAAK0E,YACpCjE,KAAKC,MAAMV,KAAK6G,kBAErB0E,IAGF,IAAIC,EAAcxL,KAAK8E,MACvB,KACE0G,EAAcxL,KAAK6E,QACnBpE,KAAKC,MAAMV,KAAK4H,iBAAiB4D,GAAaxL,KAAK8H,gBACjDrH,KAAKC,MAAMV,KAAK6G,gBAAkB7G,KAAKwF,YAEzCgG,IAIAD,IAAiBvL,KAAKkG,eACtBsF,IAAgBxL,KAAKgJ,eAErBhJ,KAAKkG,cAAgBqF,EACrBvL,KAAKgJ,aAAewC,EAChBpB,GAAWA,EAAQ6B,MACrBjM,KAAKsL,gCAGX"}