# Generated by generate_sdk_wrappers.py. DO NOT EDIT

from abc import ABCMeta
from dataclasses import dataclass, field
from typing import Any, Optional
from uuid import uuid4

from luminarycloud.tables import RectilinearTable, _param_name_to_table_type
from google.protobuf.message import Message as _Message

from luminarycloud.tables import RectilinearTable
from luminarycloud.types import Vector3
from luminarycloud.types.adfloat import _to_ad_proto, _from_ad_proto
from luminarycloud._proto.client import simulation_pb2 as clientpb
from luminarycloud._proto.client.entity_pb2 import EntityIdentifier
import luminarycloud.params.enum._enum_wrappers as enum

from luminarycloud.params.param_wrappers._lib import ParamGroupWrapper, CodeRepr, create_unique_id

from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.adjoint_controls_fluid_ import (
    AdjointControlsFluid,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.adjoint_controls_fluid_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.basic_fluid_ import (
    BasicFluid,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.basic_fluid_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions_fluid_ import (
    BoundaryConditionsFluid,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions_fluid_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.fan_curve_inlet_ import (
    FanCurveInlet,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.fan_curve_inlet_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.farfield_ import (
    Farfield,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.farfield_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.initialization.fluid_existing_solution_ import (
    FluidExistingSolution,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.initialization.fluid_existing_solution_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.initialization.fluid_farfield_values_ import (
    FluidFarfieldValues,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.initialization.fluid_farfield_values_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.initialization.fluid_prescribed_values_ import (
    FluidPrescribedValues,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.initialization.fluid_prescribed_values_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.initialization_fluid_ import (
    InitializationFluid,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.initialization_fluid_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet_ import (
    Inlet,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.turbulence.komega_sst_ import (
    KomegaSst,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.turbulence.komega_sst_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.mass_flow_inlet_ import (
    MassFlowInlet,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.mass_flow_inlet_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.outlet_ import (
    Outlet,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.outlet_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.periodic_pair_ import PeriodicPair
from luminarycloud.params.param_wrappers.simulation_param.physics.periodic_pair_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.physical_behavior_ import (
    PhysicalBehavior,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.physical_behavior_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.porous_behavior_ import (
    PorousBehavior,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.porous_behavior_ import *
from luminarycloud.params.param_wrappers.simulation_param.sliding_interfaces_ import (
    SlidingInterfaces,
)
from luminarycloud.params.param_wrappers.simulation_param.sliding_interfaces_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.solution_controls_fluid_ import (
    SolutionControlsFluid,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.solution_controls_fluid_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.turbulence.spalart_allmaras_ import (
    SpalartAllmaras,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.turbulence.spalart_allmaras_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.spatial_discretization_fluid_ import (
    SpatialDiscretizationFluid,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.spatial_discretization_fluid_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.symmetry_ import (
    Symmetry,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.symmetry_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.total_pressure_inlet_ import (
    TotalPressureInlet,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.total_pressure_inlet_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.turbulence_ import (
    Turbulence,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.turbulence_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.velocity_components_inlet_ import (
    VelocityComponentsInlet,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.velocity_components_inlet_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.velocity_magnitude_inlet_ import (
    VelocityMagnitudeInlet,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.inlet.velocity_magnitude_inlet_ import *
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.wall_ import (
    Wall,
)
from luminarycloud.params.param_wrappers.simulation_param.physics.fluid.boundary_conditions.wall_ import *


@dataclass(kw_only=True)
class Fluid(CodeRepr, ParamGroupWrapper[clientpb.Fluid]):
    """Configuration for a fluid flow physics solver - simulates the flow of liquids and gases."""

    basic: Optional[BasicFluid] = field(default_factory=BasicFluid)
    "Basic settings for a fluid flow physics solver."
    turbulence: Optional[Turbulence] = field(default_factory=SpalartAllmaras)
    "Turbulence settings for a fluid flow physics solver."
    solution_controls: Optional[SolutionControlsFluid] = field(
        default_factory=SolutionControlsFluid
    )
    "Solution controls for a fluid flow physics solver."
    adjoint_controls: Optional[AdjointControlsFluid] = field(default_factory=AdjointControlsFluid)
    ""
    spatial_discretization: Optional[SpatialDiscretizationFluid] = field(
        default_factory=SpatialDiscretizationFluid
    )
    "Spatial discretization settings for a fluid flow physics solver."
    boundary_conditions: list[BoundaryConditionsFluid] = field(default_factory=list)
    "Boundary conditions for a fluid flow physics solver."
    sliding_interfaces: list[SlidingInterfaces] = field(default_factory=list)
    "Defines the two sides that form a sliding interface. The two sides are abutting, possibly in combination with a periodic transformation, and should have the same normal grid velocity. The tangential grid velocity can, and usually will, be different. Each side of the sliding interface can be composed out of an arbitrary number of surfaces."
    periodic_pair: list[PeriodicPair] = field(default_factory=list)
    "Defines the input options needed for periodic boundaries. We assume each periodic BC can have translational OR rotational periodicity. To transform a point on boundary A to its periodically matching point on boundary B, we first subtract the center of rotation from the point coordinates to get the distance vector from the center to the point of interest, then we apply rotation around the periodicity axis and add back the center of rotation to get the coordinates of the transformed point."
    initialization: Optional[InitializationFluid] = field(default_factory=FluidPrescribedValues)
    "Type of initial condition for the field variables."
    physical_behavior: list[PhysicalBehavior] = field(default_factory=list)
    "Physical behavior settings for a fluid flow physics solver."
    porous_behavior: list[PorousBehavior] = field(default_factory=list)
    "Porous model settings for a fluid flow physics solver."

    def _to_proto(self) -> clientpb.Fluid:
        _proto = clientpb.Fluid()
        if self.basic is not None:
            _proto.basic_fluid.CopyFrom(self.basic._to_proto())
        if self.turbulence is not None:
            _proto.turbulence.CopyFrom(self.turbulence._to_proto())
        if self.solution_controls is not None:
            _proto.solution_controls_fluid.CopyFrom(self.solution_controls._to_proto())
        if self.adjoint_controls is not None:
            _proto.adjoint_controls_fluid.CopyFrom(self.adjoint_controls._to_proto())
        if self.spatial_discretization is not None:
            _proto.spatial_discretization_fluid.CopyFrom(self.spatial_discretization._to_proto())
        if self.boundary_conditions is not None:
            _proto.boundary_conditions_fluid.extend(v._to_proto() for v in self.boundary_conditions)
        if self.sliding_interfaces is not None:
            _proto.sliding_interfaces.extend(v._to_proto() for v in self.sliding_interfaces)
        if self.periodic_pair is not None:
            _proto.periodic_pair.extend(v._to_proto() for v in self.periodic_pair)
        if self.initialization is not None:
            _proto.initialization_fluid.CopyFrom(self.initialization._to_proto())
        if self.physical_behavior is not None:
            _proto.physical_behavior.extend(v._to_proto() for v in self.physical_behavior)
        if self.porous_behavior is not None:
            _proto.porous_behavior.extend(v._to_proto() for v in self.porous_behavior)
        return _proto

    def _from_proto(self, proto: clientpb.Fluid) -> None:
        self.basic = BasicFluid.from_proto(proto.basic_fluid)
        if proto.turbulence.turbulence_model == clientpb.INVALID_TURBULENCE_MODEL:
            raise ValueError("Invalid turbulence")
        elif proto.turbulence.turbulence_model == clientpb.SPALART_ALLMARAS:
            self.turbulence = SpalartAllmaras()
            self.turbulence.qcr = enum.QcrSa(proto.turbulence.qcr_sa)
            self.turbulence.rotation_correction = enum.RotationCorrectionSa(
                proto.turbulence.rotation_correction_sa
            )
            if (
                proto.turbulence.turbulence_model_constants
                == clientpb.INVALID_TURBULENCE_MODEL_CONSTANTS
            ):
                raise ValueError("Invalid spalart_allmaras_constants")
            elif proto.turbulence.turbulence_model_constants == clientpb.DEFAULT_TURB_CONSTANTS:
                self.turbulence.constants = DefaultSpalartAllmarasConstants()
            elif proto.turbulence.turbulence_model_constants == clientpb.CUSTOM_TURB_CONSTANTS:
                self.turbulence.constants = CustomSpalartAllmarasConstants()
                self.turbulence.constants.c_rot = _from_ad_proto(proto.turbulence.c_rot)
                self.turbulence.constants.c_des = _from_ad_proto(proto.turbulence.C_sa_des)
                self.turbulence.constants.c_b_1 = _from_ad_proto(proto.turbulence.c_b_1)
                self.turbulence.constants.sigma = _from_ad_proto(proto.turbulence.sigma)
                self.turbulence.constants.c_b_2 = _from_ad_proto(proto.turbulence.c_b_2)
                self.turbulence.constants.kappa = _from_ad_proto(proto.turbulence.kappa)
                self.turbulence.constants.c_w_2 = _from_ad_proto(proto.turbulence.c_w_2)
                self.turbulence.constants.c_w_3 = _from_ad_proto(proto.turbulence.c_w_3)
                self.turbulence.constants.c_v_1 = _from_ad_proto(proto.turbulence.c_v_1)
                self.turbulence.constants.c_t_3 = _from_ad_proto(proto.turbulence.c_t_3)
                self.turbulence.constants.c_t_4 = _from_ad_proto(proto.turbulence.c_t_4)
                self.turbulence.constants.c_r_1 = _from_ad_proto(proto.turbulence.c_r_1)
        elif proto.turbulence.turbulence_model == clientpb.KOMEGA_SST:
            self.turbulence = KomegaSst()
            self.turbulence.qcr = enum.QcrSst(proto.turbulence.qcr_sst)
            self.turbulence.kato_launder = proto.turbulence.kato_launder
            if (
                proto.turbulence.turbulence_model_constants
                == clientpb.INVALID_TURBULENCE_MODEL_CONSTANTS
            ):
                raise ValueError("Invalid komega_sst_constants")
            elif proto.turbulence.turbulence_model_constants == clientpb.DEFAULT_TURB_CONSTANTS:
                self.turbulence.constants = DefaultKomegaSstConstants()
            elif proto.turbulence.turbulence_model_constants == clientpb.CUSTOM_TURB_CONSTANTS:
                self.turbulence.constants = CustomKomegaSstConstants()
                self.turbulence.constants.c_des1 = _from_ad_proto(proto.turbulence.C_sst_des1)
                self.turbulence.constants.c_des2 = _from_ad_proto(proto.turbulence.C_sst_des2)
                self.turbulence.constants.sigma_k_1 = _from_ad_proto(proto.turbulence.sigma_k_1)
                self.turbulence.constants.sigma_k_2 = _from_ad_proto(proto.turbulence.sigma_k_2)
                self.turbulence.constants.sigma_w_1 = _from_ad_proto(proto.turbulence.sigma_w_1)
                self.turbulence.constants.sigma_w_2 = _from_ad_proto(proto.turbulence.sigma_w_2)
                self.turbulence.constants.beta_1 = _from_ad_proto(proto.turbulence.beta_1)
                self.turbulence.constants.beta_2 = _from_ad_proto(proto.turbulence.beta_2)
                self.turbulence.constants.beta_star = _from_ad_proto(proto.turbulence.beta_star)
                self.turbulence.constants.kappa = _from_ad_proto(proto.turbulence.kappa_sst)
                self.turbulence.constants.a_1 = _from_ad_proto(proto.turbulence.a_1)
                self.turbulence.constants.gamma_1 = _from_ad_proto(proto.turbulence.gamma_1)
                self.turbulence.constants.gamma_2 = _from_ad_proto(proto.turbulence.gamma_2)
        self.solution_controls = SolutionControlsFluid.from_proto(proto.solution_controls_fluid)
        self.adjoint_controls = AdjointControlsFluid.from_proto(proto.adjoint_controls_fluid)
        self.spatial_discretization = SpatialDiscretizationFluid.from_proto(
            proto.spatial_discretization_fluid
        )
        for proto_boundary_conditions_fluid in proto.boundary_conditions_fluid:
            if (
                proto_boundary_conditions_fluid.physical_boundary
                == clientpb.INVALID_PHYSICAL_BOUNDARY
            ):
                raise ValueError("Invalid boundary_conditions_fluid")
            elif proto_boundary_conditions_fluid.physical_boundary == clientpb.WALL:
                self.boundary_conditions.append(Wall())
                self.boundary_conditions[-1]._from_proto(proto_boundary_conditions_fluid)
            elif proto_boundary_conditions_fluid.physical_boundary == clientpb.INLET:
                self.boundary_conditions.append(Inlet())
                if (
                    proto_boundary_conditions_fluid.inlet_momentum
                    == clientpb.INVALID_INLET_MOMENTUM
                ):
                    raise ValueError("Invalid inlet")
                elif proto_boundary_conditions_fluid.inlet_momentum == clientpb.VELOCITY_INLET:
                    self.boundary_conditions[-1] = VelocityMagnitudeInlet()
                elif (
                    proto_boundary_conditions_fluid.inlet_momentum
                    == clientpb.VELOCITY_COMPONENTS_INLET
                ):
                    self.boundary_conditions[-1] = VelocityComponentsInlet()
                elif (
                    proto_boundary_conditions_fluid.inlet_momentum == clientpb.TOTAL_PRESSURE_INLET
                ):
                    self.boundary_conditions[-1] = TotalPressureInlet()
                elif proto_boundary_conditions_fluid.inlet_momentum == clientpb.MASS_FLOW_INLET:
                    self.boundary_conditions[-1] = MassFlowInlet()
                elif proto_boundary_conditions_fluid.inlet_momentum == clientpb.FAN_CURVE_INLET:
                    self.boundary_conditions[-1] = FanCurveInlet()
                self.boundary_conditions[-1]._from_proto(proto_boundary_conditions_fluid)
            elif proto_boundary_conditions_fluid.physical_boundary == clientpb.OUTLET:
                self.boundary_conditions.append(Outlet())
                self.boundary_conditions[-1]._from_proto(proto_boundary_conditions_fluid)
            elif proto_boundary_conditions_fluid.physical_boundary == clientpb.SYMMETRY:
                self.boundary_conditions.append(Symmetry())
                self.boundary_conditions[-1]._from_proto(proto_boundary_conditions_fluid)
            elif proto_boundary_conditions_fluid.physical_boundary == clientpb.FARFIELD:
                self.boundary_conditions.append(Farfield())
                self.boundary_conditions[-1]._from_proto(proto_boundary_conditions_fluid)
        self.sliding_interfaces = [
            SlidingInterfaces.from_proto(v) for v in proto.sliding_interfaces
        ]
        self.periodic_pair = [PeriodicPair.from_proto(v) for v in proto.periodic_pair]
        if proto.initialization_fluid.initialization_type == clientpb.INVALID_INITIALIZATION_TYPE:
            raise ValueError("Invalid initialization_fluid")
        elif proto.initialization_fluid.initialization_type == clientpb.UNIFORM_VALUES:
            self.initialization = FluidPrescribedValues()
            self.initialization.pressure = _from_ad_proto(proto.initialization_fluid.uniform_p)
            self.initialization.velocity._from_ad_proto(proto.initialization_fluid.uniform_v)
            self.initialization.temperature = _from_ad_proto(proto.initialization_fluid.uniform_t)
            if (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INVALID_TURBULENT_VARIABLE_INITIALIZATION_TYPE_SA
            ):
                raise ValueError("Invalid spalart_allmaras_initialization")
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INIT_TURBULENT_VISCOSITY_RATIO_SA
            ):
                self.initialization.turbulence.spalart_allmaras = InitTurbulentViscosityRatioSa()
                self.initialization.turbulence.spalart_allmaras.viscosity_ratio = _from_ad_proto(
                    proto.initialization_fluid.init_turbulent_viscosity_ratio
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INIT_TURBULENT_VISCOSITY_SA
            ):
                self.initialization.turbulence.spalart_allmaras = InitTurbulentViscositySa()
                self.initialization.turbulence.spalart_allmaras.viscosity = _from_ad_proto(
                    proto.initialization_fluid.init_turbulent_viscosity
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INIT_SA_VARIABLE
            ):
                self.initialization.turbulence.spalart_allmaras = InitSaVariable()
                self.initialization.turbulence.spalart_allmaras.sa_variable = _from_ad_proto(
                    proto.initialization_fluid.uniform_nu_tilde
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INIT_FARFIELD_VALUES_SA
            ):
                self.initialization.turbulence.spalart_allmaras = InitFarfieldValuesSa()
            if (
                proto.initialization_fluid.turbulent_variable_initialization_type_komega
                == clientpb.INVALID_TURBULENT_VARIABLE_INITIALIZATION_TYPE_KOMEGA
            ):
                raise ValueError("Invalid komega_initialization")
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_komega
                == clientpb.INIT_TURBULENT_VISCOSITY_RATIO_AND_INTENSITY_KOMEGA
            ):
                self.initialization.turbulence.komega = (
                    InitTurbulentViscosityRatioAndIntensityKomega()
                )
                self.initialization.turbulence.komega.viscosity_ratio = _from_ad_proto(
                    proto.initialization_fluid.init_turbulent_viscosity_ratio
                )
                self.initialization.turbulence.komega.intensity = _from_ad_proto(
                    proto.initialization_fluid.init_turbulence_intensity
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_komega
                == clientpb.INIT_TURBULENT_VISCOSITY_AND_INTENSITY_KOMEGA
            ):
                self.initialization.turbulence.komega = InitTurbulentViscosityAndIntensityKomega()
                self.initialization.turbulence.komega.viscosity = _from_ad_proto(
                    proto.initialization_fluid.init_turbulent_viscosity
                )
                self.initialization.turbulence.komega.intensity = _from_ad_proto(
                    proto.initialization_fluid.init_turbulence_intensity
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_komega
                == clientpb.INIT_FARFIELD_VALUES_KOMEGA
            ):
                self.initialization.turbulence.komega = InitFarfieldValuesKomega()
        elif proto.initialization_fluid.initialization_type == clientpb.FARFIELD_VALUES:
            self.initialization = FluidFarfieldValues()
            if (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INVALID_TURBULENT_VARIABLE_INITIALIZATION_TYPE_SA
            ):
                raise ValueError("Invalid spalart_allmaras_initialization")
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INIT_TURBULENT_VISCOSITY_RATIO_SA
            ):
                self.initialization.turbulence.spalart_allmaras = InitTurbulentViscosityRatioSa()
                self.initialization.turbulence.spalart_allmaras.viscosity_ratio = _from_ad_proto(
                    proto.initialization_fluid.init_turbulent_viscosity_ratio
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INIT_TURBULENT_VISCOSITY_SA
            ):
                self.initialization.turbulence.spalart_allmaras = InitTurbulentViscositySa()
                self.initialization.turbulence.spalart_allmaras.viscosity = _from_ad_proto(
                    proto.initialization_fluid.init_turbulent_viscosity
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INIT_SA_VARIABLE
            ):
                self.initialization.turbulence.spalart_allmaras = InitSaVariable()
                self.initialization.turbulence.spalart_allmaras.sa_variable = _from_ad_proto(
                    proto.initialization_fluid.uniform_nu_tilde
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_sa
                == clientpb.INIT_FARFIELD_VALUES_SA
            ):
                self.initialization.turbulence.spalart_allmaras = InitFarfieldValuesSa()
            if (
                proto.initialization_fluid.turbulent_variable_initialization_type_komega
                == clientpb.INVALID_TURBULENT_VARIABLE_INITIALIZATION_TYPE_KOMEGA
            ):
                raise ValueError("Invalid komega_initialization")
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_komega
                == clientpb.INIT_TURBULENT_VISCOSITY_RATIO_AND_INTENSITY_KOMEGA
            ):
                self.initialization.turbulence.komega = (
                    InitTurbulentViscosityRatioAndIntensityKomega()
                )
                self.initialization.turbulence.komega.viscosity_ratio = _from_ad_proto(
                    proto.initialization_fluid.init_turbulent_viscosity_ratio
                )
                self.initialization.turbulence.komega.intensity = _from_ad_proto(
                    proto.initialization_fluid.init_turbulence_intensity
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_komega
                == clientpb.INIT_TURBULENT_VISCOSITY_AND_INTENSITY_KOMEGA
            ):
                self.initialization.turbulence.komega = InitTurbulentViscosityAndIntensityKomega()
                self.initialization.turbulence.komega.viscosity = _from_ad_proto(
                    proto.initialization_fluid.init_turbulent_viscosity
                )
                self.initialization.turbulence.komega.intensity = _from_ad_proto(
                    proto.initialization_fluid.init_turbulence_intensity
                )
            elif (
                proto.initialization_fluid.turbulent_variable_initialization_type_komega
                == clientpb.INIT_FARFIELD_VALUES_KOMEGA
            ):
                self.initialization.turbulence.komega = InitFarfieldValuesKomega()
        elif proto.initialization_fluid.initialization_type == clientpb.EXISTING_SOLUTION:
            self.initialization = FluidExistingSolution()
            self.initialization.solution_id = proto.initialization_fluid.existing_solution_id
        self.physical_behavior = [PhysicalBehavior.from_proto(v) for v in proto.physical_behavior]
        self.porous_behavior = [PorousBehavior.from_proto(v) for v in proto.porous_behavior]
        return None
