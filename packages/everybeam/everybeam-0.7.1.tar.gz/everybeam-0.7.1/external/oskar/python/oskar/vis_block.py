# -*- coding: utf-8 -*-
#
# Copyright (c) 2016-2020, The University of Oxford
# All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions are met:
#  1. Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. Neither the name of the University of Oxford nor the names of its
#     contributors may be used to endorse or promote products derived from this
#     software without specific prior written permission.
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#

"""Interfaces to the OSKAR visibility block."""

from __future__ import absolute_import, division, print_function
try:
    from . import _vis_block_lib
except ImportError:
    _vis_block_lib = None

# pylint: disable=useless-object-inheritance
class VisBlock(object):
    """This class provides a Python interface to an OSKAR visibility block.

    The :class:`oskar.VisBlock` class encapuslates a portion (or a block) of
    visibility data generated by :class:`oskar.Interferometer`.
    It should always be interpreted using the corresponding
    :class:`oskar.VisHeader`, as the data will be meaningless if taken
    out of context.

    To create a :class:`oskar.VisBlock`, use the
    :meth:`create_from_header() <oskar.VisBlock.create_from_header>` method.

    To read a visibility data block from an OSKAR binary file, first call the
    :meth:`oskar.VisHeader.read` class method. This will return a tuple
    containing both the header data and also a handle to the binary file,
    which can be used to read subsequent :class:`oskar.VisBlock` data structures
    from the same file using the :meth:`read() <oskar.VisBlock.read>` method on
    this class. See below for an example of how this can be done.

    To access the visibility data, use the method
    :meth:`cross_correlations() <oskar.VisBlock.cross_correlations>` (and
    :meth:`auto_correlations() <oskar.VisBlock.auto_correlations>`, if present),
    which return references to numpy arrays. Similarly, the methods
    :meth:`baseline_uu_metres() <oskar.VisBlock.baseline_uu_metres>`,
    :meth:`baseline_vv_metres() <oskar.VisBlock.baseline_vv_metres>` and
    :meth:`baseline_ww_metres() <oskar.VisBlock.baseline_ww_metres>` return
    references to the baseline coordinate data in the block.

    The visibility data array is four-dimensional and has the shape
    ``(num_times_per_block, num_channels, num_baselines, num_pols)``, where the
    polarisation dimension is the fastest varying and the time dimension is the
    slowest varying. The baseline coordinate arrays have dimensions
    ``(num_times_per_block, num_baselines)``.
    These are standard numpy arrays which can be accessed from Python
    in the normal way. Use the :meth:`num_times <oskar.VisBlock.num_times>`
    property to determine the actual number of usable time samples in the block.

    Note that since these are array *references*, it is possible to modify
    data inside the visibility block as well as read it:
    This allows easy post-processing of visibility data, for example,
    by subtracting data in one visibility block from another, or by modifying
    visibilities as they are generated using a subclass of
    :class:`oskar.Interferometer` in the
    :meth:`process_block() <oskar.Interferometer.process_block>` method.

    Examples:

        To read all visibility blocks from a file ``example.vis``:

        >>> (header, handle) = oskar.VisHeader.read('example.vis')
        >>> block = oskar.VisBlock.create_from_header(header)
        >>> print(header.num_blocks)
        3
        >>> for i in range(header.num_blocks):
        >>>     block.read(header, handle, i)
        >>>     print(block.start_time_index)
        0
        8
        16

        To get the shape of the visibility data block numpy array:

        >>> (header, handle) = oskar.VisHeader.read('example.vis')
        >>> block = oskar.VisBlock.create_from_header(header)
        >>> vis = block.cross_correlations()
        >>> # Shape is (num_times_per_block, num_channels, num_baselines, num_pols)
        >>> print(vis.shape)
        (8, 3, 435, 4)

    """

    def __init__(self):
        """Constructs a handle to a visibility block."""
        if _vis_block_lib is None:
            raise RuntimeError("OSKAR library not found.")
        self._capsule = None

    def auto_correlations(self):
        """Returns an array reference to the auto correlations."""
        self.capsule_ensure()
        return _vis_block_lib.auto_correlations(self._capsule)

    def baseline_uu_metres(self):
        """Returns an array reference to the block baseline uu coordinates."""
        self.capsule_ensure()
        return _vis_block_lib.baseline_uu_metres(self._capsule)

    def baseline_vv_metres(self):
        """Returns an array reference to the block baseline vv coordinates."""
        self.capsule_ensure()
        return _vis_block_lib.baseline_vv_metres(self._capsule)

    def baseline_ww_metres(self):
        """Returns an array reference to the block baseline ww coordinates."""
        self.capsule_ensure()
        return _vis_block_lib.baseline_ww_metres(self._capsule)

    def capsule_ensure(self):
        """Ensures the C capsule exists."""
        if self._capsule is None:
            raise RuntimeError(
                "Call oskar.VisBlock.create_from_header() to create the block.")

    def capsule_get(self):
        """Returns the C capsule wrapped by the class."""
        return self._capsule

    def capsule_set(self, new_capsule):
        """Sets the C capsule wrapped by the class.

        Args:
            new_capsule (capsule): The new capsule to set.
        """
        if _vis_block_lib.capsule_name(new_capsule) == 'oskar_VisBlock':
            del self._capsule
            self._capsule = new_capsule
        else:
            raise RuntimeError("Capsule is not of type oskar_VisBlock.")

    @classmethod
    def create_from_header(cls, header):
        """Creates a visibility block from a header.

        Args:
            header (oskar.VisHeader): Visibility data header.
        """
        block = VisBlock()
        block.capsule = _vis_block_lib.create_from_header(header.capsule)
        return block

    def cross_correlations(self):
        """Returns an array reference to the cross correlations."""
        self.capsule_ensure()
        return _vis_block_lib.cross_correlations(self._capsule)

    def get_num_baselines(self):
        """Returns the number of baselines."""
        self.capsule_ensure()
        return _vis_block_lib.num_baselines(self._capsule)

    def get_num_channels(self):
        """Returns the number of frequency channels."""
        self.capsule_ensure()
        return _vis_block_lib.num_channels(self._capsule)

    def get_num_pols(self):
        """Returns the number of polarisations."""
        self.capsule_ensure()
        return _vis_block_lib.num_pols(self._capsule)

    def get_num_stations(self):
        """Returns the number of stations."""
        self.capsule_ensure()
        return _vis_block_lib.num_stations(self._capsule)

    def get_num_times(self):
        """Returns the number of time samples."""
        self.capsule_ensure()
        return _vis_block_lib.num_times(self._capsule)

    def get_start_channel_index(self):
        """Returns the start channel index."""
        self.capsule_ensure()
        return _vis_block_lib.start_channel_index(self._capsule)

    def get_start_time_index(self):
        """Returns the start time index."""
        self.capsule_ensure()
        return _vis_block_lib.start_time_index(self._capsule)

    # Properties
    capsule = property(capsule_get, capsule_set)
    num_baselines = property(get_num_baselines)
    num_channels = property(get_num_channels)
    num_pols = property(get_num_pols)
    num_stations = property(get_num_stations)
    num_times = property(get_num_times)
    start_channel_index = property(get_start_channel_index)
    start_time_index = property(get_start_time_index)

    def read(self, header, binary_handle, block_index):
        """Reads visibility data from a binary file into the visibility block.

        Use :meth:`oskar.VisHeader.read()` to obtain the header and
        binary file handle.

        Args:
            header (oskar.VisHeader): Visibility data header.
            binary_handle (oskar.Binary): Handle to binary file.
            block_index (int): Visibility block index to read.
        """
        self.capsule_ensure()
        _vis_block_lib.read_block(self._capsule, header.capsule,
                                  binary_handle.capsule, block_index)
