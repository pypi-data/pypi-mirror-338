(function(M,d){typeof exports=="object"&&typeof module<"u"?d(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],d):(M=typeof globalThis<"u"?globalThis:M||self,d(M.trame_vtklocal={},M.Vue))})(this,function(M,d){"use strict";const x="",y=[];function C(l){return new Promise(function(e,n){if(y.indexOf(l)===-1){y.push(l);var t=document.createElement("script");t.type="module",t.src=l,t.onload=e,t.onerror=n,document.body.appendChild(t)}else e(!1)})}class T{constructor(){this.updateInProgress=0,this.loaded=!1,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={},this.renderWindowIds=new Set,this.renderWindowIdToInteractorId=new Map,this.renderWindowSizes={},this.offlineCanvasContainer=document.createElement("div"),this.offlineCanvasContainer.setAttribute("class","unused-canvas"),document.body.appendChild(this.offlineCanvasContainer)}async load(e){if(this.loaded)return;const n=`${e}/vtkWasmSceneManager.mjs`;await C(n);const t=await window.createVTKWasmSceneManager();t.initialize(),this.loaded=!0,this.sceneManager=t}bindNetwork(e,n,t){this.networkFetchState=e,this.networkFetchHash=n,this.networkFetchStatus=t}freeMemory(e=0){const n=this.sceneManager.getTotalBlobMemoryUsage(),t=Number(e);if(n>t){const s={};let o=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([h,a])=>{a<o&&(o=a);const g=a.toString();s[g]?s[g].push(h):s[g]=[h]});this.sceneManager.getTotalBlobMemoryUsage()>t;){const h=s[o];if(h)for(let a=0;a<h.length;a++)this.sceneManager.unRegisterBlob(h[a]),delete this.hashesMTime[h[a]];o++}}}async fetchState(e){const n=await this.networkFetchState(e);return this.patchState(n)}patchState(e){var n;if(e.length>0){const t=JSON.parse(e),{Id:s,MTime:o}=t;return this.stateMTimes[s]=o,this.renderWindowIds.has(s)&&((n=t==null?void 0:t.Interactor)!=null&&n.Id)?(this.renderWindowIdToInteractorId.set(t.Interactor.Id,s),t.CanvasSelector=this.getCanvasSelector(s),delete t.Size,this.renderWindowSizes[s]&&(t.Size=this.renderWindowSizes[s]),t.ClassName="vtkCocoaRenderWindow",JSON.stringify(t)):this.renderWindowIdToInteractorId.has(s)?(t.CanvasSelector=this.getCanvasSelector(this.renderWindowIdToInteractorId.get(s)),JSON.stringify(t)):e}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const n=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,n),this.hashesMTime[e]=this.currentMTime,n}pushHash(e,n){return this.pendingArrays[e]=new Promise(t=>{n.arrayBuffer?n.arrayBuffer().then(s=>{this.sceneManager.registerBlob(e,new Uint8Array(s)),this.hashesMTime[e]=this.currentMTime,t()}):(this.sceneManager.registerBlob(e,n),this.hashesMTime[e]=this.currentMTime,t())}),this.pendingArrays[e]}async update(e){if(this.renderWindowIds.add(e),this.updateInProgress++,this.updateInProgress===1)try{const n=await this.networkFetchStatus(e),t=[],s=[],o=n.force_push||[];for(let a=0;a<o.length;a++)delete this.stateMTimes[o[a]];n.ids.forEach(([a,g])=>{(!this.stateMTimes[a]||this.stateMTimes[a]<g)&&s.push(this.fetchState(a))}),n.hashes.forEach(a=>{this.hashesMTime[a]||t.push(this.fetchHash(a)),this.hashesMTime[a]=this.currentMTime}),n.cameras.forEach(a=>this.cameraIds.add(Number(a))),n.ignore_ids.forEach(a=>this.sceneManager.unRegisterState(a)),await Promise.all(t),await Promise.all(Object.values(this.pendingArrays));const h=await Promise.all(s);for(this.currentMTime++;h.length;){const a=h.pop();a&&this.sceneManager.registerState(a)}try{this.sceneManager.updateObjectsFromStates();const[a,g]=this.renderWindowSizes[e]||[10,10];this.sceneManager.setSize(e,a,g),this.sceneManager.render(e)}catch(a){console.error("WASM update failed"),console.log(a)}}catch(n){console.error("Error in update",n)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update(e))}}getState(e,n=!1){const t=Number(e);return n&&this.stateCache[t]?this.stateCache[t]:(this.sceneManager.updateStateFromObject(t),this.sceneManager.getState(t))}clearStateCache(){this.stateCache={}}getStateValue(e,n=!1){const t=Array.isArray(e)?e:[e];let s=null;for(let o=0;o<t.length;o++){const h=t[o];o===0?s=this.getState(h,n):(s=s[h],s.Id&&(s=this.getState(s.Id,n)))}return s}getCanvasSelector(e){return`.vtk-wasm-${e}`}bindCanvasToDOM(e,n){const t=this.getCanvasSelector(e);let s=this.offlineCanvasContainer.querySelector(t);return s||(s=document.createElement("canvas"),s.setAttribute("class",t.substring(1)),s.setAttribute("tabindex","0")),n.appendChild(s),t}unbindCanvasToDOM(e){const n=this.getCanvasSelector(e),t=document.querySelector(n);t&&this.offlineCanvasContainer.appendChild(t)}setSize(e,n,t){this.renderWindowSizes[e]=[n,t];const s=this.getCanvasSelector(e),o=document.querySelector(s);o&&(o.width=n,o.height=t,this.sceneManager.setSize(e,n,t),this.sceneManager.render(e))}}function S(l,e,n){return function(){e.clearStateCache();for(const[t,s]of Object.entries(n)){const o={};for(const[h,a]of Object.entries(s))o[h]=e.getStateValue(a,!0);l.state.set(t,o)}e.clearStateCache()}}const w={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera","invoke-response"],props:{renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},verbosity:{type:Object,default:()=>({objectManager:null,invoker:null,deserializer:null,serializer:null})},listeners:{type:Object}},setup(l,{emit:e}){const n=d.inject("trame"),t=n.state.get("__trame_vtklocal_wasm_url"),s=[],o=[],h=d.ref(null),a=l.wsClient||(n==null?void 0:n.client),g=d.toRef(l,"listeners"),r=new T;let m=null;async function I(i){return await a.getConnection().getSession().call("vtklocal.get.state",[i])}async function O(i){const f=await a.getConnection().getSession().call("vtklocal.get.hash",[i]);return f.arrayBuffer?new Uint8Array(await f.arrayBuffer()):f}async function z(i){return await a.getConnection().getSession().call("vtklocal.get.status",[i])}function W([i]){i.type==="state"&&r.pushState(i.content),i.type==="blob"&&r.pushHash(i.hash,i.content)}async function j(){const i=a.getConnection().getSession();m=i.subscribe("vtklocal.subscriptions",W),await i.call("vtklocal.subscribe.update",[l.renderWindow,1])}async function A(){const i=a.getConnection().getSession();m&&(i.unsubscribe(m),m=null),await i.call("vtklocal.subscribe.update",[l.renderWindow,-1])}function E(){const{width:i,height:c}=h.value.getBoundingClientRect(),f=Math.floor(i*window.devicePixelRatio+.5),u=Math.floor(c*window.devicePixelRatio+.5);r.setSize(l.renderWindow,f,u)}let b=new ResizeObserver(E);function V(){r.freeMemory(l.cacheSize),e("memory-vtk",r.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",r.sceneManager.getTotalBlobMemoryUsage())}async function p(){r.loaded&&(await r.update(l.renderWindow),e("updated"),V())}function L(i){r.sceneManager.resetCamera(i),r.sceneManager.render(l.renderWindow)}async function F(i,c,f){const u=await r.sceneManager.invoke(i,c,f);return u.Id&&u.Success&&(u.Value=r.getState(u.Id)),e("invoke-response",u),u}function N(){r.sceneManager.printSceneManagerInformation()}d.onMounted(async()=>{r.bindNetwork(I,O,z),await r.load(t);const i=r.bindCanvasToDOM(l.renderWindow,d.unref(h));d.unref(h).querySelector(i).setAttribute("style","position: absolute; left: 0; top: 0; width: 100%; height: 100%;"),l.eagerSync&&j(),b&&b.observe(d.unref(h)),await p(),r.cameraIds.forEach(c=>{s.push([c,r.sceneManager.addObserver(c,"ModifiedEvent",()=>{e("camera",r.getState(c))})])}),d.watchEffect(()=>{for(;o.length;){const[c,f]=o.pop();r.sceneManager.removeObserver(c,f)}for(const[c,f]of Object.entries(g.value||{})){const u=Number(c);for(const[P,R]of Object.entries(f||{})){const v=S(n,r,R);o.push([u,r.sceneManager.addObserver(u,P,v)]),v()}}}),d.watchEffect(()=>{const c=l.verbosity;c.objectManager&&r.sceneManager.setObjectManagerLogVerbosity&&r.sceneManager.setObjectManagerLogVerbosity(c.objectManager),c.invoker&&r.sceneManager.setInvokerLogVerbosity&&r.sceneManager.setInvokerLogVerbosity(c.invoker),c.deserializer&&r.sceneManager.setDeserializerLogVerbosity&&r.sceneManager.setDeserializerLogVerbosity(c.deserializer),c.serializer&&r.sceneManager.setSerializerLogVerbosity&&r.sceneManager.setSerializerLogVerbosity(c.serializer)}),r.sceneManager.startEventLoop(l.renderWindow)}),d.onBeforeUnmount(()=>{for(m&&A();s.length;){const[i,c]=s.pop();r.sceneManager.removeObserver(i,c)}for(;o.length;){const[i,c]=o.pop();r.sceneManager.removeObserver(i,c)}r.sceneManager.stopEventLoop(l.renderWindow),b&&(b.disconnect(),b=null),r.unbindCanvasToDOM(l.renderWindow)});function B(i){S(n,r,i)()}return{container:h,update:p,resetCamera:L,evalStateExtract:B,invoke:F,printSceneManagerInformation:N}},template:'<div ref="container" style="position: relative; width: 100%; height: 100%;"></div>'}};function k(l){Object.keys(w).forEach(e=>{l.component(e,w[e])})}M.install=k,Object.defineProperty(M,Symbol.toStringTag,{value:"Module"})});
