# Reusable workflow intended to be called as a job by other workflows

# Deploys the project to the k8s-hosted web app on STFC infrastructure

name: Job - Deploy to k8s
run-name: Deploy to k8s
on:
  workflow_call:  # allow this workflow to be called from other workflows
    inputs:
      environment: # pass the environment, used for targettinbg env specific K8s manifests
        required: true
        type: string
      container_tag: # define our version tag created from the upstream container build job
        description: 'The latest tag for the container'
        required: true
        type: string
jobs:
  deploy-k8s:
    environment: ${{ inputs.environment }}
    # run on our self hosted github runners enabling access to STFC infrastructure
    runs-on: psdi-uk-runners 
    steps:
      - uses: actions/checkout@v4
      - name: Test kubectl/kustomize with env secret
        env:
          KUBECONF: ${{ secrets.KUBECONF }}
          IMAGEPULLSECRET: ${{ secrets.IMAGE_PULL_PAT }}
          CERTIFICATE_PRIVATE_KEY: ${{ secrets.CERTIFICATE_PRIVATE_KEY }}
          CERTIFICATE_PEM: ${{ secrets.CERTIFICATE_PEM }}
        run: |
          # update the system
          sudo apt-get update && sudo apt install curl -y
          # install kubectl
          curl -LO "https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x ./kubectl
          sudo mv ./kubectl /usr/local/bin/kubectl
          # install kustomize to get access to the 'edit' command enabling image tag updates
          curl -L --output /tmp/kustomize.tar.gz "https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv5.4.3/kustomize_v5.4.3_linux_amd64.tar.gz"
          sudo tar xvzf /tmp/kustomize.tar.gz -C /usr/local/bin
          # create directory for K8s configuration
          mkdir -p "$HOME/.kube"
          # create local kubeconfig from github secret
          echo "$KUBECONF" | base64 -d > $HOME/.kube/config
          # create K8s secrets from Github Actions Secrets
          # ImagePullSecret from PAT
          # base64 decode the secret
          IMAGEPULLSECRET="$(echo $IMAGEPULLSECRET | base64 -d)"
          # create the secret from the variable - we use a hardcoded docker-username because the PAT is coupled to a user account - downstream we will use GitHub Apps
          kubectl create secret --dry-run=client docker-registry github-psdi-registry-credentials --docker-server=ghcr.io --docker-username=stuart-stfc --docker-password="$IMAGEPULLSECRET" -o yaml | kubectl apply -f -
          # tls secret - referenced from ingress
          # create the files from base64 encoded variables
          echo "$CERTIFICATE_PEM" | base64 -d > cert.pem
          echo "$CERTIFICATE_PRIVATE_KEY" | base64 -d > cert.key
          # create the secret from the files
          kubectl create secret tls psdi-ac-uk-tls --key cert.key --cert cert.pem --dry-run=client -o yaml | kubectl apply -f -
          # use passed tag to set VERSION variable
          CONTAINER_TAG="${{ inputs.container_tag }}"
          # Apply version specific kustomizations
          # change context
          DEPLOY_ENV="${{ inputs.environment }}"
          cd deploy/$DEPLOY_ENV
          # update image with version passed from upstream build job
          kustomize edit set image data-conversion=ghcr.io/psdi-uk/psdi-data-conversion/data-conversion:$CONTAINER_TAG
          # return to root of repository
          cd -
          # Apply env specific kustomizations
          kubectl apply -k deploy/$DEPLOY_ENV
