"""
Network Vulnerability Scanner

This module provides functions to check common security vulnerabilities in network services
including FTP, Telnet, HTTP, and HTTPS. Each function performs specific security checks
and returns structured results about potential vulnerabilities.
"""

import ftplib
import telnetlib
import http.client
import ssl
import socket
import datetime
from typing import Dict, List, Any, Optional, Tuple

# Constants for common values
DEFAULT_TIMEOUT = 3
HIGH_SEVERITY = 'High'
MEDIUM_SEVERITY = 'Medium'
LOW_SEVERITY = 'Medium'

# Security headers that should be present in HTTP/HTTPS responses
RECOMMENDED_SECURITY_HEADERS = {
    'x-frame-options': 'Prevents clickjacking attacks',
    'x-xss-protection': 'Helps prevent cross-site scripting attacks',
    'content-security-policy': 'Restricts sources of executable scripts',
    'strict-transport-security': 'Enforces HTTPS connections',
    'x-content-type-options': 'Prevents MIME type sniffing'
}

def check_ftp_anonymous(ip: str, timeout: int = DEFAULT_TIMEOUT) -> Dict[str, Any]:
    """
    Test if the FTP server allows anonymous connections.
    
    Args:
        ip: IP address of the target server
        timeout: Connection timeout in seconds
        
    Returns:
        Dictionary with vulnerability assessment results
    """
    try:
        ftp = ftplib.FTP()
        ftp.connect(ip, 21, timeout=timeout)
        ftp.login('anonymous', 'anonymous@example.com')
        
        # Anonymous connection successful
        welcome = ftp.getwelcome()
        directories = []
        try:
            directories = ftp.nlst()
        except ftplib.error_perm as e:
            # Permission error but still connected
            pass
        except Exception as e:
            # Other errors during directory listing
            pass
        
        ftp.quit()
        return {
            'vulnerable': True,
            'details': f"Anonymous FTP login allowed. Welcome message: {welcome}",
            'directories': directories[:10] if len(directories) > 10 else directories
        }
    except (socket.timeout, socket.error) as e:
        return {
            'vulnerable': False,
            'details': f"Connection failed: {str(e)}"
        }
    except ftplib.error_perm as e:
        return {
            'vulnerable': False,
            'details': f"Anonymous login rejected: {str(e)}"
        }
    except Exception as e:
        return {
            'vulnerable': False,
            'details': f"FTP check failed: {str(e)}"
        }

def check_telnet_open(ip: str, timeout: int = DEFAULT_TIMEOUT) -> Dict[str, Any]:
    """
    Test if Telnet service is open and accessible.
    
    Args:
        ip: IP address of the target server
        timeout: Connection timeout in seconds
        
    Returns:
        Dictionary with vulnerability assessment results
    """
    try:
        tn = telnetlib.Telnet(ip, 23, timeout=timeout)
        welcome = tn.read_until(b"\n", timeout=1).decode('ascii', errors='ignore')
        tn.close()
        return {
            'vulnerable': True,
            'details': f"Telnet service is open. Banner: {welcome.strip()}"
        }
    except (socket.timeout, ConnectionRefusedError) as e:
        return {
            'vulnerable': False,
            'details': f"Connection failed: {str(e)}"
        }
    except Exception as e:
        return {
            'vulnerable': False,
            'details': f"Telnet check failed: {str(e)}"
        }

def check_http_basic(ip: str, port: int = 80, timeout: int = DEFAULT_TIMEOUT) -> Dict[str, Any]:
    """
    Test HTTP access and verify security headers.
    
    Args:
        ip: IP address of the target server
        port: HTTP port to check
        timeout: Connection timeout in seconds
        
    Returns:
        Dictionary with vulnerability assessment results
    """
    try:
        conn = http.client.HTTPConnection(ip, port, timeout=timeout)
        conn.request("HEAD", "/")
        response = conn.getresponse()
        
        headers = {h[0].lower(): h[1] for h in response.getheaders()}
        security_issues = []
        
        # Check for missing security headers
        for header, description in RECOMMENDED_SECURITY_HEADERS.items():
            if header not in headers:
                # Only check HSTS on HTTPS
                if header == 'strict-transport-security' and port != 443:
                    continue
                security_issues.append(f"Missing {header} ({description})")
        
        server = headers.get('server', 'Unknown')
        
        conn.close()
        
        return {
            'vulnerable': len(security_issues) > 0,
            'details': f"HTTP Server: {server}",
            'missing_security_headers': security_issues,
            'status_code': response.status,
            'headers': {k: v for k, v in headers.items() if k in [
                'server', 'x-powered-by', 'via'
            ]}
        }
    except (socket.timeout, ConnectionRefusedError) as e:
        return {
            'vulnerable': False,
            'details': f"Connection failed: {str(e)}"
        }
    except Exception as e:
        return {
            'vulnerable': False,
            'details': f"HTTP check failed: {str(e)}"
        }

def check_https_ssl(ip: str, port: int = 443, timeout: int = DEFAULT_TIMEOUT) -> Dict[str, Any]:
    """
    Test for common SSL/TLS issues.
    
    Args:
        ip: IP address of the target server
        port: HTTPS port to check
        timeout: Connection timeout in seconds
        
    Returns:
        Dictionary with vulnerability assessment results
    """
    try:
        context = ssl.create_default_context()
        with socket.create_connection((ip, port), timeout=timeout) as sock:
            with context.wrap_socket(sock, server_hostname=ip) as ssock:
                cert = ssock.getpeercert()
                
                # Check for certificate validity
                if not cert:
                    return {
                        'vulnerable': True,
                        'details': "SSL certificate validation failed"
                    }
                
                # Check expiration date
                expires = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                remaining = expires - datetime.datetime.utcnow()
                
                security_issues = []
                
                if remaining.days < 0:
                    security_issues.append(f"Certificate expired on {expires.strftime('%Y-%m-%d')}")
                elif remaining.days < 30:
                    security_issues.append(f"Certificate expires soon ({expires.strftime('%Y-%m-%d')})")
                
                # Get protocol version
                version = ssock.version()
                cipher = ssock.cipher()
                
                if version in ["TLSv1", "TLSv1.1"]:
                    security_issues.append(f"Outdated TLS protocol version: {version}")
                
                # Check for weak ciphers
                if cipher and ('NULL' in cipher[0] or 'RC4' in cipher[0] or 'MD5' in cipher[0]):
                    security_issues.append(f"Weak cipher suite in use: {cipher[0]}")
                
                return {
                    'vulnerable': len(security_issues) > 0,
                    'details': f"SSL/TLS using {version}",
                    'security_issues': security_issues,
                    'cert_expires': expires.strftime('%Y-%m-%d'),
                    'cert_subject': cert.get('subject', []),
                    'cert_issuer': cert.get('issuer', []),
                    'cipher_suite': cipher[0] if cipher else 'Unknown'
                }
                
    except ssl.SSLError as e:
        return {
            'vulnerable': True,
            'details': f"SSL error: {str(e)}",
            'security_issues': [f"SSL configuration error: {str(e)}"]
        }
    except (socket.timeout, ConnectionRefusedError) as e:
        return {
            'vulnerable': False,
            'details': f"Connection failed: {str(e)}"
        }
    except Exception as e:
        return {
            'vulnerable': False,
            'details': f"SSL check failed: {str(e)}"
        }

def check_vulnerabilities(ip: str, port: int, service: str) -> List[Dict[str, Any]]:
    """
    Execute specific vulnerability tests based on detected service.
    
    Args:
        ip: IP address of the target
        port: Port number
        service: Service name (FTP, Telnet, HTTP, HTTPS, etc.)
        
    Returns:
        List of detected vulnerabilities with details
    """
    vulnerabilities = []
    
    # Map services to their vulnerability check functions
    service_checks = {
        ("FTP", 21): [
            (check_ftp_anonymous, {
                'type': 'Anonymous FTP',
                'severity': HIGH_SEVERITY,
                'description': "Anonymous FTP login allowed"
            })
        ],
        ("Telnet", 23): [
            (check_telnet_open, {
                'type': 'Telnet Enabled',
                'severity': HIGH_SEVERITY,
                'description': "Telnet service is enabled and accessible. This protocol transmits data in cleartext and should be replaced with SSH."
            })
        ],
        ("HTTP", 80): [
            (check_http_basic, {
                'type': 'HTTP Security Headers',
                'severity': MEDIUM_SEVERITY,
                'description': "Missing important security headers in HTTP response"
            })
        ],
        ("HTTP", 8080): [
            (check_http_basic, {
                'type': 'HTTP Security Headers',
                'severity': MEDIUM_SEVERITY,
                'description': "Missing important security headers in HTTP response"
            })
        ],
        ("HTTPS", 443): [
            (check_https_ssl, {
                'type': 'SSL/TLS Issues',
                'severity': MEDIUM_SEVERITY,
                'description': "SSL/TLS configuration has security issues"
            }),
            (lambda ip: check_http_basic(ip, 443), {
                'type': 'HTTPS Security Headers',
                'severity': MEDIUM_SEVERITY,
                'description': "Missing important security headers in HTTPS response"
            })
        ]
    }
    
    # Execute checks for the given service and port
    for (check_service, check_port), checks in service_checks.items():
        if service == check_service and port == check_port:
            for check_func, vuln_template in checks:
                result = check_func(ip)
                if result.get('vulnerable', False):
                    vulnerability = vuln_template.copy()
                    
                    # Add specific details from the check result
                    if 'details' in result:
                        vulnerability['details'] = result['details']
                    
                    if 'missing_security_headers' in result:
                        vulnerability['missing_headers'] = result['missing_security_headers']
                    
                    if 'security_issues' in result:
                        vulnerability['issues'] = result['security_issues']
                    
                    if 'directories' in result:
                        vulnerability['directories'] = result['directories']
                    
                    if 'headers' in result:
                        vulnerability['server_headers'] = result['headers']
                    
                    vulnerabilities.append(vulnerability)
    
    return vulnerabilities