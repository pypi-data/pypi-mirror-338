"""
Tests for the vulnerability_checker module

These tests verify the functionality of the network vulnerability scanner
without making actual network connections.
"""

import pytest
from unittest.mock import patch, MagicMock
import socket
import ftplib
import datetime
import ssl

from core.vulnerability_checker import (
    check_ftp_anonymous,
    check_telnet_open,
    check_http_basic,
    check_https_ssl,
    check_vulnerabilities,
    HIGH_SEVERITY,
    MEDIUM_SEVERITY
)

# FTP Tests
@pytest.fixture
def mock_ftp():
    with patch('ftplib.FTP') as mock:
        ftp_instance = MagicMock()
        mock.return_value = ftp_instance
        ftp_instance.getwelcome.return_value = "FTP Server Ready"
        ftp_instance.nlst.return_value = ["file1.txt", "file2.txt", "backup"]
        yield mock

def test_ftp_anonymous_vulnerable(mock_ftp):
    """Test FTP server allowing anonymous login"""
    result = check_ftp_anonymous("192.168.1.1")
    
    assert result['vulnerable'] is True
    assert "Anonymous FTP login allowed" in result['details']
    assert len(result['directories']) == 3
    assert "file1.txt" in result['directories']

def test_ftp_anonymous_not_vulnerable(mock_ftp):
    """Test FTP server rejecting anonymous login"""
    mock_ftp.return_value.login.side_effect = ftplib.error_perm("530 Login incorrect")
    
    result = check_ftp_anonymous("192.168.1.1")
    
    assert result['vulnerable'] is False
    assert "Anonymous login rejected" in result['details']

def test_ftp_connection_error(mock_ftp):
    """Test FTP connection failure"""
    mock_ftp.return_value.connect.side_effect = socket.timeout("Connection timed out")
    
    result = check_ftp_anonymous("192.168.1.1")
    
    assert result['vulnerable'] is False
    assert "Connection failed" in result['details']

# Telnet Tests
@pytest.fixture
def mock_telnet():
    with patch('telnetlib.Telnet') as mock:
        telnet_instance = MagicMock()
        mock.return_value = telnet_instance
        telnet_instance.read_until.return_value = b"Welcome to Telnet Server\n"
        yield mock

def test_telnet_vulnerable(mock_telnet):
    """Test accessible Telnet server"""
    result = check_telnet_open("192.168.1.1")
    
    assert result['vulnerable'] is True
    assert "Telnet service is open" in result['details']
    assert "Welcome to Telnet Server" in result['details']

def test_telnet_connection_error(mock_telnet):
    """Test Telnet connection failure"""
    mock_telnet.side_effect = ConnectionRefusedError("Connection refused")
    
    result = check_telnet_open("192.168.1.1")
    
    assert result['vulnerable'] is False
    assert "Connection failed" in result['details']

# HTTP Tests
@pytest.fixture
def mock_http_connection():
    with patch('http.client.HTTPConnection') as mock:
        conn_instance = MagicMock()
        mock.return_value = conn_instance
        
        response = MagicMock()
        response.status = 200
        response.getheaders.return_value = [
            ('Server', 'Apache/2.4.41'),
            ('Content-Type', 'text/html')
        ]
        
        conn_instance.getresponse.return_value = response
        yield mock, response

def test_http_missing_security_headers(mock_http_connection):
    """Test HTTP server with missing security headers"""
    mock, _ = mock_http_connection
    
    result = check_http_basic("192.168.1.1")
    
    assert result['vulnerable'] is True
    assert "HTTP Server: Apache" in result['details']
    assert len(result['missing_security_headers']) > 0
    assert any("x-frame-options" in issue.lower() for issue in result['missing_security_headers'])

def test_http_with_security_headers(mock_http_connection):
    """Test HTTP server with all security headers"""
    _, response = mock_http_connection
    response.getheaders.return_value = [
        ('Server', 'Apache/2.4.41'),
        ('X-Frame-Options', 'DENY'),
        ('X-XSS-Protection', '1; mode=block'),
        ('Content-Security-Policy', "default-src 'self'"),
        ('X-Content-Type-Options', 'nosniff')
    ]
    
    result = check_http_basic("192.168.1.1")
    
    assert result['vulnerable'] is False

def test_http_connection_error(mock_http_connection):
    """Test HTTP connection failure"""
    mock, _ = mock_http_connection
    mock.side_effect = ConnectionRefusedError("Connection refused")
    
    result = check_http_basic("192.168.1.1")
    
    assert result['vulnerable'] is False
    assert "Connection failed" in result['details']

# HTTPS/SSL Tests
@pytest.fixture
def mock_ssl_connection():
    with patch('socket.create_connection') as mock_socket:
        with patch('ssl.create_default_context') as mock_context:
            # Create mock socket
            socket_instance = MagicMock()
            mock_socket.return_value = socket_instance
            mock_socket.return_value.__enter__.return_value = socket_instance
            
            # Create mock SSL context and socket
            context_instance = MagicMock()
            mock_context.return_value = context_instance
            
            ssl_socket = MagicMock()
            context_instance.wrap_socket.return_value.__enter__.return_value = ssl_socket
            
            # Set default certificate (valid)
            future_date = datetime.datetime.utcnow() + datetime.timedelta(days=90)
            cert_date = future_date.strftime('%b %d %H:%M:%S %Y GMT')
            
            ssl_socket.getpeercert.return_value = {
                'notAfter': cert_date,
                'subject': ((('commonName', 'example.com'),),),
                'issuer': ((('commonName', 'Example CA'),),)
            }
            
            # Set default TLS version and cipher
            ssl_socket.version.return_value = "TLSv1.2"
            ssl_socket.cipher.return_value = ("TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384", "TLSv1.2", 256)
            
            yield ssl_socket

def test_https_secure_configuration(mock_ssl_connection):
    """Test HTTPS with secure configuration"""
    result = check_https_ssl("192.168.1.1")
    
    assert result['vulnerable'] is False
    assert "SSL/TLS using TLSv1.2" in result['details']
    assert len(result.get('security_issues', [])) == 0

def test_https_outdated_protocol(mock_ssl_connection):
    """Test HTTPS with outdated TLS version"""
    mock_ssl_connection.version.return_value = "TLSv1"
    
    result = check_https_ssl("192.168.1.1")
    
    assert result['vulnerable'] is True
    assert "Outdated TLS protocol version" in result['security_issues'][0]

def test_https_weak_cipher(mock_ssl_connection):
    """Test HTTPS with weak cipher suite"""
    mock_ssl_connection.cipher.return_value = ("TLS_RSA_WITH_RC4_128_SHA", "TLSv1.2", 128)
    
    result = check_https_ssl("192.168.1.1")
    
    assert result['vulnerable'] is True
    assert "Weak cipher suite in use" in result['security_issues'][0]

def test_https_expiring_certificate(mock_ssl_connection):
    """Test HTTPS with certificate expiring soon"""
    near_future = datetime.datetime.utcnow() + datetime.timedelta(days=15)
    cert_date = near_future.strftime('%b %d %H:%M:%S %Y GMT')
    mock_ssl_connection.getpeercert.return_value['notAfter'] = cert_date
    
    result = check_https_ssl("192.168.1.1")
    
    assert result['vulnerable'] is True
    assert "Certificate expires soon" in result['security_issues'][0]

def test_https_ssl_error():
    """Test HTTPS with SSL error"""
    with patch('socket.create_connection'):
        with patch('ssl.create_default_context'):
            with patch('ssl.SSLContext.wrap_socket', side_effect=ssl.SSLError("SSL handshake failed")):
                result = check_https_ssl("192.168.1.1")
                
                assert result['vulnerable'] is True
                assert "SSL error" in result['details']

# Main function tests
def test_check_vulnerabilities_ftp():
    """Test vulnerability checking for FTP service"""
    with patch('core.vulnerability_checker.check_ftp_anonymous') as mock_check:
        mock_check.return_value = {
            'vulnerable': True,
            'details': "Anonymous FTP login allowed",
            'directories': ["file1.txt", "private"]
        }
        
        result = check_vulnerabilities("192.168.1.1", 21, "FTP")
        
        assert len(result) == 1
        assert result[0]['type'] == 'Anonymous FTP'
        assert result[0]['severity'] == HIGH_SEVERITY
        assert 'directories' in result[0]
        assert "file1.txt" in result[0]['directories']

def test_check_vulnerabilities_http():
    """Test vulnerability checking for HTTP service"""
    with patch('core.vulnerability_checker.check_http_basic') as mock_check:
        mock_check.return_value = {
            'vulnerable': True,
            'details': "HTTP Server: Apache",
            'missing_security_headers': ["Missing x-frame-options"],
            'headers': {'server': 'Apache'}
        }
        
        result = check_vulnerabilities("192.168.1.1", 80, "HTTP")
        
        assert len(result) == 1
        assert result[0]['type'] == 'HTTP Security Headers'
        assert result[0]['severity'] == MEDIUM_SEVERITY
        assert 'missing_headers' in result[0]

def test_check_vulnerabilities_https():
    """Test vulnerability checking for HTTPS service"""
    with patch('core.vulnerability_checker.check_https_ssl') as mock_ssl:
        with patch('core.vulnerability_checker.check_http_basic') as mock_http:
            mock_ssl.return_value = {
                'vulnerable': True,
                'details': "SSL/TLS using TLSv1",
                'security_issues': ["Outdated TLS protocol version: TLSv1"]
            }
            mock_http.return_value = {'vulnerable': False}
            
            result = check_vulnerabilities("192.168.1.1", 443, "HTTPS")
            
            assert len(result) == 1
            assert result[0]['type'] == 'SSL/TLS Issues'
            assert 'issues' in result[0]
            assert "Outdated TLS protocol version" in result[0]['issues'][0]

def test_check_vulnerabilities_unknown_service():
    """Test vulnerability checking for unknown service"""
    result = check_vulnerabilities("192.168.1.1", 22, "SSH")
    
    assert len(result) == 0